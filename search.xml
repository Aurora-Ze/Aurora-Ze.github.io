<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>字节码指令</title>
    <url>/2021/12/13/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><h2 id="一、结构"><a href="#一、结构" class="headerlink" title="一、结构"></a>一、结构</h2><h3 id="1-1-简单定义"><a href="#1-1-简单定义" class="headerlink" title="1.1 简单定义"></a>1.1 简单定义</h3><blockquote>
<p>Java虚拟机的指令是由<strong>一个字节长度</strong>的、<strong>代表着某种特定操作</strong>含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。</p>
</blockquote>
<p>简单来说，指令就是由一个字节的<strong>操作码</strong>和若干个<strong>参数</strong>构成。</p>
<p>另外， 因为Java虚拟机采用的是<strong>面向操作数栈</strong>的架构，所以大多数指令只有一个操作码，而操作数被放在了操作数栈中。</p>
<h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><p>从上面的定义中，我们可以发现，</p>
<ul>
<li><p>操作码总数不能超过256</p>
<p>既然操作码只占了一个字节，那么<code>1字节 = 8比特，2^8 = 256</code>，即最多能表示<code>256</code>条指令</p>
</li>
<li><p>编译后Class文件中代码的操作数长度不对齐</p>
</li>
</ul>
<p>这种字节码结构有着明显的优势和劣势：</p>
<ul>
<li><p>优势</p>
<p>省略了大量的填充和间隔符号，编译代码更加精简</p>
</li>
<li><p>劣势</p>
<p>处理超过一个字节的数据时，会因为重建而损失性能</p>
</li>
</ul>
<h3 id="1-3-执行模型"><a href="#1-3-执行模型" class="headerlink" title="1.3 执行模型"></a>1.3 执行模型</h3><p>不考虑异常处理的话，可以用以下代码来表示Java虚拟机的解释器的执行过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	自动计算PC寄存器的值加<span class="number">1</span></span><br><span class="line">	根据PC寄存器指示的位置，从字节码流中取出操作码</span><br><span class="line">	<span class="keyword">if</span> (字节码存在操作数) &#123;</span><br><span class="line">		从字节码流中取出操作数</span><br><span class="line">	&#125;</span><br><span class="line">	执行操作码所定义的操作</span><br><span class="line">&#125; <span class="keyword">while</span> (字节码流的长度 &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="二、类别"><a href="#二、类别" class="headerlink" title="二、类别"></a>二、类别</h2><p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。</p>
<p>前面我们知道了指令集不能超过256条，而Java的数据类型有很多，如果针对每一种类型，都划分出专门的指令去操作它，可能就会溢出。</p>
<p>那么Java虚拟机是怎么做的呢？</p>
<p>在将这些之前，我们先要了解两个概念。</p>
<h3 id="2-1-符号扩展和零位扩展"><a href="#2-1-符号扩展和零位扩展" class="headerlink" title="2.1 符号扩展和零位扩展"></a>2.1 符号扩展和零位扩展</h3><ul>
<li><p>符号扩展，扩展时，前面全部补上符号位</p>
</li>
<li><p>零位扩展，扩展时前面全部补零</p>
</li>
</ul>
<p>我们用一个例子来表示说明一下这两个概念，假设现在有两个数<code>+3</code>和<code>-3</code></p>
<p>它们用8位的原码表示分别是<code>00000011</code>和<code>10000011</code></p>
<p>现在我们要把它扩展到用16位来表示，就会产生如下结果</p>
<table>
<thead>
<tr>
<th align="center">数字</th>
<th align="center">符号扩展</th>
<th align="center">零位扩展</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+3</td>
<td align="center">0000000000000011</td>
<td align="center">0000000000000011</td>
</tr>
<tr>
<td align="center">-3</td>
<td align="center">1111111110000011</td>
<td align="center">0000000010000011</td>
</tr>
</tbody></table>
<p>我们可以看到，对于正数而言，符号扩展和零位扩展是没有区别的；而负数的话就是扩展的数字不同。</p>
<p>这两个概念和我们所说的溢出又有什么关系呢？</p>
<p><strong>其实设计者为了让指令集不会溢出（或者说，复用一些指令），就让编译器在编译或运行时期，把byte和short类型的数据带符号扩展为int类型，把boolean和char类型数据零位扩展成int类型。</strong></p>
<p>这样就不必对这四个类型单独再分配一些指令来处理了。</p>
<h3 id="2-2-加载和存储指令"><a href="#2-2-加载和存储指令" class="headerlink" title="2.2 加载和存储指令"></a>2.2 加载和存储指令</h3><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。例如：</p>
<ul>
<li>把一个局部变量加载到操作栈中：iload，fload，dload</li>
<li>把一个数值从操作数栈存储到局部变量表中：istore，lstore</li>
<li>把一个常量加载到操作数栈：bipush，sipush</li>
</ul>
<h3 id="2-3-运算指令"><a href="#2-3-运算指令" class="headerlink" title="2.3 运算指令"></a>2.3 运算指令</h3><p>算术指令用于对操作数栈上的两个值进行某种特定运算，并把结果重新存入到操作栈顶。</p>
<p>这里有两个<strong>注意点</strong>，</p>
<p><strong>一是之前提过的byte，short，char，boolean是用int类型指令操作的</strong></p>
<p><strong>二是计算浮点数时，会碰到取舍的问题</strong></p>
<p>先介绍下<strong>两种舍入模式</strong>：</p>
<ol>
<li>向最接近数舍入</li>
<li>向零舍入</li>
</ol>
<p>浮点数之间的计算，采用第一种向最接近数舍入，如果是浮点数转整型，采用向零舍入模式</p>
<p>我们可以回想下，Java中浮点数之间计算后，结果并不是严格准确的；浮点数转整型，会丢弃小数部分；</p>
<p>这些都和舍入模式相匹配。</p>
<h3 id="2-4-类型转换指令"><a href="#2-4-类型转换指令" class="headerlink" title="2.4 类型转换指令"></a>2.4 类型转换指令</h3><p>用于对类型的<strong>显式转换</strong>；如果是隐式的（如int转long）就不用这些指令，因为虚拟机直接支持。</p>
<p>注意，转换时可能会出现不同的正负号，因为long转int是简单的丢弃多余的高位部分，所以如果原来是负数，转换后可能就是正数了。</p>
<p>对于浮点型的转换，</p>
<ul>
<li>如果是NaN，则转成int或long的0</li>
<li>如果不是无穷大，则按向零舍入来取整<ul>
<li>如果取整后在范围内，则直接用</li>
<li>如果不在范围内，根据符号取边界值</li>
</ul>
</li>
</ul>
<h3 id="2-5-对象创建与访问指令"><a href="#2-5-对象创建与访问指令" class="headerlink" title="2.5 对象创建与访问指令"></a>2.5 对象创建与访问指令</h3><p>Java中的对象包括类实例和数组，创建他们所采用的字节码并不同。</p>
<p>对象创建完毕后，可以通过访问指令来获取对象实例（或数组实例）中的字段（或数组元素）。</p>
<h3 id="2-6-操作数栈管理指令"><a href="#2-6-操作数栈管理指令" class="headerlink" title="2.6 操作数栈管理指令"></a>2.6 操作数栈管理指令</h3><p>用于管理操作数栈中的元素</p>
<h3 id="2-7-控制转移指令"><a href="#2-7-控制转移指令" class="headerlink" title="2.7 控制转移指令"></a>2.7 控制转移指令</h3><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令的下一条指令继续执行程序。</p>
<h3 id="2-8-方法调用和返回指令"><a href="#2-8-方法调用和返回指令" class="headerlink" title="2.8 方法调用和返回指令"></a>2.8 方法调用和返回指令</h3><p>方法调用（分派、执行过程）将会在以后介绍。</p>
<p>方法调用有一系列以”invoke”开头的指令</p>
<p>返回有一系列以“return”结尾的指令</p>
<h3 id="2-9-异常处理指令"><a href="#2-9-异常处理指令" class="headerlink" title="2.9 异常处理指令"></a>2.9 异常处理指令</h3><p>关于异常，有三种来源：</p>
<ul>
<li>Java程序显式抛出，由athrow指令实现</li>
<li>Java程序try catch处理，用<code>异常表</code>来完成</li>
<li>程序发生异常状况，自动抛出</li>
</ul>
<h3 id="2-10-同步指令"><a href="#2-10-同步指令" class="headerlink" title="2.10 同步指令"></a>2.10 同步指令</h3><p>Java虚拟机支持两种同步：<strong>方法级的同步</strong>和方法内部<strong>一段指令序列</strong>的同步。</p>
<p>这两种同步都是靠管程（或者说锁）来实现的</p>
<h4 id="对于方法级的同步"><a href="#对于方法级的同步" class="headerlink" title="对于方法级的同步"></a>对于方法级的同步</h4><p>它是隐式的，不用字节码指令来控制</p>
<p>因为方法的访问标志里如果声明了<code>ACC_SYNCHRONIZED</code>，就能够表示它是同步方法</p>
<p>然后在方法<strong>执行线程</strong>就要<strong>先获取管程，才能执行方法</strong>，方法结束后就会释放管程</p>
<h4 id="对于指令序列的同步"><a href="#对于指令序列的同步" class="headerlink" title="对于指令序列的同步"></a>对于指令序列的同步</h4><p>它通常是由<code>synchronized</code>关键字声明的</p>
<p>Java虚拟机的指令集中有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持<code>synchronized</code></p>
<p><strong>实现<code>synchronized</code>指令，是<code>Javac编译器</code>和<code>Java虚拟机</code>共同协作的结果</strong></p>
<p>怎么理解这句话呢？</p>
<p>这就要谈谈这两个指令的用法了，这<strong>两条指令</strong>是加在同步指令序列的<strong>两端</strong>（开始和结束处），来<strong>保证同步性</strong>。</p>
<p><strong>如果指令正常执行，毫无疑问能配对成功。</strong></p>
<p><strong>如果执行到一般发生异常了，这时候被迫跳出同步指令序列，即只执行了<code>monitorenter</code>，而没有执行到<code>monitorexit</code></strong></p>
<p>那怎么办呢？这就要看编译器了</p>
<blockquote>
<p>在编译时，为了保证方法异常时，monitorenter和monitorexit指令仍能够配对，编译器自动生成一个异常处理程序，声明可处理所有的异常，然后只要在monitorexit后面再来条相同的指令，就能成功配对了。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/13/HelloWorld/</url>
    <content><![CDATA[<h1 id="记录博客用法"><a href="#记录博客用法" class="headerlink" title="记录博客用法"></a>记录博客用法</h1><h2 id="一、按钮"><a href="#一、按钮" class="headerlink" title="一、按钮"></a>一、按钮</h2><h3 id="1-描述"><a href="#1-描述" class="headerlink" title="1.描述"></a>1.描述</h3><blockquote>
<p>点击按钮后，显示隐藏的内容</p>
</blockquote>
<h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h3><p>哪个英文字母最酷？</p>
<h2 id="二、文章front-matter"><a href="#二、文章front-matter" class="headerlink" title="二、文章front-matter"></a>二、文章front-matter</h2><h3 id="1-描述-1"><a href="#1-描述-1" class="headerlink" title="1.描述"></a>1.描述</h3><p>用来表示文章的一些信息，如标题、类别、tag和封面等</p>
<h3 id="2-用法-1"><a href="#2-用法-1" class="headerlink" title="2.用法"></a>2.用法</h3><table>
<thead>
<tr>
<th align="center">键</th>
<th align="center">值（例子）</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">title</td>
<td align="center">Hello World</td>
<td align="center">文章标题</td>
</tr>
<tr>
<td align="center">categories</td>
<td align="center">线程池</td>
<td align="center">文章类别所属</td>
</tr>
<tr>
<td align="center">tags</td>
<td align="center">-tag: 源码</td>
<td align="center">文章标签，可包含多个</td>
</tr>
<tr>
<td align="center">cover</td>
<td align="center"><a href="https://gitee.com/aurora1004/pictures/raw/master/wps.jpg">https://gitee.com/aurora1004/pictures/raw/master/wps.jpg</a></td>
<td align="center">文章外封面</td>
</tr>
<tr>
<td align="center">top_img</td>
<td align="center"><a href="https://gitee.com/aurora1004/pictures/raw/master/wps.jpg">https://gitee.com/aurora1004/pictures/raw/master/wps.jpg</a></td>
<td align="center">文章内部，顶部图片</td>
</tr>
<tr>
<td align="center">top</td>
<td align="center">100</td>
<td align="center">权重值，越大越容易置顶</td>
</tr>
</tbody></table>
<h2 id="三、代码配色修改"><a href="#三、代码配色修改" class="headerlink" title="三、代码配色修改"></a>三、代码配色修改</h2><h3 id="1-描述-2"><a href="#1-描述-2" class="headerlink" title="1.描述"></a>1.描述</h3><p>通过引入外部css文件来修改代码配色</p>
<h3 id="2-用法-2"><a href="#2-用法-2" class="headerlink" title="2.用法"></a>2.用法</h3><p>1.选择一个想要的样式文件，网址：<a href="https://github.com/highlightjs/highlight.js/tree/main/src/styles">代码配色相关css</a></p>
<p>2.在<code>\butterfly\source\self</code>路径下新建一个<code>css</code>文件（如<code>code1.css</code>），复制第一步中选择的<code>css代码</code></p>
<p>3.<code>code1.css</code>文件中添加以下代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 颜色可自己设置 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --hl-<span class="attribute">color</span>: <span class="number">#d3af86</span>;</span><br><span class="line">  --hl-bg: <span class="number">#221a0f</span>;</span><br><span class="line">  --hltools-bg: <span class="number">#321a0f</span>;</span><br><span class="line">  --hltools-<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  --hlnumber-bg: <span class="number">#221a0f</span>;</span><br><span class="line">  --hlnumber-<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  --hlscrollbar-bg: <span class="number">#d3af86</span>;</span><br><span class="line">  --hlexpand-bg: <span class="number">#d3af86</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更改的內容 把.hljs改為 #article-container figure.highlight .hljs */</span></span><br><span class="line">进行更改！！！！！</span><br></pre></td></tr></table></figure>

<p>4.在butterfly主题的配置文件中引入该css文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/self/code1.css&quot;&gt;</span>    </span><br></pre></td></tr></table></figure>

<h2 id="四、hexo相关命令"><a href="#四、hexo相关命令" class="headerlink" title="四、hexo相关命令"></a>四、hexo相关命令</h2><h3 id="1-本地启动博客"><a href="#1-本地启动博客" class="headerlink" title="1.本地启动博客"></a>1.本地启动博客</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h3 id="2-上传GitHub"><a href="#2-上传GitHub" class="headerlink" title="2.上传GitHub"></a>2.上传GitHub</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h3 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h3><p>如果遇到如下报错</p>
<blockquote>
<p>OpenSSL SSL_read: Connection was reset, errno 10054</p>
</blockquote>
<p>则在bash中输入以下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify <span class="string">&quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后重新来一遍即可。</p>
<h3 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/Aurora-Ze/Aurora-Ze.github.io.git/&#x27;</span>: Failed to connect to github.com port 443: Timed out</span><br><span class="line"></span><br><span class="line">err: Error: Spawn failed</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<ol>
<li>删除<code>.deploy_git</code>文件夹</li>
<li>执行命令<code>git config --global core.autocrlf false</code></li>
<li>重新来一套部署命令</li>
</ol>
<h3 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h3><p>如果用了梯子，把代理的端口号设置上去</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:4780 // 我的梯子用了4780的端口</span><br><span class="line">git config --global https.proxy http://127.0.0.1:4780</span><br></pre></td></tr></table></figure>



<h2 id="五、常用latex符号"><a href="#五、常用latex符号" class="headerlink" title="五、常用latex符号"></a>五、常用latex符号</h2><h3 id="1-上标下标"><a href="#1-上标下标" class="headerlink" title="1.上标下标"></a>1.上标下标</h3><p>上标用<code>^</code>表示，下标用<code>_</code>表示；例如，$2^3_3$</p>
<h3 id="2-大于等于……"><a href="#2-大于等于……" class="headerlink" title="2.大于等于……"></a>2.大于等于……</h3><p>大于等于用<code>\geq\</code>；例如$4 \geq\ 3$</p>
<h3 id="3-处理多个变量"><a href="#3-处理多个变量" class="headerlink" title="3.处理多个变量"></a>3.处理多个变量</h3><p>表示2的n-1次方时，n-1用<code>&#123;&#125;</code>包裹，如$2^{n-1}$</p>
<h3 id="4-波浪号"><a href="#4-波浪号" class="headerlink" title="4.波浪号"></a>4.波浪号</h3><p>波浪号用<code>\sim</code>来表示，如$\sim$</p>
<h2 id="六、Typora实用快捷键"><a href="#六、Typora实用快捷键" class="headerlink" title="六、Typora实用快捷键"></a>六、Typora实用快捷键</h2><h3 id="1-文本增加-减少缩进"><a href="#1-文本增加-减少缩进" class="headerlink" title="1.文本增加/减少缩进"></a>1.文本增加/减少缩进</h3><p>有时从编辑器里拷贝过来的代码，在代码块中总是会有四格的缩进，没有贴靠左侧。</p>
<p>因此可以选中想要缩进的内容后，使用<code>ctrl + [</code>来减小缩进。</p>
<p><strong>原来效果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">batchSelectUsersById</span><span class="params">(List&lt;Long&gt; ids)</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectBatchIds(ids);</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缩进后效果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">batchSelectUsersById</span><span class="params">(List&lt;Long&gt; ids)</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectBatchIds(ids);</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、IDEA快捷键"><a href="#七、IDEA快捷键" class="headerlink" title="七、IDEA快捷键"></a>七、IDEA快捷键</h2><h3 id="Code-Glance插件开启-关闭"><a href="#Code-Glance插件开启-关闭" class="headerlink" title="Code Glance插件开启/关闭"></a>Code Glance插件开启/关闭</h3><p><code>ctrl shift g</code></p>
<h2 id="八、VSCode快捷键"><a href="#八、VSCode快捷键" class="headerlink" title="八、VSCode快捷键"></a>八、VSCode快捷键</h2><p>最近在写前端，发现vscode的快捷键不好设置，于是记录一下常用的</p>
<ol>
<li>光标跳转到下一行：<code>ctrl + enter</code></li>
<li>代码整理：<code>shift + alt + f</code></li>
<li>打开/关闭终端：<code>ctrl + ·(esc下面那个)</code></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>类文件结构</title>
    <url>/2021/12/13/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>我们所写的程序想要被计算机执行，有两种方式，第一种是<strong>编译成由0和1组成的二进制格式，让计算机执行。</strong></p>
<p>而随着虚拟机的蓬勃发展，大量的程序语言建立在虚拟机的基础上，所以产生了第二种编译方式，即：</p>
<p><strong>编译成与操作系统和机器指令集无关的、平台中立的文件存储格式</strong></p>
<p>这也正是<code>字节码</code>文件的由来。</p>
<h3 id="二、介绍"><a href="#二、介绍" class="headerlink" title="二、介绍"></a>二、介绍</h3><p>Java文件通过编译器编译，得到**Class文件(字节码文件)**，然后再通过JVM来执行。</p>
<p>但是为了让虚拟机知道这是字节码文件，就需要严格定义字节码文件的格式</p>
<p>因此在Class文件中，它的每个数据项的顺序和数量，甚至存储的字节序（统一使用Big Endian），都是被严格限定的。</p>
<p>下面我们将介绍字节码文件的具体结构。</p>
<h3 id="三、文件格式"><a href="#三、文件格式" class="headerlink" title="三、文件格式"></a>三、文件格式</h3><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p><strong>「Class文件」</strong>采用一种类似于C语言结构体的伪结构来存储数据。</p>
<p>数据类型只有两种，「无符号数」和「表」</p>
<ul>
<li><p>无符号数</p>
<p>用<code>u1,u2,u4,u8</code>分别来表示<code>1，2，4，8</code>个字节</p>
<p>可以用来描述<strong>数字、索引引用、数量值或UTF-8编码的字符串值</strong></p>
</li>
<li><p>表</p>
<p>由多个无符号数或表构成的复合数据类型</p>
<p>为便于区分，表名一般以<code>_info</code>结尾</p>
</li>
</ul>
<p>因为存在同一类型但数量不确定的数据，所以一般会用一个前置的容量计数器来表示数量。</p>
<h3 id="四、详细介绍"><a href="#四、详细介绍" class="headerlink" title="四、详细介绍"></a>四、详细介绍</h3><h5 id="①魔数"><a href="#①魔数" class="headerlink" title="①魔数"></a>①魔数</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u4</td>
<td align="center">magic</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>Class文件的头四个字节称为<strong>Magic Number</strong>，用来<strong>确认文件是否是JVM所能接收的Class文件</strong></p>
<p>使用魔数的方式来区分文件类型，这种方式在GIF和JPEG中也可以看到。</p>
<p>至于使用头字节而不是文件的扩展名来判断文件类型，主要还是为了安全考虑，毕竟啥文件改了后缀也能变成Class文件。</p>
<p>Class文件魔数的具体取值为<code>0xCAFEBABE</code>，即咖啡宝贝</p>
<h5 id="②主版本号和次版本号"><a href="#②主版本号和次版本号" class="headerlink" title="②主版本号和次版本号"></a>②主版本号和次版本号</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">minor_version</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">major_version</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>紧跟着魔数的四个字节分别表示<strong>Minor Version</strong>和<strong>Major Version</strong></p>
<p>JDK1.1以后，每个大版本都会让主版本号加一。</p>
<p>高版本的JDK能向下兼容低版本的Class文件，但是版本比它高的Class就不行，因为《Java虚拟机规范》要求了虚拟机必须拒绝执行超过其版本号的Class文件。</p>
<h5 id="③常量池"><a href="#③常量池" class="headerlink" title="③常量池"></a>③常量池</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">constant_pool_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">cp_info</td>
<td align="center">constant_pool</td>
<td align="center">constant_pool_count - 1</td>
</tr>
</tbody></table>
<p>由<code>constant_pool_count</code>和<code>constant_pool</code>构成。</p>
<p><strong>constant_pool_count（u2类型）</strong></p>
<p>因为常量池的容量是不固定的，所以入口处有u2类型的数据，来表示「常量池的容量」。</p>
<p>注意，它是从1开始计数的，所以常量数量为$count - 1$</p>
<p>这样做的原因，据设计者说，是为了<strong>能够让以后某些指向常量池的索引值的数据表达“不引用任何一个常量池项目”的含义。</strong></p>
<p><strong>constant_pool（cp_info类型）</strong></p>
<p>常量池中主要存放两大类常量：<strong>字面量</strong>和<strong>符号引用</strong></p>
<ul>
<li><p><strong>字面量</strong></p>
<p>文本字符串，声明为final的常量值等</p>
</li>
<li><p><strong>符号引用</strong></p>
<p>类、接口的全限定名</p>
<p>字段的名称和描述符</p>
<p>方法的名称和描述符等</p>
</li>
</ul>
<p>常量池中的每个常量都是一个表，截至JDK13，共有17种不同类型的常量。</p>
<p>这17类表有一个共同特点，即<strong>第一个字节都表示tag标志位，代表当前常量属于哪个常量表</strong>，后面的字节根据不同的表而变化。</p>
<h5 id="④访问标志"><a href="#④访问标志" class="headerlink" title="④访问标志"></a>④访问标志</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>常量池结束之后的两个字节，用来表示类或接口的访问标志</p>
<p>可以取的值有：public、final、super、interface等共9个</p>
<h5 id="⑤索引集合"><a href="#⑤索引集合" class="headerlink" title="⑤索引集合"></a>⑤索引集合</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">this_class</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">super_class</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">interfaces</td>
<td align="center">interfaces_count</td>
</tr>
</tbody></table>
<p>类索引和父类索引都占两个字节，而接口索引是一组数据的集合。</p>
<p>这些索引用来确认类的全限定名、父类的全限定名以及实现的接口的名称。</p>
<p><strong>具体确认过程如下：</strong></p>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/Snipaste_2021-04-25_17-01-01.png" alt="Snipaste_2021-04-25_17-01-01"></p>
<h5 id="⑥字段表集合"><a href="#⑥字段表集合" class="headerlink" title="⑥字段表集合"></a>⑥字段表集合</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">fields_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">field_info</td>
<td align="center">fields</td>
<td align="center">fields_count</td>
</tr>
</tbody></table>
<p>包含了类或接口声明的类级变量（static）和实例变量，但不包含方法内的局部变量。</p>
<p>我们可以先思考下，一个字段拥有什么属性？</p>
<ul>
<li>修饰符，public、static、volatile等</li>
<li>名称，字段名</li>
<li>类型，是什么数据类型</li>
<li>属性，如果是集合类型，里面包含的其他属性</li>
</ul>
<p>根据上面罗列出来的信息，我们可以总结出字段表的内部结构</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">access_flags</td>
<td align="center">1</td>
<td align="center">字段修饰符</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">name_index</td>
<td align="center">1</td>
<td align="center">简单名称</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">descriptor_index</td>
<td align="center">1</td>
<td align="center">描述符</td>
</tr>
<tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>这里解释下前面提到过的三个名词，全限定名、简单名称和描述符。</p>
<ul>
<li><p><strong>全限定名</strong></p>
<p>com/edu/neu/TestApplication;</p>
<p>代表类的全限定名</p>
</li>
<li><p><strong>简单名称</strong></p>
<p>sort：sort()方法的简单名称</p>
<p>arr：arr字段的简单名称</p>
</li>
<li><p><strong>描述符</strong></p>
<p>描述符和上述两者相比更加复杂一些。它是用来描述<strong>字段的数据类型</strong>、<strong>方法的参数列表</strong>和<strong>返回值</strong>。</p>
</li>
</ul>
<p><strong>描述字段时</strong></p>
<table>
<thead>
<tr>
<th align="center">标识字符</th>
<th align="center">含义</th>
<th align="center">标识字符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">基本类型byte</td>
<td align="center">J</td>
<td align="center">基本类型long</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">基本类型char</td>
<td align="center">S</td>
<td align="center">基本类型short</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">基本类型double</td>
<td align="center">Z</td>
<td align="center">基本类型boolean</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">基本类型float</td>
<td align="center">V</td>
<td align="center">特殊类型void</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">基本类型int</td>
<td align="center">L</td>
<td align="center">对象类型，如Ljava/lang/Object;</td>
</tr>
</tbody></table>
<p><strong>基本数据类型和void都用大写字母来表示，对象类型则用L加上对象的全限定名来表示，数组类型在最前面加上若干个[</strong></p>
<p>对于<code>java.lang.String[][]</code>类型，它的描述符将是<code>[[Ljava/lang/String;</code></p>
<p>对于<code>int[]</code>，它的描述符将是<code>[I</code></p>
<p><strong>描述方法时</strong></p>
<p>按照<strong>先参数列表</strong>、<strong>后返回值</strong>的顺序进行描述，参数列表要放在<code>()</code>中。</p>
<p>对于<code>int indexOf(char[] source, int srcOffset, int srcCount, char[] target, int tarOffset, int tarCount, int fromIndex)</code>，描述符将是<code>([CII[CIII)I</code></p>
<h5 id="⑦方法表集合"><a href="#⑦方法表集合" class="headerlink" title="⑦方法表集合"></a>⑦方法表集合</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">methods_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">method_info</td>
<td align="center">methods</td>
<td align="center">methods_count</td>
</tr>
</tbody></table>
<p>方法表和上述字段表集合几乎一致，所以关于表结构这部分不再介绍。</p>
<p>但是如果只是和字段一样的话，那么它的代码怎么保存呢？</p>
<p>事实上，方法体经过编译器编译成字节码指令后，存放在方法的属性表集合中一个名为<code>Code</code>的属性里，我们在将属性表时，会介绍这些。</p>
<h5 id="⑧属性表集合"><a href="#⑧属性表集合" class="headerlink" title="⑧属性表集合"></a>⑧属性表集合</h5><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attributes_count</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">attribute_info</td>
<td align="center">attributes</td>
<td align="center">attributes_count</td>
</tr>
</tbody></table>
<p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序。</p>
<p>在最新的《Java虚拟机规范》的JavaSE12版本中，预定义属性达到29项。可想而知，它的内容非常多。</p>
<p>下面我们介绍下属性表的基本结构</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">名称</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u2</td>
<td align="center">attribute_name_index</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u4</td>
<td align="center">attribute_length</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">u1</td>
<td align="center">info</td>
<td align="center">attribute_length</td>
</tr>
</tbody></table>
<p>一个符合规范的属性表，它的属性名应该从常量池中引用<code>CONSTANT_Utf8_info</code>类型的常量来表示，而属性值的结构是完全自定义的，只需要通过一个<code>u4</code>长度属性去说明属性值所占用的位数即可。</p>
<p>至于具体的属性值结构，可参考《深入理解Java虚拟机》P233。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>(三).Executor框架介绍</title>
    <url>/2021/12/13/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/20210430161315.PNG" alt="executor_1"></p>
<h2 id="一、好处"><a href="#一、好处" class="headerlink" title="一、好处"></a>一、好处</h2><p>Executor是Java提供的线程池框架</p>
<p>首先，介绍一下使用线程池的好处：</p>
<ol>
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ol>
<p>另外，还能避免<strong>this逃逸问题</strong></p>
<blockquote>
<p>即在构造器完成构造前，将自身的<strong>this</strong>引用向外抛出，并被其他线程获取到，这样其他线程有可能<strong>访问</strong>还<strong>未初始化</strong>的变量</p>
<p>详情请转至<a href="https://www.cnblogs.com/jian0110/p/9369096.html">https://www.cnblogs.com/jian0110/p/9369096.html</a></p>
</blockquote>
<h2 id="二、组成"><a href="#二、组成" class="headerlink" title="二、组成"></a>二、组成</h2><h3 id="1-任务"><a href="#1-任务" class="headerlink" title="1.任务"></a>1.任务</h3><p>任务有内外之分</p>
<p><strong>外部的任务</strong>是指实现了Runnable接口的类，使用的时候把该类对象传进去，就会执行重写的run方法</p>
<p>传进去后，线程池会把该对象包装成Worker内部类的形式</p>
<h3 id="2-任务的执行"><a href="#2-任务的执行" class="headerlink" title="2.任务的执行"></a>2.任务的执行</h3><p>执行的方式有两种，一种是直接调用<strong>execute()<strong>，这是</strong>Executor接口</strong>提供的方法</p>
<p>另一种是调用<strong>ExecutorService</strong>提供的**submit()**，它实际上也是调用前者执行的，区别在于它具有返回值，返回了一个Future对象。</p>
<h3 id="3-结果"><a href="#3-结果" class="headerlink" title="3.结果"></a>3.结果</h3><p>调用submit执行的话，会返回结果对象，它是实现Future接口的对象。</p>
<hr>
<h2 id="三、执行流程图"><a href="#三、执行流程图" class="headerlink" title="三、执行流程图"></a>三、执行流程图</h2><p>执行流程如下：</p>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/20210430161525.png" alt="executor_2"></p>
<p><strong>1.<strong>主线程创建实现</strong>Runnable</strong>或<strong>Callable</strong>接口的对象</p>
<p><strong>2.<strong>把对象交给</strong>Executor Service</strong>的<strong>execute</strong>或<strong>submit</strong>方法，去执行</p>
<p><strong>3.<strong>如果是采用submit的方式执行，那么会返回一个</strong>Future</strong>或<strong>Future Task</strong>对象</p>
<p>**4.**主线程可以执行FutureTask.get()来等待任务完成，也可以调用FutureTask.cancel()来取消任务</p>
<hr>
<h2 id="四、ThreadPoolExecutor类介绍"><a href="#四、ThreadPoolExecutor类介绍" class="headerlink" title="四、ThreadPoolExecutor类介绍"></a>四、ThreadPoolExecutor类介绍</h2><p><strong>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</strong></p>
<h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h3><p>共有四个构造方法，内部实际上都是用的同一个，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,      // 核心线程数  一旦超过这个数，任务就会被添加到队列中等待</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,   // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,    // 存活的最长时间（指核心线程数之外的线程空闲后的存活时间）</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,		 // 时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory, // 工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123; <span class="comment">//拒绝策略</span></span><br><span class="line">                          <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">corePoolSize</td>
<td align="center">核心线程数</td>
</tr>
<tr>
<td align="center">maximumPoolSize</td>
<td align="center">线程池最大线程数，当阻塞队列满时，线程数会从核心线程数变成最大线程数</td>
</tr>
<tr>
<td align="center">keepAliveTime</td>
<td align="center">非核心线程没有任务执行时的存活时间</td>
</tr>
<tr>
<td align="center">unit</td>
<td align="center">存活时间的单位</td>
</tr>
<tr>
<td align="center">workQueue</td>
<td align="center">阻塞队列</td>
</tr>
<tr>
<td align="center">threadFactory</td>
<td align="center">线程工厂，默认是Executors工具类提供的默认工厂，也可以自己实现ThreadFactory接口</td>
</tr>
<tr>
<td align="center">handler</td>
<td align="center">拒绝策略</td>
</tr>
</tbody></table>
<h3 id="2-状态"><a href="#2-状态" class="headerlink" title="2.状态"></a>2.状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;      <span class="comment">// 32 - 3 = 29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>; <span class="comment">// 2^29 - 1，即左边29个1</span></span><br><span class="line"><span class="comment">// 可以看出，状态是有序的，从小到大</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;   <span class="comment">// -1补码表示为 111 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;	  <span class="comment">//  0补码表示为 000 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;   <span class="comment">//  1补码表示为 001 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;   <span class="comment">//  2补码表示为 010 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;   <span class="comment">//  3补码表示为 011 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int共有32位</span></span><br><span class="line"><span class="comment">// 前3位表示状态，后29位表示线程数量</span></span><br></pre></td></tr></table></figure>

<p><strong>状态说明如下</strong></p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">描述</th>
<th align="center">数值</th>
<th>结构</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Running</strong></td>
<td align="center">接受新任务并处理工作队列中的任务</td>
<td align="center">$-2^{29}$</td>
<td>$111+29个0$</td>
</tr>
<tr>
<td align="center"><strong>Shutdown</strong></td>
<td align="center">不接受新任务，但仍处理队列中的任务</td>
<td align="center">$0$</td>
<td>$000+29个0$</td>
</tr>
<tr>
<td align="center"><strong>Stop</strong></td>
<td align="center">不接受新任务，也不处理队列中的任务，中断正在执行的任务</td>
<td align="center">$2^{29}$</td>
<td>$001+29个0$</td>
</tr>
<tr>
<td align="center"><strong>Tidying</strong></td>
<td align="center">任务已经终止，正在工作的线程数为0。线程来到这个状态时，会执行terminated()</td>
<td align="center">$2^{30}$</td>
<td>$010+29个0$</td>
</tr>
<tr>
<td align="center"><strong>Terminated</strong></td>
<td align="center">完成terminated()后进入此状态</td>
<td align="center">$3\times2^{29}$</td>
<td>${011}+29个0$</td>
</tr>
</tbody></table>
<p>执行的<strong>流程</strong>如下所示</p>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/20210430161844.png" alt="executor_3"></p>
<hr>
<h2 id="五、两种创建线程池的方式"><a href="#五、两种创建线程池的方式" class="headerlink" title="五、两种创建线程池的方式"></a>五、两种创建线程池的方式</h2><p>Java提供了Executors工具类来快捷的创建线程池，主要有四种</p>
<p>但这是<strong>不推荐</strong>的做法。</p>
<table>
<thead>
<tr>
<th align="left">线程池</th>
<th align="left">描述</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">①newFixedThreadPool</td>
<td align="left">固定大小，当线程不够时，任务就会放入到队列中等待</td>
<td align="center">队列容量大，线程一直存在，直到显式的调用shutdown</td>
</tr>
<tr>
<td align="left">②newSingleThreadExecutor</td>
<td align="left">只有一个线程存在，当它终止时，就会产生一个新的线程去代替它</td>
<td align="center">队列容量大</td>
</tr>
<tr>
<td align="left">③newScheduledThreadPool</td>
<td align="left">可以指定一段延迟时间，来让线程执行</td>
<td align="center">允许创建的线程数大</td>
</tr>
<tr>
<td align="left">④newCachedThreadPool</td>
<td align="left">根据需要创建线程，没有使用的线程在60秒后会终止并移出线程池</td>
<td align="center">允许创建的线程数大</td>
</tr>
</tbody></table>
<p>从上面可以看出：</p>
<ol>
<li>①②的工作队列容量是Integer.MAX_VALUE，当任务较多时可能会出现OOM</li>
<li>③④允许创建的线程数量为Integer.MAX_VALUE，创建线程较多时，会出现OOM</li>
</ol>
<p>其实<strong>Executors</strong>提供的<strong>四种创建</strong>线程池的方法，实际上是调用的<strong>ThreadPoolExecutor</strong>的构造方法</p>
<p>所以推荐使用<strong>ThreadPoolExecutor</strong>来<strong>手动配置</strong>线程池参数。</p>
<hr>
<h2 id="六、线程池大小"><a href="#六、线程池大小" class="headerlink" title="六、线程池大小"></a>六、线程池大小</h2><p>上面我们知道了应该<strong>手动创建</strong>线程池，那么线程池的大小该如何选择呢？</p>
<p>在这之前先介绍一下<strong>上下文切换</strong>的概念</p>
<h3 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1.上下文切换"></a>1.上下文切换</h3><p><strong>背景</strong></p>
<blockquote>
<p>一个<strong>CPU核心</strong>在任意一个时刻<strong>只能</strong>由一个线程使用</p>
<p>而线程的数量是比CPU核心数要多的</p>
<p>所以我们一般采取的策略是<strong>时间片轮转</strong>来为每个线程执行。</p>
</blockquote>
<p><strong>定义</strong></p>
<blockquote>
<p>当一个线程的时间片用完后，就会把CPU让给其他线程执行</p>
<p>在切换的过程中，我们需要保存当前任务的状态，以便下次切换回来时，可以很快地加载状态，这就叫<strong>上下文切换</strong>。</p>
</blockquote>
<p>那么<strong>上下文切换</strong>和<strong>线程池的大小</strong>有什么关系呢？且听我慢慢道来。</p>
<p>如果线程池大小设置的<strong>过大</strong>，就会有很多线程在<strong>竞争</strong>CPU资源，<strong>上下文切换</strong>就会变得更加<strong>频繁</strong>，因此开销也会增大</p>
<p>如果<strong>过小</strong>，当遇到大量任务出现的情景时，就会造成任务堆积，甚至OOM</p>
<h3 id="2-简单的公式"><a href="#2-简单的公式" class="headerlink" title="2.简单的公式"></a>2.简单的公式</h3><p>假设 <code>n</code> 表示<strong>CPU</strong>核心数</p>
<ul>
<li>CPU密集型任务 $n+1$ </li>
</ul>
<p>这些任务主要消耗的是CPU的计算资源（计算、排序等），把线程池大小设置成核心数加1</p>
<p>这样可以防止某个线程暂停时，CPU空闲下来的情况，或者是防止线程偶发的缺页中断。</p>
<ul>
<li>I/O密集型任务 $2n$</li>
</ul>
<p>这类任务大部分时间都在进行I/O操作，在这段时间内，CPU可以交给其他线程去执行，所以可以多配一些线程</p>
<p>因为如果线程数较小的话，可能大部分线程都在执行I/O，那么CPU利用率就会降低。</p>
<hr>
<h2 id="七、线程复用（源码分析）"><a href="#七、线程复用（源码分析）" class="headerlink" title="七、线程复用（源码分析）"></a>七、线程复用（源码分析）</h2><h3 id="什么是线程复用？"><a href="#什么是线程复用？" class="headerlink" title="什么是线程复用？"></a><strong>什么是线程复用？</strong></h3><blockquote>
<p>以前使用Thread类去创建线程时，当线程执行完任务后，就会被销毁，就算把它挂起了，也处理不了其他任务。</p>
<p>而Executor框架提供的线程池，可以让一个线程在执行完任务后，再去执行其他任务，这就叫做<strong>线程复用</strong>。</p>
</blockquote>
<p>ThreadPoolExecutor的一大特点就是<strong>线程复用</strong>。</p>
<p>首先放张图介绍下线程池执行任务的<strong>流程</strong></p>
<img data-src="https://gitee.com/aurora1004/pictures/raw/master/20210430162129.png" alt="executor_4" style="zoom:67%;" />

<ol>
<li>工作线程数小于核心线程数</li>
</ol>
<p>创建一个线程<strong>作为核心线程</strong>，去执行该任务。</p>
<ol start="2">
<li>工作线程数大于等于核心线程数</li>
</ol>
<p>把任务添加到阻塞队列中</p>
<ol start="3">
<li>阻塞队列满了</li>
</ol>
<p>创建线程作为<strong>非核心线程</strong>，去执行任务</p>
<p>既然想了解它的线程复用原理，就免不了看源码的过程，下面放出了一些关键方法。</p>
<h3 id="1-execute"><a href="#1-execute" class="headerlink" title="1.execute()"></a>1.execute()</h3><p>之前提到，不管是用execute()还是submit()来执行任务，<strong>实质</strong>都是调用execute()来执行的</p>
<p>下面就来看看execute()的核心源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;   <span class="comment">// 如果工作线程数小于核心线程数，就调用addWorker()</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))        <span class="comment">// 该方法内部新建了线程去执行任务</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;												 <span class="comment">// 工作线程数大于等于核心线程数，就会来到这</span></span><br><span class="line"><span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  <span class="comment">// 状态是Running，就把任务放入到队列中，如果失败就执行else</span></span><br><span class="line">    <span class="keyword">int</span> recheck = ctl.get();                     <span class="comment">// 二次检查</span></span><br><span class="line">    <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 检查不通过(状态不是Running)就删除该任务并采取拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)		</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))   <span class="comment">// 当状态不是运行状态，或者队列满了，就会走到这里</span></span><br><span class="line">    reject(command);                   <span class="comment">// 创建非核心线程去执行任务，如果失败就采用拒绝策略</span></span><br></pre></td></tr></table></figure>

<p>我们可以发现，execute()主要调用了两个方法，分别是<code>addWorker()</code>和<code>reject()</code></p>
<h3 id="2-reject"><a href="#2-reject" class="headerlink" title="2.reject()"></a>2.reject()</h3><p>主要是调用处理器去拒绝该任务，具体策略有四种</p>
<p>在创建线程池时，会添加默认的处理器defaultHandler，它采取的是<strong>AbortPolicy</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"><span class="comment">// 在构造方法里，会默认让 handler = defaultHandler</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体策略：</strong></p>
<table>
<thead>
<tr>
<th align="center">拒绝策略</th>
<th align="center">描述</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>AbortPolicy</strong></td>
<td align="center">拒绝任务并抛出异常RejectedExecutionException</td>
<td align="center">捕获异常进行处理</td>
</tr>
<tr>
<td align="center"><strong>CallerRunsPolicy</strong></td>
<td align="center">让调用的线程去执行任务</td>
<td align="center">并发量低时，可以使用这种</td>
</tr>
<tr>
<td align="center"><strong>DiscardPolicy</strong></td>
<td align="center">拒绝并丢弃任务</td>
<td align="center">当前任务不重要</td>
</tr>
<tr>
<td align="center"><strong>DiscardOldestPolicy</strong></td>
<td align="center">丢弃最久未处理的工作，然后再次尝试execute()</td>
<td align="center">之前的任务不是很重要，就可以用这种策略</td>
</tr>
</tbody></table>
<p><strong>具体应用1：</strong></p>
<p><strong>场景：</strong>用户支付后，把消息发送给用户，我们希望这个消息无论如何都能够发出去。</p>
<p><strong>解决：</strong>使用线程池来执行任务。如果并发量很大，导致线程池的阻塞队列满了，可以采用<code>AbortPolicy</code>策略，抛出异常，然后在外部捕获异常。捕获异常后把任务存到<code>redis</code>中，另外使用一个定时器，每隔一秒去redis中异步获取任务，再次添加到线程池。</p>
<p><strong>优化版：</strong>自定义拒绝策略，在里面把任务存到<code>redis</code>中，以此封装逻辑。</p>
<p><strong>具体应用2：</strong></p>
<p><strong>场景：</strong>推送，上游生产，下游消费；我们希望下游消费得比较慢时，就不要再推送。</p>
<p><strong>解决：</strong>开一个异步线程去获取任务，然后把任务放入到线程池中去执行推送；当阻塞队列满时，采取<code>CallerRunsPolicy</code>策略，让主线程去执行推送，这样主线程既不会空闲下来，也不会再去获取任务。</p>
<h3 id="3-addWorker"><a href="#3-addWorker" class="headerlink" title="3.addWorker()"></a>3.addWorker()</h3><p>这里主要是把任务<strong>包装</strong>成Worker对象，然后<strong>新建</strong>线程（由工厂新建）去执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 省略前面的一些判断和处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">// 创建Worker对象时，内部通过工厂获得了一个线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread; <span class="comment">// 使用线程</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;<span class="comment">// 加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());  <span class="comment">// 进行检查，如果状态是Running</span></span><br><span class="line"> 												 <span class="comment">// 如果状态是Shutdown 且firstTask是空</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||			 <span class="comment">// 就把任务添加到HashSet中</span></span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();      <span class="comment">// 判断大小</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();         <span class="comment">// 启动线程</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);    <span class="comment">// 调用失败的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看了上面的源码，我们可以发现<strong>线程池</strong>是通过<strong>创建Worker</strong>来执行任务的，同时<strong>线程</strong>也在Worker对象中。</p>
<p>那么我们再看看<strong>Worker</strong>类</p>
<h3 id="4-Worker"><a href="#4-Worker" class="headerlink" title="4.Worker"></a>4.Worker</h3><p>Worker类实现了Runnable接口，重写了run()</p>
<p>里面调用了**runWorker()**，那么这个方法才是真正执行任务的！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-runWorker"><a href="#5-runWorker" class="headerlink" title="5.runWorker()"></a>5.runWorker()</h3><p>我们可以清楚地看到，当任务不为空时，就调用run()执行。</p>
<p>这里也是线程复用的实现：</p>
<p>当一个线程 <strong>执行完 firstTask <strong>后，它会通过getTask()主动去阻塞队列中</strong>获取</strong>任务来执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;														<span class="comment">// 重点，获得任务的方式有两种</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;  	<span class="comment">// 1.从Worker对象中得到任务</span></span><br><span class="line">            w.lock();											<span class="comment">// 2.如果Worker对象中的任务完成了</span></span><br><span class="line">         														<span class="comment">// 就通过getTask()方法去获取</span></span><br><span class="line">          	<span class="comment">/* 省略一些中断处理和判断... */</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();       <span class="comment">// 前面获取到了任务，就在这里运行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-getTask"><a href="#6-getTask" class="headerlink" title="6.getTask()"></a>6.getTask()</h3><p>通过死循环来获取任务，任务是从阻塞队列中获取的</p>
<ol>
<li>工作线程数 &gt; 核心线程数 使用poll()</li>
<li>工作线程数 &lt;= 核心线程数 使用take()</li>
</ol>
<p>poll()和take()的区别在于，poll可以传递放弃等待的时间参数，超过这个时间就放弃获取</p>
<p>take()如果获取不到就会阻塞，一直等待（因为这时候工作线程数量少，你获取不到任务就会空闲，所以要一直阻塞，直到任务来了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">// 通过死循环获取任务</span></span><br><span class="line">        <span class="comment">// 省略检查线程池状态和队列为空的判断</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        <span class="comment">// 工作线程数 &gt; 核心线程数，就是true</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">       <span class="comment">// 省略超时和容量上限判断</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?                                      <span class="comment">// 1.工作线程数 &gt; 核心线程数 用poll()</span></span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="comment">// 2.反之，就用take()</span></span><br><span class="line">                workQueue.take();									  <span class="comment">// 区别在于take()会阻塞地获取任务 </span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>Executor的线程复用，是让线程在完成任务后，不断地向阻塞队列获取任务</p>
<p>对于核心线程来说，用take方法，获取不到就会阻塞，从而保证它永远不会因为存活时间而过期销毁</p>
<p>而非核心线程，用poll方法，在超时时间内获取不到任务，就会放弃，从而会因为存活时间到期而销毁。</p>
]]></content>
      <categories>
        <category>线程和线程池</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h5 id="上线集群"><a href="#上线集群" class="headerlink" title="上线集群"></a>上线集群</h5><p><code>CLUSTER MEET [ip] [port]</code>：将目标节点加入当前集群中</p>
<p><code>CLUSTER ADDSLOTS [slot ...]</code>：为当前节点分配槽</p>
<h5 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h5><p><code>CLUSTER NODES</code>：查看当前集群的节点</p>
<p><code>CLUSTER KEYSLOT [key]</code>：查看key属于哪个槽</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis主从复制</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><blockquote>
<p><strong>主从复制</strong>是指将一个redis服务器中的数据复制到另一个服务器上，前者称为主服务器，后者则是从服务器。</p>
<p>主从复制一般用于<strong>读写分离</strong>的场景，即主服务器执行读写请求，其他从服务器执行读请求。这样可以缓解主服务器的读写压力。</p>
</blockquote>
<h3 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h3><p><strong>全量复制：</strong>复制主服务器的所有数据；一般用于建立主从关系时。</p>
<p><strong>增量复制：</strong>复制后来变化的部分数据；一般用于断开连接后重连时</p>
<p>注意，增量复制是redis2.8以后才有的功能，在此之前只能进行全量复制。</p>
<h3 id="二、主从复制的过程"><a href="#二、主从复制的过程" class="headerlink" title="二、主从复制的过程"></a>二、主从复制的过程</h3><p>全量复制的过程示意：</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20211028204216.png" alt="image-20211028204216102"></p>
<h5 id="1-发起主从复制的请求"><a href="#1-发起主从复制的请求" class="headerlink" title="1.发起主从复制的请求"></a>1.发起主从复制的请求</h5><p>客户端输入<code>salveof [ip] [port]</code>命令，表示希望当前redis服务器成为目标服务器的从节点。</p>
<h5 id="2-向目标服务器发送同步请求"><a href="#2-向目标服务器发送同步请求" class="headerlink" title="2.向目标服务器发送同步请求"></a>2.向目标服务器发送同步请求</h5><p>服务器收到客户端的<code>salveof</code>命令后，向目标服务器发送<code>psync</code>命令。</p>
<p>格式为<code>psync [runid] [offset]</code></p>
<ul>
<li>因为是首次连接，则发送<code>psync ? -1</code></li>
<li>如果本地存有运行id和偏移量，则发送这些数据，用来表示重连。</li>
</ul>
<h5 id="3-响应请求"><a href="#3-响应请求" class="headerlink" title="3.响应请求"></a>3.响应请求</h5><p>主节点判断为全量复制，因此返回<code>fullresync [runid] [offset]</code>。</p>
<p><strong>runid</strong></p>
<p>每个服务器启动时会生成一个随机数runid。主从复制时，从节点会记录下主节点传过来的runid，作用有二：</p>
<ol>
<li>标志主节点的身份</li>
<li>可以根据runid是否为空来判断是初次连接还是断线重连的主从复制。</li>
</ol>
<p><strong>offset</strong></p>
<p>用来同步主从服务器之间接收的数据。</p>
<p>主节点和从节点都持有<code>offset</code>，分别表示发送数据量和接收数据量。</p>
<ul>
<li>正常情况下，两者的偏移应该是相同的。</li>
<li>断线重连时，从节点丢失一部分数据，因此它发送的psync请求携带的偏移量参数小于主节点，主节点可以判断并给出缺失的部分数据。</li>
</ul>
<h5 id="4-发送rdb快照"><a href="#4-发送rdb快照" class="headerlink" title="4.发送rdb快照"></a>4.发送rdb快照</h5><h5 id="5-发送写命令"><a href="#5-发送写命令" class="headerlink" title="5.发送写命令"></a>5.发送写命令</h5><p>在主从复制建立之后，主节点会把所有的写命令发送给从节点，<strong>来保证主从数据的一致</strong>。</p>
<p>此外，为了应对<strong>增量复制</strong>的场景，主节点还将写命令放入了一个固定的缓冲区中，当从节点因为断线缺失一部分写命令后，主节点会从缓冲区中拿出来给它。</p>
<h3 id="三、主从复制的一些问题"><a href="#三、主从复制的一些问题" class="headerlink" title="三、主从复制的一些问题"></a>三、主从复制的一些问题</h3><h5 id="3-1主从节点数据的延迟如何优化？"><a href="#3-1主从节点数据的延迟如何优化？" class="headerlink" title="3.1主从节点数据的延迟如何优化？"></a>3.1主从节点数据的延迟如何优化？</h5><h5 id="3-2从节点中数据的过期如何处理？"><a href="#3-2从节点中数据的过期如何处理？" class="headerlink" title="3.2从节点中数据的过期如何处理？"></a>3.2从节点中数据的过期如何处理？</h5><h5 id="3-3为什么主从复制不用AOF文件"><a href="#3-3为什么主从复制不用AOF文件" class="headerlink" title="3.3为什么主从复制不用AOF文件"></a>3.3为什么主从复制不用AOF文件</h5>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis数据结构</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="一、简单动态字符串"><a href="#一、简单动态字符串" class="headerlink" title="一、简单动态字符串"></a>一、简单动态字符串</h2><h3 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h3><p>redis中字符串对应的结构体定义为<code>sdshdr</code>，包含三个属性：</p>
<p>已用长度、可用长度和字节数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">	<span class="keyword">char</span>[] buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串示例：sds {len: 2, free: 2, buf: [‘h’, ‘a’, ‘\0’, ‘’, ‘’]}</strong></p>
<h3 id="2-修改字符串"><a href="#2-修改字符串" class="headerlink" title="2.修改字符串"></a>2.修改字符串</h3><p><strong>扩容策略</strong></p>
<p>字符串增长时，如果可用空间足够，就直接分配；如果可用空间不足，则进行扩容。</p>
<p>计算分配后的长度得到新的<code>len</code>，判断：</p>
<ul>
<li>如果<code>len</code>小于等于1MB（$2^{20}$），则分配len可用空间</li>
<li>如果<code>len</code>大于1MB，则分配1MB可用空间</li>
</ul>
<p><strong>删除策略</strong></p>
<p>删除字符串中的某些字符时，不会立刻释放那些空间，而是把它们作为free的空间</p>
<p><strong>特点总结</strong></p>
<ol>
<li>减少内存重分配次数（由n次到至多为n）</li>
<li>惰性回收</li>
</ol>
<h3 id="3-SDS与C字符串的区别"><a href="#3-SDS与C字符串的区别" class="headerlink" title="3.SDS与C字符串的区别"></a>3.SDS与C字符串的区别</h3><table>
<thead>
<tr>
<th align="center">区别（SDS的特点）</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(1)时间复杂度获取字符串长度</td>
<td align="center">通过<code>len</code>属性来获取已用长度</td>
</tr>
<tr>
<td align="center">直接避免缓冲区溢出</td>
<td align="center">追加字符串时，自动判断并进行扩容，防止忘记分配空间时<code>buf</code>溢出影响到其他内存区域</td>
</tr>
<tr>
<td align="center">减少内存重分配次数</td>
<td align="center">修改n次字符串，最多会产生n次内存重分配</td>
</tr>
<tr>
<td align="center">二进制安全</td>
<td align="center">支持任意的数据，如图片、序列化对象等</td>
</tr>
</tbody></table>
<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><p>链表的实现为常见的双向链表结构，表现在：</p>
<ol>
<li>当前节点拥有前后两个节点的指针</li>
<li>定义链表结构体，方便操作</li>
</ol>
<h2 id="三、压缩列表（ziplist）"><a href="#三、压缩列表（ziplist）" class="headerlink" title="三、压缩列表（ziplist）"></a>三、压缩列表（ziplist）</h2><p>压缩列表是<strong>列表键</strong>和<strong>哈希键</strong>的底层实现之一，当列表元素数量较少且每个元素比较小时，会采用压缩列表进行实现。</p>
<h3 id="1-结构-1"><a href="#1-结构-1" class="headerlink" title="1.结构"></a>1.结构</h3><p><strong>整体结构</strong></p>
<table>
<thead>
<tr>
<th align="center">zlbytes</th>
<th align="center">zltail</th>
<th align="center">zllen</th>
<th align="center">entry1</th>
<th align="center">entryN</th>
<th align="center">zlend</th>
</tr>
</thead>
</table>
<p>属性说明：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="center">描述</th>
<th align="center">长度（字节）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">zlbytes</td>
<td align="center">记录压缩列表占用内存的字节数；用于确定zlend地址</td>
<td align="center">4</td>
</tr>
<tr>
<td align="left">zltail</td>
<td align="center">记录从列表初始地址到表尾节点的偏移量；用于确定表尾地址</td>
<td align="center">4</td>
</tr>
<tr>
<td align="left">zllen</td>
<td align="center">记录节点个数；如果是$2^{16}-1$，则需要遍历列表才行</td>
<td align="center">2</td>
</tr>
<tr>
<td align="left">entryX</td>
<td align="center">每个节点</td>
<td align="center">不定</td>
</tr>
<tr>
<td align="left">zlend</td>
<td align="center">标记压缩列表的末端</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><strong>节点结构</strong></p>
<table>
<thead>
<tr>
<th align="center">previous_entry_length</th>
<th align="center">encoding</th>
<th align="center">content</th>
</tr>
</thead>
</table>
<p>节点属性说明：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">previous_entry_length</td>
<td align="center">记录前一个节点的长度，占用1字节或5字节</td>
</tr>
<tr>
<td align="left">encoding</td>
<td align="center">记录数据的类型和长度</td>
</tr>
<tr>
<td align="left">content</td>
<td align="center">记录节点的值</td>
</tr>
</tbody></table>
<p>其中，<code>previous_entry_length</code>属性最为重要，借助它我们可以从表尾节点向前遍历。</p>
<p><strong>previous_entry_length的长度变化也是引起连锁更新的主要原因。</strong></p>
<ol>
<li>长度小于254时<ul>
<li><code>previous_entry_length</code>占一字节</li>
</ul>
</li>
<li>大于等于254时<ul>
<li><code>previous_entry_length</code>占5字节，第一个字节作为标志取<code>0xFE</code>，剩余4个字节表示真正长度</li>
</ul>
</li>
</ol>
<h3 id="2-连锁更新"><a href="#2-连锁更新" class="headerlink" title="2.连锁更新"></a>2.连锁更新</h3><p>假设列表为：node(N) - node(N-1) - node(…) - node(1)</p>
<p>在极端情况下，在节点N前插入一个大于等于254字节的新节点，会引起从节点N到节点1的一轮更新。</p>
<p>而在一轮更新时，修改每个节点的<code>previous_entry_length</code>属性时，最坏情况时也会引发后面所有节点的修改。</p>
<p>因此最坏的时间复杂度为$O(n * n) = O(n^2)$。</p>
<h3 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h3><p>压缩列表适合列表元素较少的场景，因为较少时读连续的内存会比较快。</p>
<p>元素较多时会使用双向链表进行存储。（涉及对象与编码）</p>
<h2 id="四、字典"><a href="#四、字典" class="headerlink" title="四、字典"></a>四、字典</h2><p>字典即哈希表，实现和Java的HashMap类似，内部结构是一个Entry数组</p>
<p>哈希表涉及：</p>
<ol>
<li>计算哈希和下标：哈希值和掩码进行与操作</li>
<li>解决哈希冲突：头插法</li>
<li>扩容</li>
<li>rehash</li>
</ol>
<h2 id="五、整数集合"><a href="#五、整数集合" class="headerlink" title="五、整数集合"></a>五、整数集合</h2><h3 id="1-结构-2"><a href="#1-结构-2" class="headerlink" title="1.结构"></a>1.结构</h3><p>集合内部使用数组来存放元素，和Java的HashSet不太一样。</p>
<p>因此，我不得不抛出一些疑惑：contents数组有什么特点？它是如何实现去重的？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 编码方式，和数组升级有关</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;   <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[]; <span class="comment">// 数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><p><strong>1.数组有序</strong></p>
<p><strong>2.数组升级</strong></p>
<ul>
<li><p>何时升级：数组可以存放不同位数的整数，当插入一个更长位的整数后，数组格子就会扩大，但元素位数仍然不变</p>
</li>
<li><p>示例：原数组存有3个16位的整数1，2，3，共占48位。插入32位的65535后，数组扩容为128位，但是原来的3个元素仍占48位</p>
</li>
<li><p>优点</p>
<ul>
<li>灵活，数组可以存放不同位数的整型</li>
<li>节约内存</li>
</ul>
</li>
</ul>
<p><strong>3.适用于较少元素的场景</strong></p>
<h3 id="3-如何保证去重"><a href="#3-如何保证去重" class="headerlink" title="3.如何保证去重"></a>3.如何保证去重</h3><p>插入元素的时间复杂度为$O(n)$，那么在寻找指定位置时判断是否重复即可。</p>
<h2 id="六、跳表（skiplist）"><a href="#六、跳表（skiplist）" class="headerlink" title="六、跳表（skiplist）"></a>六、跳表（skiplist）</h2><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><p>跳表是一种有序的数据结构。</p>
<p><strong>思想</strong></p>
<p>普通链表查找的时间复杂度为$O(n)$，跳表通过存储<strong>额外的节点信息</strong>来达到减少查询元素的目的。</p>
<p>那么额外的节点信息究竟是什么？答案就是<strong>层和回退指针</strong>。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20211023114232.png" alt="image-20211023114232297"></p>
<p><strong>层</strong></p>
<p><code>节点维度</code>：每个节点包含多个层和一个回退指针。</p>
<p><code>跳表维度</code>：观察整个跳表，可以发现它是一个多层结构。第一层就是一条横向的，包含所有元素的链表。</p>
<p>然后往上，每一层都是前一层的子集，这样就能做到查询时<strong>跳过一部分元素</strong></p>
<p><strong>回退指针</strong></p>
<p>通过回退指针可以实现从表尾向表头进行遍历</p>
<p>注意：前进时，可以跳多个节点，但回退时是一个一个回退的</p>
<p><strong>总结</strong></p>
<p>跳表的节点定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 多层</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">    	<span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;             <span class="comment">// 两个节点之间的跨度</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 键值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>



<h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2.分析"></a>2.分析</h3><p><strong>查询</strong></p>
<p>从某个节点的最上层链表开始查询，比较前进节点与目标值：</p>
<ol>
<li>如果下一跳的值大于目标，则判断下一层（仍在当前节点）</li>
<li>如果下一跳的值小于等于目标值，则前进到下一跳（跳过了若干个节点）</li>
</ol>
<p><strong>排位</strong></p>
<p>查询该节点，然后累加经过的每一层的跨度（即跳过了多少个节点），就可以知道节点的排名。</p>
<h3 id="3-应用-1"><a href="#3-应用-1" class="headerlink" title="3.应用"></a>3.应用</h3>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis对象与编码</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h2><p>Redis存储键值对时，把键和值都当作<code>redisObject</code>来实现</p>
<p>redisObject包含三个属性：</p>
<ul>
<li>对象类型</li>
<li>编码</li>
<li>指向底层数据结构的指针</li>
</ul>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>对象类型总共有五种：<strong>String、List、Hash、Set和ZSet</strong>。</p>
<p>键值对中的键通常总是字符串对象，而值可以是不同的对象类型。</p>
<p><strong>这五种对象就是Redis对外的5种数据类型。</strong></p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>编码表示一个<strong>redisObject</strong>对象底层实现的数据类型。</p>
<p>例如，一个字符串对象底层可以由<strong>int、raw或embstr</strong>实现（根据具体存储的值和大小来变化）</p>
<h2 id="二、各种对象介绍"><a href="#二、各种对象介绍" class="headerlink" title="二、各种对象介绍"></a>二、各种对象介绍</h2><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><h5 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1.底层数据结构"></a>1.底层数据结构</h5><p><strong>底层实现：int、raw和embstr</strong></p>
<p><strong>使用情况：</strong></p>
<ul>
<li><strong>int</strong>：值为整数时，会使用int编码</li>
<li><strong>embstr</strong>：字符串小于等于32字节时，使用短SDS。（只读）</li>
<li><strong>raw</strong>：大于32字节，使用SDS。（简单动态字符串）</li>
</ul>
<h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h5><p>使用<code>embstr</code>可以减少内存分配次数。</p>
<p>解释：用raw需要分配两次内存，一次为redisObject，另一次为sds；而embstr只进行一次分配</p>
<h5 id="3-状态变化"><a href="#3-状态变化" class="headerlink" title="3.状态变化"></a>3.状态变化</h5><p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20211022162851.png" alt="image-20211022162850653"></p>
<h5 id="4-语法"><a href="#4-语法" class="headerlink" title="4.语法"></a>4.语法</h5><p>插入字符串键：<code>SET [key] [value]</code></p>
<p>获取字符串键：<code>GET [key]</code></p>
<hr>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><h5 id="1-底层数据结构-1"><a href="#1-底层数据结构-1" class="headerlink" title="1.底层数据结构"></a>1.底层数据结构</h5><p><strong>底层实现：ziplist和linkedlist</strong></p>
<p>使用情况：满足以下两个条件时，使用压缩列表；反之，则用双向链表。</p>
<ol>
<li>列表中的每个字符串对象都小于64字节</li>
<li>列表总元素小于512个</li>
</ol>
<h5 id="2-变化"><a href="#2-变化" class="headerlink" title="2.变化"></a>2.变化</h5><blockquote>
<p>linkedlist：next和prev指针浪费空间，且容易造成内存碎片化</p>
<p>ziplist：适用于数据量较小的场景</p>
<p>redis3.2之后，使用quicklist代替前两者，整体结构是链表，内部使用压缩列表分块</p>
</blockquote>
<h5 id="3-语法"><a href="#3-语法" class="headerlink" title="3.语法"></a>3.语法</h5><p>插入多个元素：<code>LRANGE [key] [value1] [value2]...</code></p>
<p>获取整个列表：<code>LRANGE [key] 0 -1</code></p>
<hr>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><h5 id="1-底层数据结构-2"><a href="#1-底层数据结构-2" class="headerlink" title="1.底层数据结构"></a>1.底层数据结构</h5><p><strong>底层实现：ziplist和hashtable</strong></p>
<p>哈希对象底层结构的变化情况基本和列表对象一致，即同样是满足两个条件时，使用压缩列表：</p>
<ol>
<li>每个键值对中的键和值都小于64字节</li>
<li>总元素小于512个</li>
</ol>
<p>当用来实现<code>ziplist</code>哈希对象时，键值对是按<code>key1, value1, key2, value2</code>的顺序存储在<code>ziplist</code>中。</p>
<h5 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h5><p>插入元素：<code>HSET [key] [k] [v]</code></p>
<p>获取某个元素：<code>HGET [key] [k]</code></p>
<p>判断是否存在某个键：<code>HEXISTS [key] [k]</code></p>
<hr>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><h5 id="1-底层数据结构-3"><a href="#1-底层数据结构-3" class="headerlink" title="1.底层数据结构"></a>1.底层数据结构</h5><p><strong>底层实现：intset和hashtable</strong></p>
<p>使用情况：集合元素全是整数且个数小于512时，使用<code>intset</code>来存储。</p>
<h5 id="2-语法-1"><a href="#2-语法-1" class="headerlink" title="2.语法"></a>2.语法</h5><p>插入多个元素：<code>SADD [key] [v1] [v2]...</code></p>
<hr>
<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p><strong>底层实现：ziplist和skiplist</strong></p>
<p><strong>使用情况：</strong>满足两个条件时，使用ziplist；否则就用跳表实现</p>
<ul>
<li>元素个数小于128</li>
<li>每个元素小于64字节</li>
</ul>
<p>使用跳表实现时，额外使用了一个map存储键值的映射关系，从而实现O(1)时间复杂度获取某个元素。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis命令记录</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>查看某个键的底层实现</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">object</span> encoding <span class="selector-attr">[key]</span></span><br></pre></td></tr></table></figure>

<p>查看某个键的引用计数</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">object</span> refcount <span class="selector-attr">[key]</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis过期与淘汰策略</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E8%BF%87%E6%9C%9F%E4%B8%8E%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="过期"><a href="#过期" class="headerlink" title="过期"></a>过期</h2><p>redis的数据库通过<code>字典</code>保存所有的键值对，键是一个字符串对象，值可以是之前介绍的多种对象之一。</p>
<p>但是随着键值对的不断增加，它占用的内存空间会越来越大，因此redis提供了设置过期的方法来减少内存的使用。</p>
<h3 id="一、过期相关的命令"><a href="#一、过期相关的命令" class="headerlink" title="一、过期相关的命令"></a>一、过期相关的命令</h3><p><strong>设置过期时间</strong></p>
<ul>
<li><p>EXPIRE：秒级</p>
</li>
<li><p>PEXPIRE：毫秒级</p>
</li>
<li><p>EXPIREAT</p>
</li>
<li><p>PEXPIREAT</p>
</li>
<li><p>示例：<code>EXPIRE [key] [time]</code></p>
</li>
</ul>
<p>另外，对于字符串对象可以在设置时直接附带过期时间。</p>
<p>示例：<code>SETEX [key] [value] [time]</code></p>
<p><strong>查看剩余过期时间</strong></p>
<ul>
<li>TTL：秒级</li>
<li>PTTL：毫秒级</li>
<li>示例：<code>TTL [key]</code></li>
</ul>
<h3 id="二、如何实现过期"><a href="#二、如何实现过期" class="headerlink" title="二、如何实现过期"></a>二、如何实现过期</h3><p>首先，我们需要知道：</p>
<ol>
<li>redis使用一个字典来存储所有键值对，该字典叫做<code>键空间</code></li>
<li>键值对中的键和值都是一个<code>redisObject</code>对象</li>
</ol>
<p>知道上面两个概念后，redis实现过期的方式就很容易理解了：即<strong>使用一个<code>过期字典</code>记录键的过期时间</strong></p>
<p>其中，过期字典的键值如下：</p>
<ul>
<li><p>过期字典的键与键空间的键相同，都是指向键的指针。</p>
</li>
<li><p>过期字典的值就是过期时间的毫秒时间戳，通过与当前时间戳进行比较来判断是否过期。</p>
</li>
</ul>
<h3 id="三、过期策略介绍"><a href="#三、过期策略介绍" class="headerlink" title="三、过期策略介绍"></a>三、过期策略介绍</h3><p>常见的过期策略有3种，分别是定时删除、惰性删除和定期删除。</p>
<p><strong>定时删除</strong></p>
<ul>
<li>描述：为每个键设置一个定时器，时间到就删除</li>
<li>特点：及时删除对内存友好；但计时器过多时占用CPU资源</li>
</ul>
<p><strong>惰性删除</strong></p>
<ul>
<li>描述：取出键的时候才进行过期检查</li>
<li>特点：占用CPU资源较少，但是过期键容易堆积，浪费内存</li>
</ul>
<p>基于上述两种删除策略，我们又有一种折中的方案，即：</p>
<p><strong>定期删除</strong></p>
<ul>
<li>描述：分多次遍历各个数据库，随机抽一部分键值对进行过期检查</li>
</ul>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>redis使用<code>惰性删除</code>和<code>定期删除</code>两种方式作为键值对的过期策略。</p>
<p>但是仍然存在一些问题：</p>
<ol>
<li>定期删除的随机性可能会留下一些很久未使用的key</li>
<li>大量加入键值对会造成内存溢出</li>
</ol>
<p>因此redis还采用了<code>内存淘汰策略</code>来应对内存耗尽的场景。</p>
<h2 id="内存淘汰"><a href="#内存淘汰" class="headerlink" title="内存淘汰"></a>内存淘汰</h2><p><a href="https://blog.csdn.net/newCheng/article/details/100700101">https://blog.csdn.net/newCheng/article/details/100700101</a></p>
<h3 id="内存淘汰策略介绍（8种）"><a href="#内存淘汰策略介绍（8种）" class="headerlink" title="内存淘汰策略介绍（8种）"></a>内存淘汰策略介绍（8种）</h3><p><strong>无淘汰策略：noeviction，内存溢出时拒绝插入</strong></p>
<p><strong>针对所有的键值对</strong></p>
<ul>
<li>allkeys-lru</li>
<li>allkeys-random</li>
<li>allkeys-lfu</li>
</ul>
<p><strong>针对设置过期时间的键值对</strong></p>
<ul>
<li>volatile-lru</li>
<li>volatile-random</li>
<li>volatile-lfu</li>
<li>volatile-ttl：优先淘汰过期时间更早的键值对</li>
</ul>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p><strong>查看当前的最大内存设置和内存淘汰策略</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONFIG GET maxmemory</span><br><span class="line">CONFIG GET maxmemory-policy</span><br></pre></td></tr></table></figure>

<p><strong>修改内存淘汰策略</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONFIG SET maxmemory-policy allkeys-lru</span><br><span class="line">CONFIG REWRITE <span class="comment"># 服务启动时带上配置文件才能执行此命令，否则报错</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p><code>Redis</code>是一种内存型的数据库，它的键值对数据全部存在内存中。如果不加以预防，就会面临断电丢失的情况。</p>
<p>因此<code>Redis</code>用到了两种持久化策略，分别是<code>RDB</code>和<code>AOF</code></p>
</blockquote>
<h2 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB(快照)"></a>RDB(快照)</h2><p>对于一种持久化方式，我们可能会有以下一些疑惑：</p>
<ol>
<li>它持久化了什么</li>
<li>持久化是怎样进行的</li>
<li>如何恢复数据</li>
<li>特点</li>
</ol>
<p>下面我们会围绕这些问题进行介绍。</p>
<h3 id="一、RDB介绍"><a href="#一、RDB介绍" class="headerlink" title="一、RDB介绍"></a>一、RDB介绍</h3><p>RDB文件是一种经过压缩的二进制文件，保存了Redis在某一时刻的<strong>所有数据</strong>，即<strong>快照</strong></p>
<p>它的文件结构大致如下：</p>
<table>
<thead>
<tr>
<th align="center">REDIS</th>
<th align="center">db_version</th>
<th align="center">databases</th>
<th align="center">EOF</th>
<th align="center">checksum</th>
</tr>
</thead>
<tbody><tr>
<td align="center">魔数</td>
<td align="center">rdb版本</td>
<td align="center">多个数据库数据</td>
<td align="center">标志结束</td>
<td align="center">校验和</td>
</tr>
</tbody></table>
<h3 id="二、RDB文件的生成与载入"><a href="#二、RDB文件的生成与载入" class="headerlink" title="二、RDB文件的生成与载入"></a>二、RDB文件的生成与载入</h3><h5 id="2-1RDB相关命令"><a href="#2-1RDB相关命令" class="headerlink" title="2.1RDB相关命令"></a>2.1RDB相关命令</h5><p>生成RDB文件的相关命令有两个，分别是<code>save</code>和<code>bgsave</code></p>
<ul>
<li><code>save</code>：会阻塞服务器进程</li>
<li><code>bgsave</code>：创建子进程进行持久化，不阻塞</li>
</ul>
<h5 id="2-2生成情况：手动or自动"><a href="#2-2生成情况：手动or自动" class="headerlink" title="2.2生成情况：手动or自动"></a>2.2生成情况：手动or自动</h5><p>Redis客户端可以通过上述的<code>save</code>或<code>bgsave</code>命令手动进行持久化。</p>
<p>此外，服务端也支持配置，在满足配置条件时自动执行RDB持久。</p>
<p>例如<code>save 900 1</code>配置表示在900秒内修改1次，就会启动RDB。</p>
<h5 id="2-3加载RDB文件"><a href="#2-3加载RDB文件" class="headerlink" title="2.3加载RDB文件"></a>2.3加载RDB文件</h5><p>如果没有开启AOF，服务器会在启动时寻找RDB文件并进行加载。</p>
<h3 id="三、相关配置"><a href="#三、相关配置" class="headerlink" title="三、相关配置"></a>三、相关配置</h3><p><strong>RDB的默认配置</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p><strong>关闭RDB持久化</strong></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">save</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="AOF-追加"><a href="#AOF-追加" class="headerlink" title="AOF(追加)"></a>AOF(追加)</h2><h3 id="一、AOF介绍"><a href="#一、AOF介绍" class="headerlink" title="一、AOF介绍"></a>一、AOF介绍</h3><p>AOF持久化通过记录Redis服务器的<strong>写操作</strong>来实现持久化。</p>
<h3 id="二、AOF文件的生成与载入"><a href="#二、AOF文件的生成与载入" class="headerlink" title="二、AOF文件的生成与载入"></a>二、AOF文件的生成与载入</h3><h5 id="2-1实现AOF文件"><a href="#2-1实现AOF文件" class="headerlink" title="2.1实现AOF文件"></a>2.1实现AOF文件</h5><p>实现AOF持久化的过程可以分为3步：<strong>命令追加</strong>、<strong>文件写入</strong>和<strong>文件同步</strong>。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20211025123206.png" alt="image-20211025123206155"></p>
<ul>
<li>命令追加<ul>
<li>redis在处理命令请求时，用AOF缓冲区记录执行过的一些写操作</li>
</ul>
</li>
<li>文件写入<ul>
<li>redis处理完请求后，会将AOF缓冲区的内容写入到AOF文件中</li>
</ul>
</li>
<li>文件同步<ul>
<li>由于操作系统缓冲的存在，就会产生怎样写的情况</li>
<li>文件同步通过一个<code>appendfsync</code>参数来配置。</li>
</ul>
</li>
</ul>
<p><strong>appendfsync参数配置</strong></p>
<table>
<thead>
<tr>
<th align="center">取值</th>
<th align="center">对应策略</th>
</tr>
</thead>
<tbody><tr>
<td align="center">always</td>
<td align="center">每次文件写入时都进行同步</td>
</tr>
<tr>
<td align="center">everysec（默认）</td>
<td align="center">正常写（会经过OS缓冲），后台线程判断超过一秒钟时进行同步操作</td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">正常写，由操作系统决定啥时候同步</td>
</tr>
</tbody></table>
<p><strong>代码示例</strong></p>
<p>写入文件时直接刷新到磁盘上，有两种方式可以做到。</p>
<p>第一种：打开文件时使用<code>O_SYNC</code>标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> s[] = <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步打开</span></span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">&quot;/root/file.txt&quot;</span>, O_RDWR|O_SYNC);</span><br><span class="line">        write(fd, s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">        </span><br><span class="line">    	close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种，写完文件后调用<code>fsync</code>、<code>fdatasync</code>等系统调用进行同步</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> s[] = <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">&quot;/root/file.txt&quot;</span>, O_RDWR);</span><br><span class="line">        write(fd, s, <span class="keyword">sizeof</span>(s));</span><br><span class="line">        fsync(fd);</span><br><span class="line">    </span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2加载AOF文件"><a href="#2-2加载AOF文件" class="headerlink" title="2.2加载AOF文件"></a>2.2加载AOF文件</h5><p>服务器启动时，如果开启了AOF持久化，则redis会开启一个伪客户端，把分析得到的命令交给伪客户端执行。</p>
<h3 id="三、AOF重写"><a href="#三、AOF重写" class="headerlink" title="三、AOF重写"></a>三、AOF重写</h3><h5 id="3-1为什么要重写AOF文件？"><a href="#3-1为什么要重写AOF文件？" class="headerlink" title="3.1为什么要重写AOF文件？"></a>3.1为什么要重写AOF文件？</h5><p>AOF文件记录的是写操作，容易发生文件体积膨胀的问题。</p>
<p>此外加载AOF文件时，执行效率也会降低。</p>
<h5 id="3-2怎样重写AOF文件"><a href="#3-2怎样重写AOF文件" class="headerlink" title="3.2怎样重写AOF文件"></a>3.2怎样重写AOF文件</h5><p>redis开启子进程，在后台利用当前数据库的数据来重新生成AOF文件并覆盖原文件。</p>
<p>使用<code>BGREWRITEAOF</code>命令可以手动开启重写。</p>
<p><strong>特点：</strong></p>
<ol>
<li>使用子进程而不是当前进程：防止服务器阻塞</li>
<li>没有使用原AOF文件的方式：</li>
</ol>
<p><strong>问题：子进程在后台生成AOF文件时，当前数据库的数据可能会发生变化，导致持久化的数据与实际数据不一致的情况</strong></p>
<p>解决：重写AOF时，服务器把写操作记录到AOF缓冲和AOF重写缓冲中。</p>
<p>解释：前者是为了AOF持久化的正常工作，后者是将AOF重写过程中的数据变化记录下来，等子进程重写完毕后把这一部分发送给它。</p>
<h3 id="四、相关配置"><a href="#四、相关配置" class="headerlink" title="四、相关配置"></a>四、相关配置</h3><p><strong>AOF默认为关闭，如果要开启，改为yes</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure>

<p><strong>文件同步策略</strong></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta"># appendfsync no</span></span><br></pre></td></tr></table></figure>

<p><strong>自动重写AOF</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AOF文件大小为上次重写后AOF文件大小时，开始重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动进行AOF文件重写的最小大小</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下RDB与AOF的特点，从持久化速度、加载速度、文件大小、数据安全性等多个维度进行讨论。</p>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化速度</td>
<td align="center">不支持秒级，慢</td>
<td align="center">支持秒级</td>
</tr>
<tr>
<td align="center">加载速度</td>
<td align="center">很快</td>
<td align="center">执行写操作，慢</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">压缩后小</td>
<td align="center">文件较大</td>
</tr>
<tr>
<td align="center">数据安全性</td>
<td align="center">距离上次持久化后的数据都可能会丢</td>
<td align="center">默认配置下最多丢1秒的数据</td>
</tr>
<tr>
<td align="center">开销</td>
<td align="center">每次持久化都会fork一个子进程</td>
<td align="center">处理事件后需要写缓冲</td>
</tr>
</tbody></table>
<h2 id="RDB与AOF的混合使用"><a href="#RDB与AOF的混合使用" class="headerlink" title="RDB与AOF的混合使用"></a>RDB与AOF的混合使用</h2><p>redis4.0提出了两种持久化方式混合使用的方案：</p>
<p>RDB以一定的频率运行，然后在两次RDB间使用AOF记录写操作。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis客户端与服务器</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="一、客户端属性"><a href="#一、客户端属性" class="headerlink" title="一、客户端属性"></a>一、客户端属性</h3><p>服务器通过一个<code>clients</code>链表维护连接的客户端</p>
<p>涉及的客户端信息有：描述符、名称、输入输出缓冲区、状态等等。</p>
<h3 id="二、客户端类型"><a href="#二、客户端类型" class="headerlink" title="二、客户端类型"></a>二、客户端类型</h3><p>客户端的类型有：通过网络连接的客户端、加载AOF文件的伪客户端以及执行Lua脚本的伪客户端。</p>
<p>不同的类型创建和关闭的方式不太一样。</p>
<ol>
<li>网络连接的客户端<ul>
<li>创建：用<code>clients</code>链表相连</li>
<li>关闭：正常关闭，或空转时间、缓冲区溢出等原因造成关闭</li>
</ul>
</li>
<li>加载AOF文件的伪客户端<ul>
<li>创建：单独创建</li>
<li>关闭：加载完毕后关闭</li>
</ul>
</li>
<li>执行Lua脚本的伪客户端<ul>
<li>创建：用<code>lua_client</code>记录</li>
<li>关闭：随服务器运行</li>
</ul>
</li>
</ol>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="一、命令执行的过程"><a href="#一、命令执行的过程" class="headerlink" title="一、命令执行的过程"></a>一、命令执行的过程</h3><h5 id="1-1简化的过程"><a href="#1-1简化的过程" class="headerlink" title="1.1简化的过程"></a>1.1简化的过程</h5><ol>
<li>客户端发送命令请求</li>
<li>服务器接收请求并处理</li>
<li>服务器返回结果</li>
</ol>
<p>其中1、3步其实涉及了Redis使用的<strong>协议格式</strong>，因为在通信时命令请求是被封装成某个协议格式进行发送的。</p>
<p>第二步涉及Redis如何解析命令请求。</p>
<h5 id="1-2服务器处理命令请求"><a href="#1-2服务器处理命令请求" class="headerlink" title="1.2服务器处理命令请求"></a>1.2服务器处理命令请求</h5><ol>
<li>按协议格式解析命令请求</li>
<li>命令执行器执行命令<ul>
<li>预处理</li>
<li>执行</li>
<li>后续工作</li>
</ul>
</li>
</ol>
<p>Redis服务器维护了一个<code>命令表</code>的字典，可以根据命令的名称找到具体的执行函数。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>消息存储</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E5%9B%9B%E3%80%81%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="Kafka消息存储"><a href="#Kafka消息存储" class="headerlink" title="Kafka消息存储"></a>Kafka消息存储</h1><h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><ul>
<li><strong>kafka服务节点</strong></li>
<li>如果是单机的kafka，那么broker就只有一个；如果是集群，则会有多个broker</li>
</ul>
<h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><ul>
<li><strong>主题，是一种逻辑概念。</strong></li>
<li>一个主题可以包含多个分区，每个分区位于不同的节点上。</li>
</ul>
<h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><ul>
<li><strong>分区，是一种物理概念</strong></li>
<li>可以在某一个broker的数据目录下找到以”主题-分区”命名的文件夹</li>
</ul>
<h2 id="二、带着问题学习"><a href="#二、带着问题学习" class="headerlink" title="二、带着问题学习"></a>二、带着问题学习</h2><h3 id="2-1生产者发出的消息存在哪儿？"><a href="#2-1生产者发出的消息存在哪儿？" class="headerlink" title="2.1生产者发出的消息存在哪儿？"></a>2.1生产者发出的消息存在哪儿？</h3><p>这个是由<code>server.properties</code>文件中的<code>log.dirs</code>配置项来决定的。例如我配置在<code>kafka1/data</code>路径下。</p>
<p>数据目录的内容如下，里面的每个文件夹都是一个分区，命名格式为<code>topic-partition</code></p>
<ul>
<li><p><code>__consumer_offsets</code>：kafka内部主题</p>
</li>
<li><p><code>topic_first</code>和<code>topic_second</code>等自定义的主题及分区</p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111171444098.png" alt="image-20211117121306130"></p>
<p>查看topic_second-0的内容发现目前存放了5个文件，分别是：</p>
<ol>
<li><code>.index</code>：偏移量索引文件</li>
<li><code>.log</code>：真正的消息文件，即数据</li>
<li><code>.timeindex</code>：时间索引文件</li>
<li>leader-epoch-checkpoint</li>
<li>partition.metadata</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111171444616.png" alt="image-20211117121739809"></p>
<hr>
<h3 id="2-2kafka是如何存储消息的？"><a href="#2-2kafka是如何存储消息的？" class="headerlink" title="2.2kafka是如何存储消息的？"></a>2.2kafka是如何存储消息的？</h3><p>为了防止数据文件过大，kafka采用了<code>分段</code>和<code>索引</code>的方式。每一段可以由一个log文件和两个索引文件组成（以及可能的其他文件）。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111171526705.png" alt="image-20211117152613529"></p>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>数据文件被分成多个<code>log</code>文件进行存储，其中：</p>
<ul>
<li>文件名：起始偏移量，表示在该文件记录的所有消息中的最小偏移量。如上图的<code>00000000000000000000.log</code>，因为是从第一条消息开始记录，所以偏移量为0</li>
<li>文件大小：由<code>log.segment.bytes</code>配置项决定，默认为1GB</li>
</ul>
<p><strong>如何定位消息所在的log文件？</strong></p>
<p>维护一个跳表，跳表的key是每个文件的起始偏移量，这样就可以得知消息在哪个log文件中。</p>
<p>例如查找消息的偏移量为121，那就在<code>120.log</code>中</p>
<table>
<thead>
<tr>
<th align="center">baseoffset=0</th>
<th align="center">baseoffset=120</th>
<th align="center">baseoffset=365</th>
<th align="center">baseoffset=488</th>
<th align="center">baseoffset=788</th>
</tr>
</thead>
</table>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>我们知道消息在哪个log文件之后，还需要知道消息在log中的具体位置，这就需要借助<code>索引文件</code>。</p>
<p><strong>索引文件结构</strong></p>
<p>每个索引项都占8字节，结构如下：</p>
<table>
<thead>
<tr>
<th align="center">relativeOffset</th>
<th align="center">position</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4字节</td>
<td align="center">4字节</td>
</tr>
</tbody></table>
<p><strong>如何根据索引文件来定位消息在log文件中的位置？</strong></p>
<p>在相对偏移量中进行二分查找，确定小于目标offset的最接近的偏移量，然后得到物理位置去log文件中往下找。</p>
<p>例如在<code>27.index</code>中查找offset为50的消息位置：</p>
<table>
<thead>
<tr>
<th align="center">relativeOffset</th>
<th align="center">position</th>
</tr>
</thead>
<tbody><tr>
<td align="center">14</td>
<td align="center">156</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">459</td>
</tr>
<tr>
<td align="center">35</td>
<td align="center">666</td>
</tr>
<tr>
<td align="center">45</td>
<td align="center">863</td>
</tr>
</tbody></table>
<ol>
<li>计算相对偏移量<ul>
<li>50-27=23</li>
</ul>
</li>
<li>通过<code>二分查找</code>在索引文件中找到22的一项</li>
<li>去<code>27.log</code>文件中的459字节处开始往下找</li>
</ol>
<hr>
<h3 id="2-3消息的过期机制是怎样的？"><a href="#2-3消息的过期机制是怎样的？" class="headerlink" title="2.3消息的过期机制是怎样的？"></a>2.3消息的过期机制是怎样的？</h3><p>消息在磁盘上存储为一个个log文件，这些log文件会占据磁盘一定的容量。</p>
<p>因此Kafka提供了基于<strong>时间</strong>、<strong>文件大小</strong>和<strong>起始偏移量</strong>的删除策略。</p>
<p><strong>存在时间</strong>和<strong>文件大小</strong>都是由配置项决定的，默认配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">log.retention.hours=168                <span class="comment"># log文件保留七天</span></span><br><span class="line">log.segment.bytes=1073741824           <span class="comment"># 每个log文件最大1GB，超过则写新文件中</span></span><br><span class="line">log.retention.check.interval.ms=300000 <span class="comment"># 每隔5分钟检查是否可以删除</span></span><br></pre></td></tr></table></figure>

<p>另外，基于日志起始偏移量的删除是因为log文件有可能被截断，那么小于起始偏移量的消息就不应该被保留。</p>
<hr>
<h3 id="2-4Kafka高性能、高吞吐是怎样做到的？"><a href="#2-4Kafka高性能、高吞吐是怎样做到的？" class="headerlink" title="2.4Kafka高性能、高吞吐是怎样做到的？"></a>2.4Kafka高性能、高吞吐是怎样做到的？</h3><h5 id="顺序追加"><a href="#顺序追加" class="headerlink" title="顺序追加"></a>顺序追加</h5><p>消息顺序的写到磁盘文件中，并使用操作系统的刷盘策略。</p>
<p>兼顾消息的读写性能与完整性。</p>
<h5 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h5><p>操作系统利用内存加载了大量的磁盘页（即页缓存），使用<strong>预读</strong>和<strong>后写</strong>的方式大大加快了IO效率。</p>
<blockquote>
<p><strong>预读</strong>指读磁盘上的数据时，把后面的一部分数据也读到内存中，这样加快下一次读的效率</p>
<p><strong>后写</strong>指向磁盘写数据时，只是把数据写入到一个缓冲区中，然后由操作系统决定何时写入磁盘。在用户看来已经写入完毕。</p>
</blockquote>
<h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><p>正常传输流程：</p>
<ol>
<li>从磁盘读数据到内核的READ BUFFER缓冲区中</li>
<li>数据从内核传输到用户</li>
<li>用户态下的数据传递给socket</li>
<li>socket把数据传递给网卡（NIC）</li>
</ol>
<p>零拷贝利用<code>DMA</code>(直接内存访问)的方式，直接把数据从内核缓冲区传输到socket中。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
  </entry>
  <entry>
    <title>生产者与消费者实践</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p>之前使用命令行和脚本的方式来操作kafka，但是一般用的更多的是在项目中用高级语言来操作。</p>
<p>下面是springboot中kafka的使用</p>
</blockquote>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="生产者示例"><a href="#生产者示例" class="headerlink" title="生产者示例"></a>生产者示例</h2><h5 id="一、创建Producer类，用于编写生产者发送消息的过程。"><a href="#一、创建Producer类，用于编写生产者发送消息的过程。" class="headerlink" title="一、创建Producer类，用于编写生产者发送消息的过程。"></a>一、创建<code>Producer</code>类，用于编写生产者发送消息的过程。</h5><h5 id="二、初始化配置"><a href="#二、初始化配置" class="headerlink" title="二、初始化配置"></a>二、初始化配置</h5><p><strong>配置项说明</strong></p>
<table border="1" style="margin:200; text-align:center;">
    <tbody>
        <tr>
            <th colspan="2">配置项</th>
            <th colspan="2">描述</th>
        </tr>
        <tr>
            <td colspan="2">bootstrap.servers</td>
            <td colspan="2">broker节点，如果是集群也不需要全部列出来，一般列出两个即可</td>
        </tr>
        <tr>
            <td rowspan="3" colspan="2" >ack</td>
            <td colspan="2">ack = 1, leader同步了消息，就返回ack</td>
        </tr>
        <tr>
            <td colspan="2">ack = 0, 不等待服务端任何响应，直接返回ack</td>
        </tr>
        <tr>
            <td colspan="2">ack = -1, 所有副本同步了消息才返回ack</td>
        </tr>
        <tr>
            <td colspan="2">compression.type</td>
            <td colspan="2">压缩方式，可以配置为gzip、snappy、lz4等</td>
        </tr>



<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_LIST = <span class="string">&quot;192.168.13.130:9091,192.168.13.130:9092&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, BROKER_LIST);</span><br><span class="line">        prop.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        prop.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回ack策略</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">// 消息最大值</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;max.request.size&quot;</span>, <span class="string">&quot;1048576&quot;</span>);</span><br><span class="line">        <span class="comment">// 重发次数和间隔</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;retries.backoff.ms&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息压缩方式</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;compression.type&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义的拦截器</span></span><br><span class="line">        prop.setProperty(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, MyProducerInterceptor.class.getName());</span><br><span class="line">        <span class="keyword">return</span> prop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、定义消息并发送"><a href="#三、定义消息并发送" class="headerlink" title="三、定义消息并发送"></a>三、定义消息并发送</h5><p>对于消息的发送，我们可以选择三种模式：</p>
<ol>
<li>发后即忘，不做任何处理</li>
<li>同步发送，阻塞等待结果</li>
<li>异步回调，传入回调函数在发送完毕后执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Properties prop = initConfig();</span><br><span class="line">    KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(prop,</span><br><span class="line">            <span class="keyword">new</span> StringSerializer(),</span><br><span class="line">            <span class="keyword">new</span> StringSerializer());</span><br><span class="line">    ProducerRecord&lt;String, String&gt; record1 = <span class="keyword">new</span> ProducerRecord(TOPIC, <span class="string">&quot;aurora&quot;</span>);</span><br><span class="line">    ProducerRecord&lt;String, String&gt; record2 = <span class="keyword">new</span> ProducerRecord(TOPIC, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">    ProducerRecord&lt;String, String&gt; record3 = <span class="keyword">new</span> ProducerRecord(TOPIC, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 异步，不处理结果</span></span><br><span class="line">        producer.send(record1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步，调用get阻塞等待结果</span></span><br><span class="line">        producer.send(record2).get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步回调，回调函数处理异常</span></span><br><span class="line">        producer.send(record3, (RecordMetadata recordMetadata, Exception e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;[INFO] 回调输出：&quot;</span> + recordMetadata.topic() + <span class="string">&quot;-&quot;</span></span><br><span class="line">                        + recordMetadata.partition() + <span class="string">&quot;:&quot;</span></span><br><span class="line">                        + recordMetadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产者补充部分"><a href="#生产者补充部分" class="headerlink" title="生产者补充部分"></a>生产者补充部分</h2><h5 id="一、拦截器"><a href="#一、拦截器" class="headerlink" title="一、拦截器"></a>一、拦截器</h5><p><strong>是什么？</strong></p>
<p>拦截器可以在消息发出前以及收到返回的ack后，添加额外的操作。</p>
<p><strong>如何实现？</strong></p>
<p>实现<code>ProducerInterceptor</code>接口，实现其中的方法即可。下面是一个拦截器示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProducerInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger sendSuccess = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger sendFailure = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 为消息的值添加前缀</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord <span class="title">onSend</span><span class="params">(ProducerRecord record)</span> </span>&#123;</span><br><span class="line">        String newVal = <span class="string">&quot;pre-&quot;</span> + record.value();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProducerRecord(record.topic(), record.partition(), record.timestamp(),</span><br><span class="line">                record.key(), record.value(), record.headers());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 消息成功发送后，输出一些信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sendFailure.incrementAndGet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendSuccess.incrementAndGet();</span><br><span class="line">            System.out.println(<span class="string">&quot;write into partition: &quot;</span> + metadata.partition() + <span class="string">&quot; &quot;</span> + metadata.topic());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计消息发送成功率</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> rate = (<span class="keyword">double</span>)sendSuccess.get() / (sendSuccess.get() + sendFailure.get());</span><br><span class="line">        System.out.printf(<span class="string">&quot;[INFO] 发送成功率=%f%s\n&quot;</span>, rate*<span class="number">100</span>, <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二、序列化器"><a href="#二、序列化器" class="headerlink" title="二、序列化器"></a>二、序列化器</h5><p><strong>是什么？</strong></p>
<p>将消息转化成字节流的形式，进行传输。</p>
<p>一般使用的序列化器是<code>StringSerializer</code>，在配置中添加这一项即可。</p>
<p><strong>如何实现？</strong></p>
<p>实现<code>Serializer</code>接口。</p>
<h5 id="三、分区器"><a href="#三、分区器" class="headerlink" title="三、分区器"></a>三、分区器</h5><p><strong>是什么？</strong></p>
<p>分区器可以决定消息要发往主题的哪一个分区。当然，如果指定了分区，那么分区器就不会起作用。</p>
<p><strong>如何实现？</strong></p>
<p>实现<code>Partitioner</code>接口。</p>
<h2 id="消费者示例"><a href="#消费者示例" class="headerlink" title="消费者示例"></a>消费者示例</h2><p>消费者的主要行为是订阅topic或partition，然后进行消费。</p>
<h5 id="一、初始化配置"><a href="#一、初始化配置" class="headerlink" title="一、初始化配置"></a>一、初始化配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, Config.BROKER_LIST);</span><br><span class="line">    prop.setProperty(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    prop.setProperty(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line"></span><br><span class="line">    prop.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;group1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二、订阅主题或分区"><a href="#二、订阅主题或分区" class="headerlink" title="二、订阅主题或分区"></a>二、订阅主题或分区</h5><p>消费者API中提供了多种方式进行订阅，下面列举了一些：</p>
<p>注意，通过<code>subscribe</code>、<code>assign</code>和<code>正则</code>这三种方式的订阅是互斥的，不要对同一个消费者混合使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Properties prop = initConfig();</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(prop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅指定topic</span></span><br><span class="line">    consumer.subscribe(Arrays.asList(Config.TOPIC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅指定topic和partition</span></span><br><span class="line">    consumer.assign(Arrays.asList(<span class="keyword">new</span> TopicPartition(Config.TOPIC, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则表达式批量订阅</span></span><br><span class="line">    consumer.subscribe(Pattern.compile(<span class="string">&quot;test*&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询并订阅topic的所有分区</span></span><br><span class="line">    List&lt;TopicPartition&gt; topic = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = consumer.partitionsFor(Config.TOPIC);</span><br><span class="line">    <span class="keyword">for</span> (PartitionInfo partition : partitions) &#123;</span><br><span class="line">        topic.add(<span class="keyword">new</span> TopicPartition(partition.topic(), partition.partition()));</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.assign(topic); </span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、拉取消息"><a href="#三、拉取消息" class="headerlink" title="三、拉取消息"></a>三、拉取消息</h5><p>通过循环不断地轮询，尝试读取消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Properties prop = initConfig();</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(prop);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省去订阅步骤...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(isRunning.get()) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            <span class="comment">// 模拟消息处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Topic = &quot;</span> + record.topic()</span><br><span class="line">                    + <span class="string">&quot;, partition = &quot;</span> + record.partition()</span><br><span class="line">                    + <span class="string">&quot;, offset = &quot;</span> + record.offset());</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + record.key()</span><br><span class="line">                    + <span class="string">&quot;value = &quot;</span> + record.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、提交位移"><a href="#四、提交位移" class="headerlink" title="四、提交位移"></a>四、提交位移</h5><p>下面演示手动提交位移，首先记得关闭自动提交：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">prop.setProperty(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>同步提交</strong></p>
<p>按分区来对消息进行处理并提交位移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(isRunning.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="comment">// 针对分区进行消费</span></span><br><span class="line">    <span class="keyword">for</span>(TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">        List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ConsumerRecord&lt;String, String&gt; record : partitionRecords) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Topic = &quot;</span> + record.topic()</span><br><span class="line">                    + <span class="string">&quot;, partition = &quot;</span> + record.partition()</span><br><span class="line">                    + <span class="string">&quot;, offset = &quot;</span> + record.offset());</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + record.key()</span><br><span class="line">                    + <span class="string">&quot;value = &quot;</span> + record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同步提交位移</span></span><br><span class="line">        <span class="keyword">long</span> lastConsumedOffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">        consumer.commitSync(Collections.singletonMap(partition, <span class="keyword">new</span> OffsetAndMetadata(lastConsumedOffset + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer.close();</span><br></pre></td></tr></table></figure>

<p><strong>异步提交</strong></p>
<p>异步提交，并传入回调函数在提交完后执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(isRunning.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        <span class="comment">// 处理消息...</span></span><br><span class="line"></span><br><span class="line">        consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(offsets);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// log.error(&quot;fail to commit offsets &#123; &#125;&quot;, offsets, exception);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、退出消费"><a href="#五、退出消费" class="headerlink" title="五、退出消费"></a>五、退出消费</h5><p>消费的大致结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line"> 		<span class="comment">// 消费消息、提交位移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// do some logic process</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kafka Consumer提供了<code>wakeup()</code>抛出一个WakeupException来退出消费。</p>
<p>此外，我们还可以通过设置<code>isRunning</code>为false来退出消费的循环。</p>
<h2 id="消费者补充"><a href="#消费者补充" class="headerlink" title="消费者补充"></a>消费者补充</h2><h5 id="一、再均衡监听器"><a href="#一、再均衡监听器" class="headerlink" title="一、再均衡监听器"></a>一、再均衡监听器</h5><p>再均衡是指当消费者组中的消费者数量发生变化，或主题的分区数变化时，Kafka会进行重新分配的过程。在这过程中，消费者是无法进行消费的。</p>
<p>简单示例：在发生再均衡之前，先提交位移。</p>
<p>当然也可以把位移保存在其他地方，然后再均衡结束时，取出位移并指定位移消费。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(Config.TOPIC), <span class="keyword">new</span> <span class="function"><span class="title">ConsumerRebalanceListener</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onPartitionsRevoked</span>(<span class="params">Collection&lt;TopicPartition&gt; partitions</span>)</span> &#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onPartitionsAssigned</span>(<span class="params">Collection&lt;TopicPartition&gt; partitions</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="二、消费者拦截器"><a href="#二、消费者拦截器" class="headerlink" title="二、消费者拦截器"></a>二、消费者拦截器</h5><p>消费者拦截器用于在消费者拿到消息或提交位移时进行定制化操作（比如过滤）。</p>
<p>自定义的消费者拦截器需要实现<code>ConsumerInterceptor</code>接口，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Configurable</span>, <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function">ConsumerRecords&lt;K, V&gt; <span class="title">onConsume</span><span class="params">(ConsumerRecords&lt;K, V&gt; records)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onCommit</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、多线程消费"><a href="#三、多线程消费" class="headerlink" title="三、多线程消费"></a>三、多线程消费</h5><p><strong>形式1：开启多个线程，每个线程消费不同的分区</strong></p>
<p><code>ConsumerThread</code>继承Thread类并重写run方法。在<code>run()</code>内部进行消息的获取和消费，这里就不再赘述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties prop = initConfig();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 线程数可指定</span></span><br><span class="line">    ConsumerThread thread = <span class="keyword">new</span> ConsumerThread(Config.TOPIC, prop);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>形式2：多个消费者线程消费同一个分区</strong></p>
<p>这种方式可以用<code>seek()</code>或<code>assign()</code>来实现，但是对于位移提交和顺序控制将会非常困难。所以一般不推荐使用。</p>
<p><strong>形式3：线程池消费不同批次的消息</strong></p>
<p>因为使用线程池对线程进行管理，所以可能存在消费了同一分区消息的情况。因此我们需要对消费位移进行维护。</p>
<p>首先，定义<code>KafkaConsumerThread</code>，该线程负责实现将拉取到的记录加入到线程池中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    KafkaConsumer consumer;</span><br><span class="line">    ExecutorService executors;</span><br><span class="line">    ConcurrentMap&lt;TopicPartition, OffsetAndMetadata&gt; offsets;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对消费者和线程池进行初始化</span></span><br><span class="line">    KafkaConsumerThread(String topic, Properties prop, <span class="keyword">int</span> threadNumber) &#123;</span><br><span class="line">        consumer = <span class="keyword">new</span> KafkaConsumer(prop);</span><br><span class="line">        consumer.subscribe(Collections.singletonList(topic));</span><br><span class="line">        executors = <span class="keyword">new</span> ThreadPoolExecutor(threadNumber, threadNumber, <span class="number">0L</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">1000</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()); <span class="comment">// 让调用线程处理多余的消息</span></span><br><span class="line"></span><br><span class="line">        offsets = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">                <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                    executors.submit(<span class="keyword">new</span> RecordsHandler(records, offsets));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 提交位移</span></span><br><span class="line">                <span class="keyword">if</span> (!offsets.isEmpty()) &#123;</span><br><span class="line">                    consumer.commitSync(offsets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对封装的<code>RecordsHandler</code>实现消息的消费逻辑（主要列出了重写的<code>run()</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    <span class="keyword">for</span>(TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">        List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = <span class="keyword">this</span>.records.records(partition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费过程...</span></span><br><span class="line">        <span class="keyword">for</span>(ConsumerRecord record : partitionRecords) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Current Thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;topic = &quot;</span> + record.topic()</span><br><span class="line">                    + <span class="string">&quot; partition = &quot;</span> + record.partition()</span><br><span class="line">                    + <span class="string">&quot; value = &quot;</span> + record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录位移, 条件为没有偏移量记录或消费偏移量更大 fixme</span></span><br><span class="line">        <span class="keyword">long</span> lastConsumedOffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">        <span class="keyword">if</span> (!offsets.containsKey(partition) || lastConsumedOffset + <span class="number">1</span> &gt; offsets.get(partition).offset()) &#123;</span><br><span class="line">            offsets.put(partition, <span class="keyword">new</span> OffsetAndMetadata(lastConsumedOffset + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h5 id="一、未指定partition和key时，消息全部发往一个分区"><a href="#一、未指定partition和key时，消息全部发往一个分区" class="headerlink" title="一、未指定partition和key时，消息全部发往一个分区"></a>一、未指定partition和key时，消息全部发往一个分区</h5><p><strong>问题描述</strong></p>
<p>连续发十条消息（编号0-9），我希望消费者读到的顺序是错位的，如<code>0369147258</code>。但是发现消息顺序读出来了。</p>
<p>打印一些信息后，发现消息都发在同一个分区了，因此消费者当然就会顺序消费了。（Kafka保证了消息的分区有序性）</p>
<p><strong>相关配置</strong></p>
<ol>
<li>发送策略：发后即忘</li>
<li>分区器：未设置，使用默认分区器</li>
</ol>
<p><strong>分析</strong></p>
<p>最后发现是因为粗心，生产者配置部分都是自己写的，忘记参照视频的样例。</p>
<p>默认的分区器使用粘性分区的思想，同一批发送的消息会发送到相同的分区，这样避免了分区的重复计算。（关于消息的分区器，可以参考另一篇理论性的文章）</p>
<p>如果希望消息发送到不同的分区，可以尝试设置<code>RoundRobin</code>分区器，实现轮询分配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者处</span></span><br><span class="line">prop.setProperty(ProducerConfig.PARTITIONER_CLASS_CONFIG, RoundRobinPartitioner.class.getName());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
  </entry>
  <entry>
    <title>生产者与消费者理论</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><h2 id="消息分区策略"><a href="#消息分区策略" class="headerlink" title="消息分区策略"></a>消息分区策略</h2><p>问题：当生产者向包含多个分区的Topic发送消息时，消息会发往哪个分区呢？</p>
<p>解释：</p>
<ol>
<li>发送时指定<code>partition</code>：发送到指定分区</li>
<li>发送时未指定<code>partition</code>：由分区器来决定</li>
</ol>
<p>在Kafka生产者中分区器主要有两种，默认分区器和轮询分区器。</p>
<h3 id="一、默认分区器"><a href="#一、默认分区器" class="headerlink" title="一、默认分区器"></a>一、默认分区器</h3><p>默认分区器利用了<code>粘性分区</code>的思想。</p>
<blockquote>
<p><code>粘性分区</code>表示在Kafka一次批量发送消息的过程中，会尽可能的减少分区的分配变动。</p>
<p>因此分区就是具备粘性的，在同一次批量发送中消息就会分配到同一个分区。</p>
</blockquote>
<h5 id="DefaultPartitioner"><a href="#DefaultPartitioner" class="headerlink" title="DefaultPartitioner"></a>DefaultPartitioner</h5><p><code>partition()</code>计算得到要发送的分区号，源码如下：</p>
<ol>
<li>未指定key时，用粘性分区缓存来获取分区号</li>
<li>指定key时，通过计算哈希值并求余的方式得到分区号。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> stickyPartitionCache.partition(topic, cluster);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StickyPartitionCache"><a href="#StickyPartitionCache" class="headerlink" title="StickyPartitionCache"></a>StickyPartitionCache</h5><p><code>StickyPartitionCache</code>类主要利用利用map记录主题和消息发往的分区号的映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StickyPartitionCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Integer&gt; indexCache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StickyPartitionCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.indexCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * partition()返回分区号</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 如果在map中找到了上次发往某个主题时分配的分区号，就返回该分区号（粘性分区）</span></span><br><span class="line"><span class="comment">    * 如果map中未找到，则调用nextPartition()执行一次重新分配分区号的动作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        Integer part = indexCache.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (part == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextPartition(topic, cluster, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> part;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、轮询分区器"><a href="#二、轮询分区器" class="headerlink" title="二、轮询分区器"></a>二、轮询分区器</h3><p>从<code>RoundRobinPartitioner</code>类的注解可以看到，如果希望消息能够分布式的写到不同的分区上，那么就可以使用轮询分区器。</p>
<p>它具备两个特点：</p>
<ol>
<li>平等的写入到每个分区</li>
<li>消息设置的key不会生效（即不会对它求hash来取值）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &quot;Round-Robin&quot; partitioner</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This partitioning strategy can be used when user wants </span></span><br><span class="line"><span class="comment"> * to distribute the writes to all partitions equally. This</span></span><br><span class="line"><span class="comment"> * is the behaviour regardless of record key hash. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="nextValue"><a href="#nextValue" class="headerlink" title="nextValue()"></a>nextValue()</h5><p>在map寻找topic对应的分区号，未找到则返回0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextValue</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">    AtomicInteger counter = topicCounterMap.computeIfAbsent(topic, k -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> counter.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="partition"><a href="#partition" class="headerlink" title="partition()"></a>partition()</h5><p>借助<code>nextValue()</code>返回的值来求余计算分区号。</p>
<p>此外，这里还有一些额外的逻辑，如判断是否有可用分区和确保nextValue为正。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">    <span class="keyword">int</span> nextValue = nextValue(topic);</span><br><span class="line">    List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">if</span> (!availablePartitions.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">        <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产者过程分析"><a href="#生产者过程分析" class="headerlink" title="生产者过程分析"></a>生产者过程分析</h2><p>生产者主要使用两个线程：主线程和Sender线程</p>
<p>主线程调用<code>send()</code>后，依次经过了<code>拦截器-序列化器-分区器</code>，然后被添加到消息累计器中。然后由Sender线程获取消息并发送给broker。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111211654366.png" alt="image-20211118170513669"></p>
<h3 id="一、消息累加器"><a href="#一、消息累加器" class="headerlink" title="一、消息累加器"></a>一、消息累加器</h3><p>在消息累加器中，每个分区都会对应一条队列，经过分区器计算或是直接指定分区的消息，便会加入到对应的队列中。</p>
<p>消息累加器<code>RecordAccumulator</code>使用map存储了某个主题下每个分区和队列的映射关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordAccumulator</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; batches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>队列中的<code>ProducerBatch</code>对象表示批量的记录，分配消息时会取出队列的最后一条batch记录，并把消息添加在batch中。</p>
<p>这里对应的就是<code>ProducerBatch</code>类下的tryAppend()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 检查空间后，调用MemoryRecordsBuilder对象的append方法来向内存中写入新消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FutureRecordMetadata <span class="title">tryAppend</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value, Header[] headers, Callback callback, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.recordsBuilder.append(timestamp, key, value, headers); </span><br><span class="line">        <span class="keyword">this</span>.maxRecordSize = Math.max(<span class="keyword">this</span>.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(),</span><br><span class="line">                recordsBuilder.compressionType(), key, value, headers));</span><br><span class="line">        <span class="keyword">this</span>.lastAppendTime = now;</span><br><span class="line">        FutureRecordMetadata future = <span class="keyword">new</span> FutureRecordMetadata(<span class="keyword">this</span>.produceFuture, <span class="keyword">this</span>.recordCount,</span><br><span class="line">                                                               timestamp,</span><br><span class="line">                                                               key == <span class="keyword">null</span> ? -<span class="number">1</span> : key.length,</span><br><span class="line">                                                               value == <span class="keyword">null</span> ? -<span class="number">1</span> : value.length,</span><br><span class="line">                                                               Time.SYSTEM);</span><br><span class="line">        <span class="comment">// we have to keep every future returned to the users in case the batch needs to be</span></span><br><span class="line">        <span class="comment">// split to several new batches and resent.</span></span><br><span class="line">        thunks.add(<span class="keyword">new</span> Thunk(callback, future));</span><br><span class="line">        <span class="keyword">this</span>.recordCount++;</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h2><h3 id="一、位移提交"><a href="#一、位移提交" class="headerlink" title="一、位移提交"></a>一、位移提交</h3><p><strong>对于Kafka分区而言，它的每条消息都有唯一的offset，用来表示消息在分区中的位置；而消费者也是通过offset来得知上次消费消息的位置。</strong></p>
<h5 id="那么这个位移存在哪儿？"><a href="#那么这个位移存在哪儿？" class="headerlink" title="那么这个位移存在哪儿？"></a>那么这个位移存在哪儿？</h5><p>旧版存在ZooKeeper中，新版存在Kafka Broker的<code>__consumer_offsets</code>主题中。</p>
<h5 id="什么是位移提交？为什么要提交位移？"><a href="#什么是位移提交？为什么要提交位移？" class="headerlink" title="什么是位移提交？为什么要提交位移？"></a>什么是位移提交？为什么要提交位移？</h5><p>消费者将消费的位移提交到Kafka Broker的动作，就是<strong>位移提交</strong>。而之所以需要提交，是因为消费者使用拉取消息的方式，Kafka并不知道消费者消费到哪儿了，需要消费者来告诉它。</p>
<h5 id="怎样进行位移提交"><a href="#怎样进行位移提交" class="headerlink" title="怎样进行位移提交?"></a>怎样进行位移提交?</h5><p>Kafka提供了<strong>自动提交</strong>和<strong>手动提交</strong>两种方式。</p>
<p>首先，确认一点，提交的位移指的是下一次要消费的消息所在的偏移量。</p>
<p><strong>自动提交</strong></p>
<p>自动提交指的是Kafka会定期的提交一次位移，定期由两个参数来配置：</p>
<ul>
<li><p><code>enable.auto.commit</code>：是否开启自动提交，默认为true</p>
</li>
<li><p><code>auto.commit.interval.ms</code>：自动提交的间隔，默认为5秒</p>
</li>
</ul>
<p>自动提交存在的问题：</p>
<ol>
<li><code>重复消费</code>：因为位移是延后提交的，所以存在消费者消费之后，还没来得及提交位移就宕机的可能。</li>
<li><code>消息丢失</code>：如果消费者端把读到的消息放入队列中等待另一个线程处理，那么有可能提交位移后消费者宕机，处理线程还未处理消息。</li>
</ol>
<p><strong>手动提交</strong></p>
<p>手动提交可以让开发人员根据程序的逻辑在合适的地方提交位移，<strong>注意，采用手动提交时必须关闭自动提交</strong>。</p>
<p>手动提交的时机非常重要：</p>
<ol>
<li>如果先提交再处理消息，消息可能还没处理消费者就宕机了，导致<strong>消息丢失</strong>。</li>
<li>如果先处理再提交，提交位移前消费者宕机就会造成<strong>重复消费</strong>。</li>
</ol>
<p>如果希望消息精确的只被消费一次，可以采用二阶段提交的方式：落表，并在消息处理前判断是否已存在记录。（还是有缺陷？何时落表？）</p>
<h2 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h2><p>分区分配策略：</p>
<ol>
<li>决定了处于同一消费者组中的消费者该消费哪个分区</li>
<li>保证一个分区只能被同一个消费者组中的一个消费者消费</li>
</ol>
<p>如果要打破<code>2</code>的限制</p>
<h3 id="一、RangeAssignor"><a href="#一、RangeAssignor" class="headerlink" title="一、RangeAssignor"></a>一、RangeAssignor</h3><h5 id="1-1分配原理"><a href="#1-1分配原理" class="headerlink" title="1.1分配原理"></a>1.1分配原理</h5><p>对<code>单个主题</code>的所有分区进行平均分配。</p>
<ul>
<li>如果分区数与消费者数能够整除，那么每个消费者分配到的分区数量都是一样的。</li>
<li>如果有余数，那么把余数分区一份份分给靠前（排序后）的消费者</li>
</ul>
<h5 id="1-2示例"><a href="#1-2示例" class="headerlink" title="1.2示例"></a>1.2示例</h5><blockquote>
<p>两个消费者订阅两个主题，每个主题3个分区。</p>
<p>如主题t0的分区为t0p0、t0p1、t0p2</p>
</blockquote>
<p>对于一个主题来说，每个消费者先分配1个分区，然后多余的1个分区分给第一个消费者。</p>
<p><strong>分配t0后的结果：</strong></p>
<ul>
<li>消费者C0：t0p0、t0p1</li>
<li>消费者C1：t0p2</li>
</ul>
<p><strong>然后分配t1后的结果：</strong></p>
<ul>
<li>消费者C0：t0p0、t0p1、t1p0、t1p1</li>
<li>消费者C1：t0p2、t1p2</li>
</ul>
<p>设想一下，如果新订阅了第三个主题（分区数为3），那么消费者C0所分配到的分区数还会多两个，<strong>不均衡</strong>的情况会更加严重。</p>
<h5 id="1-3特点"><a href="#1-3特点" class="headerlink" title="1.3特点"></a>1.3特点</h5><p>通过上述例子可以发现，<code>Range</code>策略可以保证<strong>分配一个主题的分区时每个消费者所分配到的分区数之差在一个以内。</strong></p>
<p>但是，当订阅多个主题时可能会存在某个消费者过载的问题，并且可能会随着订阅主题数的增加而愈发严重。</p>
<h3 id="二、RoundRobinAssingor"><a href="#二、RoundRobinAssingor" class="headerlink" title="二、RoundRobinAssingor"></a>二、RoundRobinAssingor</h3><h5 id="2-1分配原理"><a href="#2-1分配原理" class="headerlink" title="2.1分配原理"></a>2.1分配原理</h5><p>对消费者组订阅的<code>所有主题及分区</code>进行排序并依次分配。</p>
<h5 id="2-2示例1-同上述的例子"><a href="#2-2示例1-同上述的例子" class="headerlink" title="2.2示例1@同上述的例子"></a>2.2示例1<code>@同上述的例子</code></h5><blockquote>
<p>两个消费者订阅两个主题，每个主题3个分区。</p>
<p>所有订阅主题的分区排序：t0p0、t0p1、t0p2、t1p0、t1p1、t1p2</p>
</blockquote>
<p>分配结果（依次分配给消费者）：</p>
<ul>
<li>消费者C0：t0p0、t0p2、t1p1</li>
<li>消费者C1：t0p1、t1p0、t1p2</li>
</ul>
<p>可以看到，如果每个消费者订阅的主题是相同的，那么可以保证尽可能的均匀分配。</p>
<h5 id="2-3示例2-订阅不同主题"><a href="#2-3示例2-订阅不同主题" class="headerlink" title="2.3示例2@订阅不同主题"></a>2.3示例2<code>@订阅不同主题</code></h5><p>再看这个订阅不同主题的例子：</p>
<blockquote>
<p>三个消费者，订阅情况分别是：C0订阅t0，C1订阅t0、t1，C2订阅t0、t1、t2</p>
<p>主题分别有1，2，3个分区</p>
</blockquote>
<p>因为消费者C0和C1没有订阅所有主题，因此并不会参与所有主题分区的分配</p>
<p>所有分区排序：t0p0、t1p0、t1p1、t2p0、t2p1、t2p2</p>
<p>分配结果：</p>
<ul>
<li>消费者C0：t0p0</li>
<li>消费者C1：t1p0</li>
<li>消费者C2：t1p1、t2p0、t2p1、t2p2</li>
</ul>
<h5 id="2-4特点"><a href="#2-4特点" class="headerlink" title="2.4特点"></a>2.4特点</h5><p>和<code>RangeAssignor</code>相比，<code>RoundRobinAssignor</code>通过从多主题的角度考虑，保证了当每个消费者订阅相同的主题时的分配均衡（最多差一个）。</p>
<p>但是订阅的主题不同时，它并没有做到最优分配，例如上述例子中<code>t1p1</code>可以分配给C1</p>
<h3 id="三、StickyAssingor"><a href="#三、StickyAssingor" class="headerlink" title="三、StickyAssingor"></a>三、StickyAssingor</h3><p>粘性分配的目的：</p>
<ol>
<li>与其他分配策略一样，尽量保证分区的分配均衡。</li>
<li>进行<strong>再分配</strong>时，尽可能的减少分配的变化，即拥有“粘性”</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="一、消息丢失问题"><a href="#一、消息丢失问题" class="headerlink" title="一、消息丢失问题"></a>一、消息丢失问题</h3><p>Kafka生产者与消费者都有可能存在消息丢失的问题。</p>
<h5 id="生产者端"><a href="#生产者端" class="headerlink" title="生产者端"></a>生产者端</h5><p>原因在于<code>ack</code>的取值，值为0或1时没有做到所有副本的消息同步，因此副本宕机会造成消息丢失。</p>
<p><code>ack</code>取-1时所有副本同步后才算消息写入成功，但这样消息吞吐量会有所损失。</p>
<h5 id="消费者端"><a href="#消费者端" class="headerlink" title="消费者端"></a>消费者端</h5><p>原因可能是开启了自动提交位移，也可能是手动提交位移的情况下先提交再消费。</p>
<p>如何解决可以看上述的<strong>手动提交</strong>部分。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
  </entry>
  <entry>
    <title>环境搭建</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%80%E3%80%81Kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><blockquote>
<p>在Linux上搭建Kafka，需要有Java8和Zookeeper环境:stuck_out_tongue_winking_eye:</p>
</blockquote>
<h2 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h2><h5 id="查看Java包"><a href="#查看Java包" class="headerlink" title="查看Java包"></a>查看Java包</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum search java</span><br></pre></td></tr></table></figure>

<h5 id="选择jdk8进行安装"><a href="#选择jdk8进行安装" class="headerlink" title="选择jdk8进行安装"></a>选择jdk8进行安装</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk-devel.x86_64</span><br></pre></td></tr></table></figure>

<h5 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加变量JAVA_HOME，表示jdk安装路径。路径最后一长串可能不太一样，需要自己进入jvm目录下查看</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.171-8.b10.el6_9.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加变量CLASSPATH，表示jvm扫描class文件的路径</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加变量PATH，表示可以执行java提供的命令</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h5 id="查看java版本"><a href="#查看java版本" class="headerlink" title="查看java版本"></a>查看java版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>



<h2 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h2><h5 id="安装并解压"><a href="#安装并解压" class="headerlink" title="安装并解压"></a>安装并解压</h5><p>在安装前，最好进入到要安装的目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在官网（http://zookeeper.apache.org/releases.html）选择版本，找到下载路径</span></span><br><span class="line">wget https://downloads.apache.org/zookeeper/zookeeper-3.6.3/apache-zookeeper-3.6.3-bin.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.6.3-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="得到Zookeeper配置文件"><a href="#得到Zookeeper配置文件" class="headerlink" title="得到Zookeeper配置文件"></a>得到Zookeeper配置文件</h5><p>在<code>conf</code>文件夹中拷贝配置文件示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 必选，修改成自己想要的路径</span></span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/services/zookeeper/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可增加，日志目录</span></span><br><span class="line">dataLogDir=/usr/<span class="built_in">local</span>/services/zookeeper/logs</span><br></pre></td></tr></table></figure>

<p>这里提一句，zookeeper的日志是二进制，需要经过处理后才能看</p>
<p>详情请参考这里：<a href="https://www.cnblogs.com/sagech/p/10827174.html">zookeeper 事务日志查看 - 浪荡小新 - 博客园 (cnblogs.com)</a></p>
<h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/usr/<span class="built_in">local</span>/services/zookeeper/apache-zookeeper-3.6.3-bin <span class="comment"># 注意这里的路径要根据实际来填</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ZOOKEEPER_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="comment"># 使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zkServer.sh start   <span class="comment"># 如果打印出一些信息，即表示启动成功</span></span><br><span class="line">zkServer.sh status  <span class="comment"># 查看状态</span></span><br><span class="line">zkServer.sh stop    <span class="comment"># 关闭</span></span><br><span class="line">zkServer.sh restart <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>



<h2 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h2><h5 id="下载并解压"><a href="#下载并解压" class="headerlink" title="下载并解压"></a>下载并解压</h5><p>同样，记得提前进入安装目录；否则就要下载完后再移动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在quick start中点击进入下载页面</span></span><br><span class="line"><span class="comment"># https://kafka.apache.org/quickstart</span></span><br><span class="line">wget https://dlcdn.apache.org/kafka/3.0.0/kafka_2.13-3.0.0.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压，笨办法，移动压缩包，然后再原地解压</span></span><br><span class="line">tar -zxvf kafka_2.13-3.0.0.tgz</span><br></pre></td></tr></table></figure>

<h5 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kafka根目录下/config/server.properties文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改broker.id为正数</span></span><br><span class="line">broker.id=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置消息文件的路径（数据与日志分离）</span></span><br><span class="line">log.dir=/usr/<span class="built_in">local</span>/services/kafka/data</span><br></pre></td></tr></table></figure>

<h5 id="集群搭建（可选）"><a href="#集群搭建（可选）" class="headerlink" title="集群搭建（可选）"></a>集群搭建（可选）</h5><p>尝试在单台虚拟机上搭建3个kafka broker。</p>
<blockquote title="结束啦" style="padding:12px;border-left-color:#98bf21;background-color:rgb(249, 248, 250);">
 <p style="font-weight: bold;">提示</p>
 <p>到这里，kafka安装及环境搭建就告一段落啦~ </p>
 <p>接下来开始正式使用「kafka」</p>
</blockquote>




<h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><h2 id="启动与关闭"><a href="#启动与关闭" class="headerlink" title="启动与关闭"></a>启动与关闭</h2><h5 id="启动Kafka"><a href="#启动Kafka" class="headerlink" title="启动Kafka"></a>启动Kafka</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先启动zookeeper</span></span><br><span class="line">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再启动kafka</span></span><br><span class="line">bin/kafka-server-start.sh  config/server.properties</span><br></pre></td></tr></table></figure>

<h5 id="关闭kafka-broker、producer、consumer"><a href="#关闭kafka-broker、producer、consumer" class="headerlink" title="关闭kafka broker、producer、consumer"></a>关闭kafka broker、producer、consumer</h5><p><code>Ctrl + C</code>或者输入<code>bin/kafka-server-stop.sh</code></p>
<h5 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># run this script to auto start the kafka broker and zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/service/kafka</span><br><span class="line"></span><br><span class="line">bash bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br><span class="line"></span><br><span class="line">bash bin/kafka-server-start.sh  config/server.properties</span><br></pre></td></tr></table></figure>



<h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><p>topic相当于文件系统中的文件夹，events就相当于一个个要放入文件夹中的文件。</p>
<h5 id="创建名为quickstart的topic"><a href="#创建名为quickstart的topic" class="headerlink" title="创建名为quickstart的topic"></a>创建名为quickstart的topic</h5><ul>
<li><code>topic</code>：指定topic名称</li>
<li><code>replication-factor</code>：备份数</li>
<li><code>partitions</code>：分区数</li>
<li><code>bootstrap-server</code>：2.2版本后推荐用它来代替zookeeper</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --topic quickstart --replication-factor 1 --partitions 1 --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<h5 id="列出所有topic"><a href="#列出所有topic" class="headerlink" title="列出所有topic"></a>列出所有topic</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<h5 id="查看某个topic信息"><a href="#查看某个topic信息" class="headerlink" title="查看某个topic信息"></a>查看某个topic信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --topic quickstart --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<h5 id="删除某个topic"><a href="#删除某个topic" class="headerlink" title="删除某个topic"></a>删除某个topic</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-topic.sh --delete --topic quickstart --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>



<h2 id="生产与消费"><a href="#生产与消费" class="headerlink" title="生产与消费"></a>生产与消费</h2><h5 id="启动生产者"><a href="#启动生产者" class="headerlink" title="启动生产者"></a>启动生产者</h5><p>启动完毕后，在控制台输入的内容将会写入到<code>topic</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --topic quickstart --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<h5 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --topic quickstart --from-beginning --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka特性</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/Kafka%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="EOS"><a href="#EOS" class="headerlink" title="EOS"></a>EOS</h3><p><strong>EOS（exactly once semantics）：精确一次处理语义</strong></p>
<p>Kafka的EOS体现在三个方面：</p>
<ol>
<li>幂等：保证消息发到一个分区只会发一次，分区不会有重复消息。</li>
<li>事务：保证原子性的写入到多个分区，要么全部写入成功，要么全部失败</li>
<li>流式EOS</li>
</ol>
<p><strong>幂等的实现</strong></p>
<p>引入producer id（pid），每个batch消息包含了pid以及起始和结束的序列号（从0开始递增）</p>
<p>broker接收消息时，判断是否是同一个生产者发送过的相同消息，就可以实现去重。</p>
<p>具体的判断逻辑是和上次的batch信息相比，如果pid、初始和结束序列号都相等，则判断为重复。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
  </entry>
  <entry>
    <title>docker使用</title>
    <url>/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/docker/docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在传统项目中，开发和运维的对接往往会出现环境不一致的问题，即使能够统一环境，也需要进行很多配置，非常麻烦。</p>
<p>所以人们就提出一种方式，即</p>
<blockquote>
<p>把开发时的环境抽离并保存下来，当其他地方需要运行项目时，直接拉取这个环境，就省去了麻烦的配置过程。</p>
</blockquote>
<p>这也就是docker的思想。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote>
<p> docker采用容器的思想，把镜像配置在容器中，当其他人需要运行项目时，只需要从docker仓库中拉去相应的镜像，即可解决环境冲突问题。</p>
</blockquote>
<blockquote>
<p>轻巧，和VM相比，他只需要几兆空间，因为只用到了核心命令等</p>
</blockquote>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><blockquote>
<p>官网：<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
</blockquote>
<h3 id="1-检查环境"><a href="#1-检查环境" class="headerlink" title="1.检查环境"></a>1.检查环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uname -r              <span class="comment"># 查看内核版本，需要3.1及以上</span></span><br><span class="line">cat /etc/os-release   <span class="comment"># 查看CentOS版本，需要7以上</span></span><br></pre></td></tr></table></figure>

<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.install </span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.set repository  not sure</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.update index</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.install docker-ce</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.start docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># sure</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>

<h2 id="三、docker组件介绍"><a href="#三、docker组件介绍" class="headerlink" title="三、docker组件介绍"></a>三、docker组件介绍</h2><p><strong>docker的核心三大组件为：镜像、容器和仓库</strong></p>
<p>三者的关系如下所示：</p>
<img data-src="https://gitee.com/aurora1004/pictures/raw/master/docker_component.png" alt="docker_component" style="zoom: 67%;" />

<p>在谈这些之前，我们先要了解下Linux相关的一些基础知识。</p>
<p>Linux操作系统分为两部分，<strong>内核与用户空间</strong>。Linux真正<strong>核心</strong>部分在于内核，而<strong>用户空间</strong>只是各大厂商在内核基础上添加自己的软件与工具集形成的发布版本。</p>
<p><strong>镜像</strong></p>
<blockquote>
<p>docker镜像实际上是由一层一层的系统文件组成，这种层级的文件系统被称为UnionFS( Union file system  统一文件系统)，镜像可以基于dockerfile构建，dockerfile是一个描述文件，里面包含了若干条密令，每条命令都会对基础文件系统创建新的层次结构。</p>
</blockquote>
<p><strong>镜像仓库</strong></p>
<p>镜像仓库顾名思义便是用来存放镜像的，docker提供了一个注册服务器（register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像，docker运作中使用的默认仓库是docker hub公共仓库。</p>
<p><strong>容器</strong></p>
<p>docker容器是由docker镜像创建的运行实例。</p>
<p>docker容器类似虚拟机，可以执行包含启动，停止，删除等。每个容器间是相互隔离的。</p>
<p>容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件，因此可以看作是一个简易版的Linux环境（包含root用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序。</p>
<h2 id="四、常用命令"><a href="#四、常用命令" class="headerlink" title="四、常用命令"></a>四、常用命令</h2><h3 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1.帮助命令"></a>1.帮助命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info    <span class="comment"># 显示系统信息，包括容器和镜像</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h3 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2.镜像命令"></a>2.镜像命令</h3><h5 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地主机上的所有镜像</span></span><br><span class="line">docker images  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">	- a <span class="comment"># all</span></span><br><span class="line">	- q <span class="comment"># 只显示镜像id</span></span><br></pre></td></tr></table></figure>

<h5 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在docker hub中搜索镜像</span></span><br><span class="line">docker search mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">	--filter	<span class="comment"># 搜索过滤 如 --filter=STARS=3000</span></span><br></pre></td></tr></table></figure>

<h5 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line"><span class="comment"># 拉取结果分析，待补充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定版本，注意，版本必须是存在的</span></span><br><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全部删除</span></span><br><span class="line">docker rmi -f $(docker images -aq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定id或名称</span></span><br><span class="line">docker rmi -f id或name</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3.容器命令"></a>3.容器命令</h3><p>首先，需要一个镜像才能运行容器。</p>
<h5 id="拉取cent-OS镜像"><a href="#拉取cent-OS镜像" class="headerlink" title="拉取cent OS镜像"></a>拉取cent OS镜像</h5><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker pull centOS</span></span><br></pre></td></tr></table></figure>

<h5 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"> --name=<span class="string">&quot;Name&quot;</span> 用来区分容器</span><br><span class="line"> -d 后台运行</span><br><span class="line"> -it 启动并进入容器</span><br><span class="line"> -p 绑定端口，有多种方式</span><br><span class="line"> 	-p ip:主机端口:容器端口</span><br><span class="line"> 	-p 主机端口:容器端口(最常用)</span><br><span class="line"> 	-p 容器端口</span><br><span class="line"> 	容器端口</span><br><span class="line"> -P 随机指定端口 </span><br></pre></td></tr></table></figure>

<h5 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 查看正在运行和历史运行的容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 只显示id</span></span><br><span class="line">docker ps -q</span><br></pre></td></tr></table></figure>

<h5 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果在创建容器时加上了 -it，就会直接进入到容器中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.退出，但是容器也会停止</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.退出，容器不停止</span></span><br><span class="line">ctrl + p + q</span><br></pre></td></tr></table></figure>

<h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"></span><br><span class="line">docker ps -aq | xargs docker rm</span><br></pre></td></tr></table></figure>

<h5 id="启动和停止容器"><a href="#启动和停止容器" class="headerlink" title="启动和停止容器"></a>启动和停止容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start   <span class="comment"># 启动</span></span><br><span class="line">docker stop    <span class="comment"># 停止</span></span><br><span class="line">docker <span class="built_in">kill</span>    <span class="comment"># 强制停止</span></span><br><span class="line">docker restart <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>

<h3 id="4-其他命令"><a href="#4-其他命令" class="headerlink" title="4.其他命令"></a>4.其他命令</h3><h5 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d 镜像名</span><br><span class="line"><span class="comment"># 发现容器停止了</span></span><br><span class="line"><span class="comment"># 因为docker必须要有一个前台进程运行着才行</span></span><br></pre></td></tr></table></figure>

<h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看指定id的10条日志</span></span><br><span class="line">docker logs -tf --tail 10 容器id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure>

<h5 id="查看镜像元数据"><a href="#查看镜像元数据" class="headerlink" title="查看镜像元数据"></a>查看镜像元数据</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>虚拟机相关</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>问题总结</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1-前端页面展示的日期为空"><a href="#1-前端页面展示的日期为空" class="headerlink" title="1.前端页面展示的日期为空"></a>1.前端页面展示的日期为空</h3><p>前端收到日期数据为空 <code>-&gt;</code> 后端读数据库得到日期为空 <code>-&gt;</code> 数据库中数据正常</p>
<p>最后定位问题出在实体类这儿：</p>
<blockquote>
<p>我用<code>@TableField</code>注解来指定实体类属性与表字段的映射关系，即属性update_time对应表中字段gmt_modified。</p>
<p>但是mybatis-plus默认会把实体类的属性转化成驼峰形式的<code>updateTime</code>，导致原先的映射对不上了，因此查询为空。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE, value = &quot;gmt_modified&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date updated_time;</span><br></pre></td></tr></table></figure>

<p><strong>解决方式（二选一!!!）</strong></p>
<p>①把属性修改成驼峰形式的（讲道理就该写成驼峰式的，当时脑子抽了…）</p>
<p><code>private Date updatedTime;</code></p>
<p>②或者关闭自动转驼峰</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># application.yml文件</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h3 id="2-枚举类型为空"><a href="#2-枚举类型为空" class="headerlink" title="2.枚举类型为空"></a>2.枚举类型为空</h3><p>同上问，数据库（int）中读出来的数据经mybatis plus转化为枚举后，变为空。</p>
<p>最后的做法是把表的字段类型由int改为tinyint(4)。</p>
]]></content>
      <categories>
        <category>谷粒学苑</category>
      </categories>
  </entry>
  <entry>
    <title>项目模块</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="父工程介绍"><a href="#父工程介绍" class="headerlink" title="父工程介绍"></a>父工程介绍</h3><p>父工程的主要特点是：</p>
<ol>
<li>父工程使用<code>Spring Intializr</code>创建为SpringBoot项目，</li>
<li>使用<code>properties</code>和<code>dependencyManagement</code>进行总的依赖和版本管理。</li>
</ol>
<p>这样做的好处是可以让所有子模块都使用父工程的依赖和版本，从而<strong>确保各个子模块的依赖和版本保持一致</strong>。</p>
<p>如果某个子模块需要使用不同于父工程的版本，只需要在自己的模块中声明版本即可，这样就不会继承父工程的版本。</p>
<h3 id="讲师管理模块"><a href="#讲师管理模块" class="headerlink" title="讲师管理模块"></a>讲师管理模块</h3>]]></content>
      <categories>
        <category>谷粒学苑</category>
      </categories>
  </entry>
  <entry>
    <title>项目介绍</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p><code>在线教育</code>：以网络为媒介的教学方式</p>
<p>谷粒学苑是一个在线教育平台，为学员和教师提供了一个学习与授课的平台。它借助互联网打破了时间与空间的限制，使得工作繁忙或是学习时间不固定的群体都能借此来充能。</p>
<h2 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h2><p>项目用户分为两类，管理员和普通用户。</p>
<p><strong>对于管理员来说，模块有：</strong></p>
<ol>
<li>讲师管理</li>
<li>课程分类管理</li>
<li>课程管理</li>
<li>统计分析</li>
<li>订单管理</li>
<li>banner</li>
<li>权限管理</li>
</ol>
<p><strong>对于普通用户来说，模块有：</strong></p>
<ol>
<li>首页数据展示</li>
<li>讲师列表和详情</li>
<li>课程列表和详情<ul>
<li>视频播放</li>
</ul>
</li>
<li>登录和注册</li>
<li><code>微信扫码登录</code></li>
<li><code>微信扫码支付</code></li>
</ol>
<h2 id="项目使用技术"><a href="#项目使用技术" class="headerlink" title="项目使用技术"></a>项目使用技术</h2><p><strong>后端</strong></p>
<ul>
<li>springboot</li>
<li>springcloud</li>
<li>mybatisplus</li>
<li>springsecurity</li>
</ul>
<p><strong>前端</strong></p>
<ul>
<li>vue+element-ui+axios+nodejs</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>阿里云oss</li>
<li>阿里云视频点播服务</li>
<li>阿里云短信服务</li>
<li>微信支付</li>
<li>docker</li>
</ul>
]]></content>
      <categories>
        <category>谷粒学苑</category>
      </categories>
  </entry>
  <entry>
    <title>Vue指令学习</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/Vue/%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h3><blockquote>
<p>代码部分只展示了关键部分</p>
</blockquote>
<h5 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h5><p>通过参数来设置标签内的值</p>
<p>注意，会覆盖标签内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&#39;demo&#39; v-text&#x3D;&#39;para&#39;&gt;被覆盖啦呀，真惨&lt;&#x2F;div&gt; </span><br></pre></td></tr></table></figure>

<h5 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h5><p>和 <code>v-text</code> 类似，区别在于 <code>v-html</code> 能解析成HTML，进行赋值</p>
<h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>绑定方法，<strong>简写形式如下</strong></p>
<p>另外，绑定方法可以具体化，如@keyup.enter表示键盘键入回车键后，调用某方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input id&#x3D;&#39;demo&#39; @click&#x3D;&#39;method&#39; type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot;&gt;&lt;&#x2F;input&gt; </span><br></pre></td></tr></table></figure>

<h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p>用来改变元素的属性值，来使它隐藏或出现</p>
<p>注意，是通过修改属性的方式实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&#39;demo2&#39;&gt;</span><br><span class="line">       &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点击改变&quot; @click&#x3D;&#39;click_it&#39;&gt; </span><br><span class="line">       &lt;p v-show&#x3D;&quot;flag&quot;&gt;嘿嘿，会员内容哦&lt;&#x2F;p&gt;   </span><br><span class="line">   &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><h5 id="v-bind-单向绑定"><a href="#v-bind-单向绑定" class="headerlink" title="v-bind(单向绑定)"></a>v-bind(单向绑定)</h5><p>设置元素的内部属性，如src、<strong>class</strong></p>
<p><strong>简写形式如下</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&#39;demo&#39; &gt;</span><br><span class="line">        &lt;img v-bind:src&#x3D;&quot;para&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 下面的改变class属性比较重要 --&gt;</span><br><span class="line">&lt;div id&#x3D;&#39;demo&#39; &gt;</span><br><span class="line">        &lt;img :class&#x3D;&quot;&#123;clazz_type:isNeedToChange&#125;&quot;  v-bind:src&#x3D;&quot;para&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- 一些参数 --&gt;</span><br><span class="line">isNeedToChange: true</span><br><span class="line">.clazz_type &#123; border: 1px solid red; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="v-model-双向绑定"><a href="#v-model-双向绑定" class="headerlink" title="v-model(双向绑定)"></a>v-model(双向绑定)</h5><p>页面上的值发生变化时（比如用户输入内容），被绑定的变量也会变化。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><p>同样也是用来决定元素的隐藏与出现</p>
<p>但是它是通过修改DOM树的方式实现的</p>
<h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>遍历数组中的值，并利用一个模板显示出来</p>
<p>如下，<strong>li <strong>标签就是所谓的模板，在模板中添加</strong>遍历项student</strong>的名字和年龄</p>
<p>所以就会输出数组中所有学生的名字和年龄</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&#39;demo&#39; &gt;</span><br><span class="line">       &lt;ul&gt;</span><br><span class="line">           &lt;li v-for&#x3D;&quot;(student, index) in students&quot;&gt;</span><br><span class="line">               第&#123;&#123; index + 1 &#125;&#125;位同学叫&#123;&#123;student.name&#125;&#125;，年龄&#123;&#123;student.age&#125;&#125;</span><br><span class="line">           &lt;&#x2F;li&gt;</span><br><span class="line">       &lt;&#x2F;ul&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>全局异常处理</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/SpringBoot/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p><strong>如何自定义异常？</strong></p>
<p>例如定义一个业务异常类，继承<code>RuntimeException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>如何用到这个异常？</strong></p>
<p>例如在controller的方法中抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">deleteTeacher</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(id)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BizException(ResultEnum.PARAM_ERROR.getCode(), <span class="string">&quot;id为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>如何使用全局异常处理？</strong></p>
<p>即业务中抛出异常后，如何处理。只要实现一个由<code>@ControllerAdvice</code>修饰的处理类即可。</p>
<p>然后在handler中实现具体异常的处理方法，例如打印或写入日志，然后返回相应的响应码和信息给前端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(value = BizException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">bizExceptionHandler</span><span class="params">(BizException e)</span> </span>&#123;</span><br><span class="line">        log.error(E.getMessage(e));</span><br><span class="line">        <span class="keyword">return</span> R.error(e.getCode(), e.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>swagger</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/SpringBoot/swagger/</url>
    <content><![CDATA[<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>前后端分离开发模式中，api文档是最好的沟通方式。</p>
<p>Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务。</p>
<ul>
<li><p>及时性：接口变更后，能够及时准确地通知相关前后端开发人员</p>
</li>
<li><p>规范性：保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息</p>
</li>
<li><p>一致性：接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧</p>
</li>
<li><p>可测性：直接在接口文档上进行测试，以方便理解业务</p>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用的结构大致是：</p>
<p>父工程管理swagger依赖和版本，common模块进行swagger配置，其他模块引入common来使用swagger。</p>
<h5 id="配置common模块"><a href="#配置common模块" class="headerlink" title="配置common模块"></a>配置common模块</h5><p><strong>1.父工程使用dependencyManagement</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swagger.version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">swagger.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;swagger.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--swagger ui--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;swagger.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.common模块中添加swagger和swagger ui依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided <span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided <span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.在common模块中进行配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/admin/.*&quot;</span>)))</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/error.*&quot;</span>)))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;网站-课程中心API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了课程中心微服务接口的定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;Aurora&quot;</span>, <span class="string">&quot;http://www.baidu.com&quot;</span>, <span class="string">&quot;1635951075@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="其他模块使用swagger"><a href="#其他模块使用swagger" class="headerlink" title="其他模块使用swagger"></a>其他模块使用swagger</h5><p><strong>1.引入common模块</strong></p>
<p>忽略名字的不同。。。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入common模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ze.aurora<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>service-base<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.在应用的模块启动类上添加组件扫描，以此来扫描到common中的配置类</strong></p>
<p>common模块的包名为<code>com.aurora.baseservice</code></p>
<p>应用模块的包名为<code>com.aurora.eduservice</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.aurora&quot;&#125;)</span> <span class="comment">// 最好所有模块的包名具有公共前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EduApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p><strong>3.在controler中使用swagger</strong></p>
<p>关于<code>Api</code>、<code>ApiOperation</code>、<code>ApiParam</code>所对应的内容，可以对照着下面swagger-ui的图看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &#123;&quot;讲师管理&quot;&#125;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/eduservice/teacher&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EduTeacherController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EduTeacherService teacherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;查询所有讲师&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;EduTeacher&gt; <span class="title">selectAllTeachers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> teacherService.list(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;根据id删除指定讲师&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteTeacher</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true)</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isDeleted = teacherService.removeById(id);</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;delete teacher with id %s %s\n&quot;</span>, id, isDeleted ? <span class="string">&quot;successfully&quot;</span> : <span class="string">&quot;unsuccessfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.进入swagger路由进行查看</strong></p>
<p>示例路径为<code>http://localhost:8081/swagger-ui.html#/</code></p>
<p>在swagger-ui中我们可以看到各个接口的说明，同时也可以点击<code>try it out</code>对其进行测试，查看接口的返回结果等等。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111232201431.png" alt="image-20211123220134346"></p>
]]></content>
      <categories>
        <category>swagger</category>
      </categories>
  </entry>
  <entry>
    <title>核心功能——配置文件</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/SpringBoot/4_yaml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="YAML配置文件"><a href="#YAML配置文件" class="headerlink" title="YAML配置文件"></a>YAML配置文件</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>yaml是一种比<code>xml</code>更便捷的文件格式</p>
<p>主要表现在格式整齐、书写方便、占用内容少</p>
</blockquote>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>采用键值对的形式，key: value</p>
<ul>
<li>一般形式<ul>
<li><code>key: value</code></li>
</ul>
</li>
<li>数组、队列、集合<ul>
<li><code>key: [v1,v2,v3]</code></li>
</ul>
</li>
<li>Map、对象<ul>
<li><code>key: &#123;k1:v1,k2:v2,k3:v3&#125;</code></li>
</ul>
</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> String[] interests;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; animal;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; score;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Double&gt; salarys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Pet&gt;&gt; allPets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">	<span class="attr">userName:</span> <span class="string">whz</span></span><br><span class="line">	<span class="attr">boss:</span> <span class="string">whz</span></span><br><span class="line">	<span class="attr">birth:</span> <span class="number">1999</span><span class="string">/10/04</span></span><br><span class="line">	<span class="attr">age:</span> <span class="number">21</span></span><br><span class="line">	<span class="attr">pet:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">cc</span></span><br><span class="line">		<span class="attr">weight:</span> <span class="number">20</span></span><br><span class="line">	<span class="attr">interests:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">eat</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">drink</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">play</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">happy</span></span><br><span class="line">	<span class="attr">animal:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">a</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">b</span></span><br><span class="line">	<span class="attr">score:</span></span><br><span class="line">		</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>入门——开发小技巧</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/SpringBoot/3_%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="一、lombok"><a href="#一、lombok" class="headerlink" title="一、lombok"></a>一、lombok</h2><p>该插件可以让我们不用再写<code>setter</code>和<code>getter</code>等方法</p>
<p>只需要添加注解就可以在编译时生成对应代码</p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="IDEA安装lombok插件"><a href="#IDEA安装lombok插件" class="headerlink" title="IDEA安装lombok插件"></a>IDEA安装lombok插件</h3><p>在market中搜索插件并安装</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>@Data<ul>
<li>setter和getter</li>
</ul>
</li>
<li>@NoArgsConstructor<ul>
<li>无参构造器</li>
</ul>
</li>
<li>@AllArgsConstructor<ul>
<li>全参构造器</li>
</ul>
</li>
<li>@ToString<ul>
<li>toString()</li>
</ul>
</li>
<li>@EqualsAndHashCode<ul>
<li>equals()和hashCode()</li>
</ul>
</li>
<li>@Slf4j<ul>
<li>日志</li>
<li>在注解的类中，可直接用<code>log.info()</code>等方法输出日志</li>
</ul>
</li>
</ul>
<h2 id="dev-tools"><a href="#dev-tools" class="headerlink" title="dev-tools"></a>dev-tools</h2><p>热部署工具，这是重新启动</p>
<h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用快捷键ctrl-F9来刷新"><a href="#使用快捷键ctrl-F9来刷新" class="headerlink" title="使用快捷键ctrl + F9来刷新"></a>使用快捷键<code>ctrl + F9</code>来刷新</h3><h2 id="Spring-Initializr"><a href="#Spring-Initializr" class="headerlink" title="Spring Initializr"></a>Spring Initializr</h2><p>快速创建SpringBoot项目</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>入门——自动装配</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/SpringBoot/2_%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%8E%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一、依赖管理"><a href="#一、依赖管理" class="headerlink" title="一、依赖管理"></a>一、依赖管理</h1><h2 id="关于父工程的依赖"><a href="#关于父工程的依赖" class="headerlink" title="关于父工程的依赖"></a>关于父工程的依赖</h2><p>当我们创建了Spring Boot项目后，我们会发现<code>pom.xml</code>文件中，默认有个父工程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>进入之后发现他还有个父工程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后我们来到了名为<strong>spring-boot-dependencies</strong>的工程</p>
<p>发现他里面添加了开发中常用依赖的版本，配置在<strong>properties</strong>标签中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.15.13<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.81<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.16.1<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">atomikos.version</span>&gt;</span>4.0.6<span class="tag">&lt;/<span class="name">atomikos.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">awaitility.version</span>&gt;</span>4.0.3<span class="tag">&lt;/<span class="name">awaitility.version</span>&gt;</span></span><br><span class="line">  &lt;-! ......省略-&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">webjars-locator-core.version</span>&gt;</span>0.45<span class="tag">&lt;/<span class="name">webjars-locator-core.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">wsdl4j.version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">wsdl4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xml-maven-plugin.version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">xml-maven-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xmlunit2.version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">xmlunit2.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>而如果我们想要自己来选择版本的话，就可以在pom.xml中的properties标签中添加对应依赖的版本</strong></p>
<h2 id="starter场景启动器"><a href="#starter场景启动器" class="headerlink" title="starter场景启动器"></a>starter场景启动器</h2><p>关于<code>spring-boot-starter-web</code>的依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>我们进入它（或者是其他starter）的内部，发现所有类似的starter都有这样一段依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这说明了只要引用了<code>spring-boot-starter-xxx</code>，就会自动引入该场景（例子中是web）的所有常规依赖</p>
<h1 id="二、自动配置"><a href="#二、自动配置" class="headerlink" title="二、自动配置"></a>二、自动配置</h1><p><strong>Spring Boot的自动配置如下</strong></p>
<ol>
<li>配置Tomcat</li>
<li>配置SpringMVC</li>
<li>配置Web常用功能，如字符编码等</li>
<li>默认包结构</li>
</ol>
<p><strong>主启动类路径下的文件都会被扫描到</strong></p>
<p><strong>如果想要改变扫描路径，可以通过</strong></p>
<ul>
<li><p>@SpringBootApplication(scanBasePackages=”com.edu.neu”)</p>
</li>
<li><p>或者@ComponentScan(“com.edu.neu”)</p>
</li>
</ul>
<p>特点：按需加载配置项</p>
<h1 id="三、组件注册"><a href="#三、组件注册" class="headerlink" title="三、组件注册"></a>三、组件注册</h1><h2 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h2><p>spring是采用在xml配置文件中写标签的方式来注册组件，<del>但不知为啥没注册成功。。</del>原来还要@ImportResource才行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cola&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.edu.neu.learning.entity.Cola&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-SpringBoot-Configuration"><a href="#2-SpringBoot-Configuration" class="headerlink" title="2.SpringBoot @Configuration"></a>2.SpringBoot @Configuration</h2><p>spring boot可以不用再通过<code>xml</code>文件来注册组件了，而是使用<code>@Configuration</code>注解，来表示这是<strong>配置类</strong></p>
<p>然后在<strong>配置类</strong>中通过<code>@Bean</code>的方式把组件注册到容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cola <span class="title">myCola</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cola();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们进入到@Configuration注解中，可以发现它定义了一个布尔型的变量，默认是true</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>proxyBeanMethods直译过来就是是否要代理组件方法</strong>，那么我们可以理解成</p>
<ul>
<li>true，由容器来代理组件方法</li>
<li>false，容器不进行代理</li>
</ul>
<p><strong>那这有什么用呢？</strong>就写一段代码试试看吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ColaConfig bean = run.getBean(ColaConfig.class); <span class="comment">// 得到配置类的实例对象</span></span><br><span class="line"><span class="comment">// 通过配置类的方法来获取Cola对象</span></span><br><span class="line">      Cola cola1 = bean.myCola();</span><br><span class="line">      Cola cola2 = bean.myCola();</span><br><span class="line"><span class="comment">// 如果是代理，则    cola1 == cola2</span></span><br><span class="line"><span class="comment">// 如果不采用代理，则 cola1 != cola2</span></span><br></pre></td></tr></table></figure>

<p><strong>这说明当配置类采取代理组件方法时，它会先从容器中获得对象。容器没有的话，再调用真正的方法去创建对象并注册到容器中。</strong></p>
<p>之后如果还想要获取对象，就会直接返回容器中存在的对象，不用重复创建。</p>
<p><strong>这样看来代理是不是还挺好的，但是存在一个问题，如果每次都要从容器中寻找对象，就会造成不必要的开销，特别是本来就不用组件依赖的时候，直接创建对象也可以用，就不用再去容器中寻找，所以选择不代理的情况也是存在的</strong></p>
<p><strong>所以基于他们耗时、开销的多少，我们常常把采用代理称为Full模式，不用代理形容成Light（轻量级）模式</strong></p>
<p>总结一下，如下</p>
<ul>
<li>配置类的组件之间无依赖关系，就用轻量级模式加速容器的启动过程，减少判断</li>
<li>配置类的组件之间存在依赖，就要用Full模式，让被调用方法返回之前存在的容器</li>
</ul>
<h2 id="3-Import"><a href="#3-Import" class="headerlink" title="3.@Import"></a>3.@Import</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a><strong>描述</strong></h3><p>用来在容器中注册全类名的组件</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Person.class, DBHelper.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Conditional"><a href="#4-Conditional" class="headerlink" title="4.@Conditional"></a>4.@Conditional</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a><strong>描述</strong></h3><p>表示在条件满足时再注册组件</p>
<p>它有很多子类，例如ConditionalOnBean、ConditionalOnProperty、ConditionalOnMissingBean等</p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a><strong>用法</strong></h3><p>如下，当容器中存在myPerson组件时，myCola组件才会注册到容器中</p>
<p><strong>注意，这两个方法的先后顺序是有影响的！下面这样子的结果是myCola被注册到容器了，如果这俩方法换个顺序，myCola就不会被注册进容器！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">myPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name = &quot;myPerson&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cola <span class="title">myCola</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cola();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，如果@Conditional注解加在类上，那么会决定整个类中的组件是否会被注册进容器。</p>
<h2 id="5-ImportResource"><a href="#5-ImportResource" class="headerlink" title="5.@ImportResource"></a>5.@ImportResource</h2><p>用来注册<code>xml</code>文件中配置的组件</p>
<p>例如，下面的<code>beans.xml</code>是上文提到的，在这里引入后，就能注册在容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColaConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<h2 id="6-ConfigurationProperties"><a href="#6-ConfigurationProperties" class="headerlink" title="6.@ConfigurationProperties"></a>6.@ConfigurationProperties</h2><p>通过<code>application.properties</code>文件来配置组件的一些信息</p>
<p><strong>注意，组件类必须在容器中才能进行属性绑定</strong></p>
<p><strong>所以要么在组件类中添加@Component注册它，要么就用配置类去注册它。</strong></p>
<p><strong>然后在组件类上方添加@ConfigurationProperties，完成属性绑定</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...		</span></span><br></pre></td></tr></table></figure>

<p>在<code>application.properties</code>中设置组件类的属性</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">person.id</span>=<span class="string">123</span></span><br><span class="line"><span class="meta">person.name</span>=<span class="string">whz</span></span><br></pre></td></tr></table></figure>

<h2 id="7-EnableConfigurationProperties"><a href="#7-EnableConfigurationProperties" class="headerlink" title="7.@EnableConfigurationProperties"></a>7.@EnableConfigurationProperties</h2><p>和⑥相比，把该注解用在注册组件的配置类中，组件类就不用再使用@Component注解了</p>
<p><strong>这是防止引用第三方的包时，其组件类没有@Component而产生无法进行属性绑定的问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(Person.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColaConfig</span> </span>&#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="comment">// ... &#125;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h1 id="四、按需进行自动配置"><a href="#四、按需进行自动配置" class="headerlink" title="四、按需进行自动配置"></a>四、按需进行自动配置</h1><p>上面我们提到了许多用来注册组件的注解</p>
<p>那么SpringBoot究竟是怎么把这些东西注册进容器的呢，SpringBoot程序的运行离不开主启动类，这个启动类也许包含了更多的信息。</p>
<p>让我们来研究下主启动类的注解吧。</p>
<p>首先，<code>@SpringBootApplication</code>内部涉及三个注解，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>SpringBootConfiguration<ul>
<li>内部就是Configuration</li>
<li>说明主启动类也注册到容器中</li>
</ul>
</li>
</ul>
<h2 id="Registrar"><a href="#Registrar" class="headerlink" title="Registrar"></a><strong>Registrar</strong></h2><p>类中的注册组件方法如下：</p>
<p>通过<code>metadate</code>得到<code>packageNames</code>，然后对一群组件进行注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a><strong>AutoConfigurationImportSelector</strong></h2><p>可以看到，该类中使用<code>getAutoConfigurationEntry()</code>来返回批量的组件信息</p>
<p>方法内部又调用了<code>getCandidateConfigurations()</code>，而这个方法是通过<code>SpringFactoriesLoader</code>来获得配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.<span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 1.判断SpringBoot的自动装配是否打开</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.读取EnableAutoConfiguration注解中的exclude和excludeName</span></span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">// 3.读取所有需要自动装配的配置类，在META-INF/spring.factories中</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">// 4.删去不满足条件的</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);		                </span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用Spring的工厂加载器来获取配置</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们来到SpringFactoriesLoader类中，可以看到它的核心方法loadSpringFactories()</strong></p>
<p>分析一下该方法</p>
<ol>
<li>判断cache是否是null</li>
<li>如果cache存在，就直接返回，因为配置项已经加载过</li>
<li>如果不存在，就从<code>META-INF/spring.factories</code>文件中<strong>读取并加载所有的配置</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryTypeName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryImplementationName = var9[var11];</span><br><span class="line">                        result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但我们可能会有疑问，如果一次性把所有组件都注册进容器中，会不会多余？并且影响启动的性能</p>
<p>这时候我们就要用到前面提过的<strong>条件注解</strong>了</p>
<p><strong>只要我们在组件类中添加相应的条件配置，如<code>@ConditionalOnClass</code>，这样只有引入某个包时，对应的组件才会真正被注册到容器中。</strong></p>
<h2 id="定制化配置"><a href="#定制化配置" class="headerlink" title="定制化配置"></a>定制化配置</h2><p>如果我们对SpringBoot的默认配置不满意呢，该怎样做到修改它的默认配置</p>
<p>以下提供了两种方法</p>
<ol>
<li>注册自己的Bean，取代默认组件</li>
<li>通过配置文件<code>application.properties</code>来设置</li>
</ol>
<h2 id="定制化配置的实现方式"><a href="#定制化配置的实现方式" class="headerlink" title="定制化配置的实现方式"></a>定制化配置的实现方式</h2><p>我们查看Spring Boot默认加载的组件，会发现以下注解</p>
<p>就以<code>HttpEncodingAutoConfiguration</code>为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span></span><br></pre></td></tr></table></figure>

<p>这个注解我们之前了解过</p>
<p>即：该组件把<code>ServerProperties</code>类注册到容器中，同时读取<code>application.properties</code>中对应的属性来赋值。</p>
<p>所以我们只要直接修改配置文件，就能够使用自己的配置</p>
<h2 id="查看自动配置"><a href="#查看自动配置" class="headerlink" title="查看自动配置"></a>查看自动配置</h2><p>在<code>application.properties</code>中设置<code>debug=true</code>来开启调试</p>
<p>这样运行项目后会打印出配置项(<code>positive matches </code>或<code>negative matches</code>)</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>入门——HelloWorld</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/SpringBoot/1_HelloWorld/</url>
    <content><![CDATA[<h3 id="编写Hello-World"><a href="#编写Hello-World" class="headerlink" title="编写Hello World"></a>编写Hello World</h3><ol>
<li>创建Spring Boot项目</li>
<li>编写启动类和Controller</li>
<li>启动项目，访问<code>localhost:8080/hello</code>页面</li>
</ol>
<p>即可看到Hello World</p>
<h3 id="尝试打包"><a href="#尝试打包" class="headerlink" title="尝试打包"></a>尝试打包</h3><ol>
<li><p>在右侧maven栏中依次选择<code>clean</code>和<code>package</code></p>
</li>
<li><p>然后可以在<code>target</code>目录下中看到<code>jar</code>包</p>
</li>
<li><p>在该路径下打开cmd（文件路径栏直接输入cmd即可），输入<code>java -jar xxx.jar</code></p>
</li>
</ol>
<p>即运行成功</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>IOC</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/Spring/IOC/</url>
    <content><![CDATA[<h2 id="一、IOC—问题总览"><a href="#一、IOC—问题总览" class="headerlink" title="一、IOC—问题总览"></a>一、IOC—问题总览</h2><p>什么是IOC?</p>
<p>IOC的用法是怎样的？</p>
<p>为什么要有IOC？</p>
<p>IOC是怎样实现的？</p>
<h2 id="二、IOC—解答"><a href="#二、IOC—解答" class="headerlink" title="二、IOC—解答"></a>二、IOC—解答</h2><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC?"></a>什么是IOC?</h3><p>IOC：inverse of control，即控制反转，把创建对象和管理对象的工作交给Spring框架来做</p>
<h3 id="为什么要有IOC？"><a href="#为什么要有IOC？" class="headerlink" title="为什么要有IOC？"></a>为什么要有IOC？</h3><p>由框架来管理对象，实行解耦</p>
<h3 id="IOC的实现"><a href="#IOC的实现" class="headerlink" title="IOC的实现"></a>IOC的实现</h3><p><strong>过程可以分为两步</strong></p>
<p>Bean定义：通过注解或者xml配置文件的方式，定义Bean所在的路径</p>
<p>Bean的初始化：IOC容器创建Bean对象，完成初始化。</p>
<p><strong>实现</strong></p>
<ol>
<li>通过注解或xml拿到类的全限定名</li>
<li>利用反射获取类的对象</li>
<li>将对象实例传递出去</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/swagger/</url>
    <content><![CDATA[<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>前后端分离开发模式中，api文档是最好的沟通方式。</p>
<p>Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务。</p>
<ul>
<li><p>及时性：接口变更后，能够及时准确地通知相关前后端开发人员</p>
</li>
<li><p>规范性：保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息</p>
</li>
<li><p>一致性：接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧</p>
</li>
<li><p>可测性：直接在接口文档上进行测试，以方便理解业务</p>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用的结构大致是：</p>
<p>父工程管理swagger依赖和版本，common模块进行swagger配置，其他模块引入common来使用swagger。</p>
<h5 id="配置common模块"><a href="#配置common模块" class="headerlink" title="配置common模块"></a>配置common模块</h5><p><strong>1.父工程使用dependencyManagement</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swagger.version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">swagger.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;swagger.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--swagger ui--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;swagger.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.common模块中添加swagger和swagger ui依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided <span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided <span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.在common模块中进行配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/admin/.*&quot;</span>)))</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/error.*&quot;</span>)))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;网站-课程中心API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了课程中心微服务接口的定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;Aurora&quot;</span>, <span class="string">&quot;http://www.baidu.com&quot;</span>, <span class="string">&quot;1635951075@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="其他模块使用swagger"><a href="#其他模块使用swagger" class="headerlink" title="其他模块使用swagger"></a>其他模块使用swagger</h5><p><strong>1.引入common模块</strong></p>
<p>忽略名字的不同。。。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入common模块--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ze.aurora<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>service-base<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.在应用的模块启动类上添加组件扫描，以此来扫描到common中的配置类</strong></p>
<p>common模块的包名为<code>com.aurora.baseservice</code></p>
<p>应用模块的包名为<code>com.aurora.eduservice</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.aurora&quot;&#125;)</span> <span class="comment">// 最好所有模块的包名具有公共前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EduApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p><strong>3.在controler中使用swagger</strong></p>
<p>关于<code>Api</code>、<code>ApiOperation</code>、<code>ApiParam</code>所对应的内容，可以对照着下面swagger-ui的图看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &#123;&quot;讲师管理&quot;&#125;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/eduservice/teacher&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EduTeacherController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EduTeacherService teacherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;查询所有讲师&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;EduTeacher&gt; <span class="title">selectAllTeachers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> teacherService.list(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;根据id删除指定讲师&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteTeacher</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@ApiParam(name = &quot;id&quot;, value = &quot;讲师ID&quot;, required = true)</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isDeleted = teacherService.removeById(id);</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;delete teacher with id %s %s\n&quot;</span>, id, isDeleted ? <span class="string">&quot;successfully&quot;</span> : <span class="string">&quot;unsuccessfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.进入swagger路由进行查看</strong></p>
<p>示例路径为<code>http://localhost:8081/swagger-ui.html#/</code></p>
<p>在swagger-ui中我们可以看到各个接口的说明，同时也可以点击<code>try it out</code>对其进行测试，查看接口的返回结果等等。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111232201431.png" alt="image-20211123220134346"></p>
]]></content>
  </entry>
  <entry>
    <title>MyBatis-Plus</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/MyBatis-Plus/</url>
    <content><![CDATA[<blockquote>
<p>其实官方的教程很详细，一切以<a href="https://mp.baomidou.com/">官网</a>为准。</p>
</blockquote>
<h2 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h2><h5 id="引入Maven依赖"><a href="#引入Maven依赖" class="headerlink" title="引入Maven依赖"></a>引入Maven依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--            mybatis-plus--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        mysql--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="添加数据源配置"><a href="#添加数据源配置" class="headerlink" title="添加数据源配置"></a>添加数据源配置</h5><p>Spring Boot 2.1集成了jdbc8.0驱动，需要注意两点：</p>
<ol>
<li>不再推荐使用<code>com.mysql.jdbc.Driver</code></li>
<li>url路径后要加上时区信息<code>?serverTimezone=GMT%2B8</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/awesome?serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">88775682whz</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="comment"># 输出日志</span></span><br></pre></td></tr></table></figure>

<h5 id="修改启动类"><a href="#修改启动类" class="headerlink" title="修改启动类"></a>修改启动类</h5><p>在启动类上添加包扫描的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.ze.aurora.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LearningApplication</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** ... **/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定义Mapper"><a href="#定义Mapper" class="headerlink" title="定义Mapper"></a>定义Mapper</h5><p>定义mapper接口，继承<code>BaseMapper</code>并实现泛型</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">UserMapper</span> <span class="symbol">extends</span> <span class="symbol">BaseMapper</span>&lt;<span class="symbol">User</span>&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h5 id="id生成策略"><a href="#id生成策略" class="headerlink" title="id生成策略"></a>id生成策略</h5><p>在id的属性上添加<code>@TableId(type = IdType.xxx)</code>注解来设置具体策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.NONE)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> id;</span><br></pre></td></tr></table></figure>



<h5 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h5><p><strong>1.添加注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span> <span class="comment">// 新增或修改时自动填充</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br></pre></td></tr></table></figure>

<p><strong>2.实现自定义的handler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strictUpdateFill(metaObject, <span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p><strong>原理：</strong>通过设置一个version字段，取出记录时获取version。准备更新时，带上version去更新，通过判断version是否一样，再决定更新成功与否。</p>
<p><strong>1.数据库添加version字段，并设置默认值为0</strong></p>
<p><code>version</code>必须设置一个默认值，不能为null，否则会发生错误。</p>
<p>设置默认值的方式有两种，一种是直接在数据库里修改，另一种则是利用上面提到的<code>自动填充</code>，具体做法不再赘述。</p>
<p><strong>2.添加配置类</strong>（下方是旧版。新旧版本不太一样，详情见官网）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.ze.aurora.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.实体类添加version属性，并使用Version注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 版本号实现乐观锁*/</span></span><br><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> version;</span><br></pre></td></tr></table></figure>



<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><p><strong>1.配置分页插件</strong></p>
<p>在<code>MyBatisPlus</code>配置类（如果没有，则参照上一段代码的做法创建一个）中添加以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.使用Page传参</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectPage</span><span class="params">(<span class="keyword">long</span> pageSize, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(pageSize, offset);</span><br><span class="line">    <span class="comment">// 无条件分页查询</span></span><br><span class="line">    userMapper.selectPage(page, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = page.getRecords();</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h5><p><strong>1.数据库新增deleted字段（注意设置默认值为0）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user add deleted int default 0;</span><br></pre></td></tr></table></figure>

<p><strong>2.实体类添加@TableLogic注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> deleted;</span><br></pre></td></tr></table></figure>

<p><strong>3.自定义逻辑删除与未删除的取值（可选）</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除，默认为0</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑删除，默认为1</span></span><br></pre></td></tr></table></figure>

<p>如果是旧版的MyBatisPlus，还需要注入相应的配置类。</p>
<h5 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h5><p>常见的条件缩写：</p>
<ul>
<li><code>gt</code>：great than</li>
<li><code>lt</code>：less than</li>
<li><code>ne</code>：not equals</li>
<li>…(基本都是英文缩写)</li>
</ul>
<p>基本用法：实现where语句的条件，如<code>select * from user where age &gt; 60</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectOldUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1.定义QueryWrapper</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">    <span class="comment">// 2.添加条件</span></span><br><span class="line">    wrapper.gt(<span class="string">&quot;age&quot;</span>, <span class="number">60</span>);</span><br><span class="line">    <span class="comment">// 3.传入wrapper进行查询</span></span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(wrapper);</span><br><span class="line">    <span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本用法：实现查询指定列，如<code>select name, email ...</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wrapper.select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;email&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>基本用法：多条件查询，如<code>select * from user where deleted = 0 and age &gt; 60 or (age &lt; 20)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wrapper.eq(<span class="string">&quot;deleted&quot;</span>, <span class="number">0</span>)</span><br><span class="line">        .gt(<span class="string">&quot;age&quot;</span>, <span class="number">60</span>)</span><br><span class="line">        .or(i -&gt; i.lt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>));</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>MyBatis-Plus</category>
      </categories>
  </entry>
  <entry>
    <title>项目介绍</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E5%8D%81%E6%AC%A1%E6%96%B9/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h4><h6 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h6><p>本项目旨在搭建一个交流平台，主要目标是爱好写作、分享博客的各位小伙伴们</p>
<p>用户可以在其中浏览文章，发布文章、发表评论等。</p>
<p>当遇到美文时，可以点赞，或关注作者，以及时获取其最新推送</p>
<h6 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h6><p>用户：发布文章，修改文章，删除文章，点赞，发布评论，关注作者</p>
<p>系统：推送消息给用户</p>
<h6 id="3-模块划分"><a href="#3-模块划分" class="headerlink" title="3. 模块划分"></a>3. 模块划分</h6><p>按功能来划分，可以分成以下模块</p>
<ul>
<li>文章模块</li>
</ul>
<p>对文章进行操作，包括发布、修改、删除、点赞等</p>
<ul>
<li>评论模块</li>
</ul>
<p>用户在某一篇文章下发表评论、删除评论</p>
<ul>
<li>用户模块</li>
</ul>
<p>用户登录、注册</p>
<ul>
<li>消息模块</li>
</ul>
<p>消息推送，包括文章被读者点赞，或者是关注的作者发表了新文章</p>
<h6 id="4-架构及技术选型"><a href="#4-架构及技术选型" class="headerlink" title="4. 架构及技术选型"></a>4. 架构及技术选型</h6><ul>
<li><h6 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h6></li>
</ul>
<p>采用前后端分离的开发方式</p>
<ul>
<li>后端架构</li>
</ul>
<p>采用当前主流的基于 Spring Cloud 的微服务架构</p>
<p>用到的技术有：Spring Boot、Spring Cloud、MyBatis Plus、MySQL</p>
<p>用到的组件有：</p>
<table>
<thead>
<tr>
<th align="center">组件</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Eureka</td>
<td align="center">用来注册服务</td>
</tr>
<tr>
<td align="center">Maven</td>
<td align="center">管理依赖</td>
</tr>
<tr>
<td align="center">Feign</td>
<td align="center">服务间调用</td>
</tr>
<tr>
<td align="center">Redis</td>
<td align="center">缓存用户间的订阅和点赞关系</td>
</tr>
<tr>
<td align="center">netty</td>
<td align="center">异步通信，配合消息队列完成消息推送</td>
</tr>
<tr>
<td align="center">RabbitMQ</td>
<td align="center">存放通知消息</td>
</tr>
<tr>
<td align="center">MongoDB</td>
<td align="center">持久化存储评论数据（不太重要的数据）</td>
</tr>
<tr>
<td align="center">docker</td>
<td align="center">部署虚拟化容器</td>
</tr>
</tbody></table>
<h6 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h6><p>模块划分后，又添加了common模块和encrypt模块</p>
<p> <code>common</code> 用来部署一些公共部分，如状态码StatusCode，返回结果Result，分页查询结果PageResult、ID生成器IdWorker</p>
<p> <code>encrypt</code> 用来进行接口加密，前端用公钥对数据进行加密，后端用私钥进行解密</p>
<h4 id="二、难点总结"><a href="#二、难点总结" class="headerlink" title="二、难点总结"></a>二、难点总结</h4><h5 id="1-分页查询"><a href="#1-分页查询" class="headerlink" title="1. 分页查询"></a>1. 分页查询</h5><p>controller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;search/&#123;page&#125;/&#123;size&#125;&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">findByPage</span><span class="params">(<span class="meta">@PathVariable</span> Integer page,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@PathVariable</span> Integer size,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@RequestBody</span> Map&lt;String,Object&gt; map)</span> </span>&#123;      <span class="comment">// json数据转成map而不是对象，方便遍历属性</span></span><br><span class="line">    Page&lt;Article&gt; pageData = articleService.search(map, page, size); <span class="comment">// 调用service层的方法</span></span><br><span class="line">    PageResult&lt;Article&gt; pageResult = <span class="keyword">new</span> PageResult&lt;&gt;(               <span class="comment">// 封装成自己定义的结果类</span></span><br><span class="line">            pageData.getTotal(), pageData.getRecords()</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, StatusCode.OK, <span class="string">&quot;查询成功&quot;</span>, pageResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Article&gt; <span class="title">search</span><span class="params">(Map&lt;String, Object&gt; map, Integer page, Integer size)</span> </span>&#123;</span><br><span class="line">    EntityWrapper&lt;Article&gt; wrapper = <span class="keyword">new</span> EntityWrapper&lt;Article&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String field : map.keySet()) &#123;</span><br><span class="line">        wrapper.eq(<span class="keyword">null</span> != map.get(field), field, map.get(field));<span class="comment">// 不考虑字段值为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    Page&lt;Article&gt; pageData = <span class="keyword">new</span> Page&lt;&gt;(page, size);</span><br><span class="line">    List list = articleDao.selectPage(pageData, wrapper); <span class="comment">// 传入分页参数（Page）、查询条件（EntityWrapper）</span></span><br><span class="line">    pageData.setRecords(list);                            <span class="comment">// 目的是找到和 map 中非空的键值对相匹配的数据</span></span><br><span class="line">    <span class="keyword">return</span> pageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-使用redis"><a href="#2-使用redis" class="headerlink" title="2. 使用redis"></a>2. 使用redis</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String userKey = <span class="string">&quot;article_subscribe_&quot;</span> + userId;  <span class="comment">// 作者集合</span></span><br><span class="line">String authorKey = <span class="string">&quot;article_author_&quot;</span> + authorId; <span class="comment">// 读者集合</span></span><br><span class="line">Boolean flag = redisTemplate.boundSetOps(userKey).isMember(authorId);<span class="comment">// 查询该用户是否已经订阅作者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="comment">// 取消订阅</span></span><br><span class="line">    redisTemplate.boundSetOps(userKey).remove(authorId); <span class="comment">// redis 删除指定集合的某条数据</span></span><br><span class="line">    redisTemplate.boundSetOps(authorKey).remove(userId);</span><br><span class="line">    <span class="comment">// 删除绑定关系</span></span><br><span class="line">    rabbitAdmin.removeBinding(binding);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进行订阅</span></span><br><span class="line">    redisTemplate.boundSetOps(userKey).add(authorId);    <span class="comment">// redis 往指定集合添加一条数据</span></span><br><span class="line">    redisTemplate.boundSetOps(authorKey).add(userId);</span><br><span class="line">    <span class="comment">// 声明队列、添加绑定关系</span></span><br><span class="line">    rabbitAdmin.declareQueue(queue);</span><br><span class="line">    rabbitAdmin.declareBinding(binding);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-rabbitMQ使用"><a href="#3-rabbitMQ使用" class="headerlink" title="3.rabbitMQ使用"></a>3.rabbitMQ使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建管理器</span></span><br><span class="line">RabbitAdmin rabbitAdmin = <span class="keyword">new</span> RabbitAdmin(rabbitTemplate.getConnectionFactory());</span><br><span class="line"><span class="comment">// 声明交换机，路由键为article_subscribe，消息通过交换机来发送</span></span><br><span class="line">DirectExchange exchange = <span class="keyword">new</span> DirectExchange(<span class="string">&quot;article_subscribe&quot;</span>);</span><br><span class="line">rabbitAdmin.declareExchange(exchange);</span><br><span class="line"><span class="comment">// 创建消息队列</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;article_subscribe_&quot;</span> +  userId, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 绑定交换机与队列</span></span><br><span class="line">Binding binding = BindingBuilder.bind(queue).to(exchange).with(authorId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag; <span class="comment">// 获取是否订阅的关系</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="comment">//如果已经订阅，就取消绑定队列与交换机的绑定关系</span></span><br><span class="line">	rabbitAdmin.removeBinding(binding);    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	rabbitAdmin.declareQueue(queue);</span><br><span class="line">    rabbitAdmin.declareBinding(binding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...关注作者发布文章后，生成消息推送</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;article_subscribe&quot;</span>, userId, id);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tensquare</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟机使用</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E5%8D%81%E6%AC%A1%E6%96%B9/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="一、记录"><a href="#一、记录" class="headerlink" title="一、记录"></a>一、记录</h4><p>账号：root</p>
<p>密码：itcast</p>
<h4 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h4><h5 id="1-启动docker"><a href="#1-启动docker" class="headerlink" title="1. 启动docker"></a>1. 启动docker</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<h5 id="2-docker命令"><a href="#2-docker命令" class="headerlink" title="2. docker命令"></a>2. docker命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>查看docker可以使用的命令</p>
<p>例如 <code>docker images </code> 可以查看本地使用的镜像</p>
<h5 id="3-首次创建并启动MySQL容器"><a href="#3-首次创建并启动MySQL容器" class="headerlink" title="3. 首次创建并启动MySQL容器"></a>3. 首次创建并启动MySQL容器</h5><p>创建并启动一个名叫 <code>tensquare_mysql</code> 的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -id --name=tensquare_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7</span><br></pre></td></tr></table></figure>

<h5 id="4-关闭容器"><a href="#4-关闭容器" class="headerlink" title="4. 关闭容器"></a>4. 关闭容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop tensquare_mysql</span><br></pre></td></tr></table></figure>

<h5 id="5-再次启动容器"><a href="#5-再次启动容器" class="headerlink" title="5. 再次启动容器"></a>5. 再次启动容器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start tensquare_mysql</span><br></pre></td></tr></table></figure>

<h5 id="6-连接MongoDB"><a href="#6-连接MongoDB" class="headerlink" title="6. 连接MongoDB"></a>6. 连接MongoDB</h5><ul>
<li><p>win10进入 <code>C:\Program Files\MongoDB\Server\3.2\bin</code> 路径</p>
</li>
<li><p>打开cmd（shift + 鼠标右键打开<strong>Powershell</strong>，然后输入<code>start cmd</code>命令）</p>
</li>
<li><p>然后输入 <code>mongo 192.168.13.128</code> 连接</p>
</li>
</ul>
]]></content>
      <categories>
        <category>tensquare</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E5%8D%81%E6%AC%A1%E6%96%B9/RabbitMQ/</url>
    <content><![CDATA[<h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-添加配置"><a href="#2-添加配置" class="headerlink" title="2. 添加配置"></a>2. 添加配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要添加在spring字段内</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.13</span><span class="number">.128</span> </span><br></pre></td></tr></table></figure>

<h4 id="3-具体使用"><a href="#3-具体使用" class="headerlink" title="3. 具体使用"></a>3. 具体使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建管理器</span></span><br><span class="line">RabbitAdmin rabbitAdmin = <span class="keyword">new</span> RabbitAdmin(rabbitTemplate.getConnectionFactory());</span><br><span class="line"><span class="comment">// 声明交换机</span></span><br><span class="line">DirectExchange exchange = <span class="keyword">new</span> DirectExchange(<span class="string">&quot;article_subscribe&quot;</span>);</span><br><span class="line">rabbitAdmin.declareExchange(exchange);</span><br><span class="line"><span class="comment">// 创建消息队列</span></span><br><span class="line">Queue queue = <span class="keyword">new</span> Queue(<span class="string">&quot;article_subscribe&quot;</span> +  userId, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 绑定交换机与队列</span></span><br><span class="line">Binding binding = BindingBuilder.bind(queue).to(exchange).with(authorId);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tensquare</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatisPlus使用</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E5%8D%81%E6%AC%A1%E6%96%B9/Mybatis%20Plus/</url>
    <content><![CDATA[<h5 id="1-在-pom-xml-中添加依赖"><a href="#1-在-pom-xml-中添加依赖" class="headerlink" title="1. 在 pom.xml 中添加依赖"></a>1. 在 <code>pom.xml</code> 中添加依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatisplus-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatisplus-spring-boot-starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatisplus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-在-application-yml-文件中添加配置"><a href="#2-在-application-yml-文件中添加配置" class="headerlink" title="2. 在 application.yml 文件中添加配置"></a>2. 在 <code>application.yml</code> 文件中添加配置</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">typeAliasesPackage:</span> <span class="string">com.tensquare.article.pojo</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">id-type:</span> <span class="number">1</span>  </span><br><span class="line">    <span class="attr">db-column-underline:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">refresh-mapper:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">configuration:</span></span><br><span class="line">      <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">cache-enabled:</span> <span class="literal">true</span> </span><br><span class="line">      <span class="attr">lazyLoadingEnabled:</span> <span class="literal">true</span> </span><br><span class="line">      <span class="attr">multipleResultSetsEnabled:</span> <span class="literal">true</span> </span><br><span class="line">      <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>

<p>说明</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">typeAliasesPackage</td>
<td align="center">实体类所在包，多个package用逗号或者分号分隔</td>
</tr>
<tr>
<td align="center">id-type</td>
<td align="center">0表示数据库的自增ID，1表示用户输入ID</td>
</tr>
<tr>
<td align="center">cache-enabled</td>
<td align="center">缓存是否开启</td>
</tr>
<tr>
<td align="center">lazyLoadingEnabled</td>
<td align="center">懒加载是否开启</td>
</tr>
<tr>
<td align="center">multipleResultSetsEnabled</td>
<td align="center">延时加载是否开启</td>
</tr>
<tr>
<td align="center">log-impl</td>
<td align="center">打印SQL语句，用做调试</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>tensquare</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB使用</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E5%8D%81%E6%AC%A1%E6%96%B9/MongoDB/</url>
    <content><![CDATA[<h5 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h5><p>在 <code>pom.xml</code> 中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>application.yml</code> 文件中添加配置（spring内）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">database:</span> <span class="string">commentdb</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.13</span><span class="number">.128</span></span><br></pre></td></tr></table></figure>



<h5 id="2-什么是MongoDB"><a href="#2-什么是MongoDB" class="headerlink" title="2. 什么是MongoDB"></a>2. 什么是MongoDB</h5><p><strong>MongoDB</strong>是一个基于分布式文件存储的数据库，是一个介于<strong>关系型数据库</strong>和<strong>非关系型数据库</strong>之间的产品。</p>
<p>它支持的数据结构非常松散，是类似于JSON格式的BSON。</p>
<p>它是由<strong>C++编写</strong>的</p>
<h5 id="2-MongoDB的体系结构"><a href="#2-MongoDB的体系结构" class="headerlink" title="2. MongoDB的体系结构"></a>2. MongoDB的体系结构</h5><p>主要由<strong>文档、集合、数据库</strong>三部分组成</p>
<table>
<thead>
<tr>
<th align="center">MongoDB</th>
<th align="center">关系型数据库Mysql</th>
</tr>
</thead>
<tbody><tr>
<td align="center">数据库(databases)</td>
<td align="center">数据库(databases)</td>
</tr>
<tr>
<td align="center">集合(collections)</td>
<td align="center">表(table)</td>
</tr>
<tr>
<td align="center">文档(document)</td>
<td align="center">行(row)</td>
</tr>
</tbody></table>
<p>MongoDB的一个<strong>集合</strong>中存储了多条<strong>文档</strong>，文档是由多个<strong>key-value</strong>构成的</p>
<p>每条文档默认有个id</p>
]]></content>
      <categories>
        <category>tensquare</category>
      </categories>
  </entry>
  <entry>
    <title>项目上传至GitHub</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E5%8D%81%E6%AC%A1%E6%96%B9/Github%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="上传项目"><a href="#上传项目" class="headerlink" title="上传项目"></a>上传项目</h1><h2 id="1-先在github上新建一个仓库，记住HTTPS地址"><a href="#1-先在github上新建一个仓库，记住HTTPS地址" class="headerlink" title="1. 先在github上新建一个仓库，记住HTTPS地址"></a>1. 先在github上新建一个仓库，记住HTTPS地址</h2><h2 id="2-打开git-bash，进入到项目目录中"><a href="#2-打开git-bash，进入到项目目录中" class="headerlink" title="2. 打开git bash，进入到项目目录中"></a>2. 打开git bash，进入到项目目录中</h2><p>如果用的是<code>idea</code>之类的开发工具的话，可以在那里面打开<code>terminal</code>终端（默认会来到项目路径下）</p>
<p>就不用自己手动<code>cd</code>了</p>
<h2 id="3-依次键入以下命令"><a href="#3-依次键入以下命令" class="headerlink" title="3. 依次键入以下命令"></a>3. 依次键入以下命令</h2><p>第一次操作时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;first try&quot;</span></span><br><span class="line"></span><br><span class="line">git remote add origin https://github.com/ + ...  <span class="comment"># 这里是仓库地址</span></span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h2 id="4-之后更新项目"><a href="#4-之后更新项目" class="headerlink" title="4. 之后更新项目"></a>4. 之后更新项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 添加所有文件</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">// 提交并说明</span><br><span class="line">git commit -m <span class="string">&quot;second try&quot;</span></span><br><span class="line"></span><br><span class="line">// push到远程仓库</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<h2 id="5-遇到问题"><a href="#5-遇到问题" class="headerlink" title="5.遇到问题"></a>5.遇到问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure>

<p>使用<code>git config --global http.sslVerify &quot;false&quot;</code>命令解决</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure>

<p>检查代理是否关闭（要关闭）</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Feign使用</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E5%8D%81%E6%AC%A1%E6%96%B9/Feign/</url>
    <content><![CDATA[<h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>功能：用来调用<strong>其他微服务</strong>所提供的接口</p>
<h5 id="1-在本服务的pom-xml中添加Feign依赖，并在启动类上添加注解"><a href="#1-在本服务的pom-xml中添加Feign依赖，并在启动类上添加注解" class="headerlink" title="1. 在本服务的pom.xml中添加Feign依赖，并在启动类上添加注解"></a>1. 在本服务的<code>pom.xml</code>中添加Feign依赖，并在启动类上添加注解</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoticeApplication</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-在client包下创建其他微服务接口类"><a href="#2-在client包下创建其他微服务接口类" class="headerlink" title="2. 在client包下创建其他微服务接口类"></a>2. 在<code>client</code>包下创建其他微服务接口类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;tensquare-article&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;article/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="function">Result <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中声明要使用的方法（必须是其他微服务实现好的）</p>
<h5 id="3-注入Bean以调用接口"><a href="#3-注入Bean以调用接口" class="headerlink" title="3. 注入Bean以调用接口"></a>3. 注入Bean以调用接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserClient userClient;</span><br><span class="line"><span class="comment">// ...	userClient.findById(&quot;123&quot;);</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tensquare</category>
      </categories>
  </entry>
  <entry>
    <title>Eureka使用</title>
    <url>/2021/12/13/%E9%A1%B9%E7%9B%AE/%E5%8D%81%E6%AC%A1%E6%96%B9/Eureka/</url>
    <content><![CDATA[<p>功能：统一管理模块</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="1-在父工程的pom-xml文件下添加依赖"><a href="#1-在父工程的pom-xml文件下添加依赖" class="headerlink" title="1. 在父工程的pom.xml文件下添加依赖"></a>1. 在父工程的<code>pom.xml</code>文件下添加依赖</h4><p>另起一块</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Greenwich.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-创建Eureka的微服务模块"><a href="#2-创建Eureka的微服务模块" class="headerlink" title="2. 创建Eureka的微服务模块"></a>2. 创建Eureka的微服务模块</h4><p>右键 - &gt; new module - &gt; 选择maven工程进行创建</p>
<p>然后在Eureka模块中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在resource目录下添加<code>application.yml</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6868</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#是否将自己注册到eureka中</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#是否从eureka中获取信息</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>

<p>编写启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-将其他模块注册到Eureka中"><a href="#3-将其他模块注册到Eureka中" class="headerlink" title="3. 将其他模块注册到Eureka中"></a>3. 将其他模块注册到Eureka中</h4><p>在pom.xml中添加Eureka依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改配置文件，使用Eureka</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:6868/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后在启动类中添加注解：@EnableEurekaClient</p>
<hr>
]]></content>
      <categories>
        <category>tensquare</category>
      </categories>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2021/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><blockquote>
<p>红黑树是一种含有红黑节点并能<strong>自平衡</strong>的<strong>二叉查找树</strong></p>
</blockquote>
<ul>
<li>每个节点只能是红色或黑色</li>
<li>根节点为黑色</li>
<li>每个叶子节点（这里是指为空的节点）是黑色</li>
<li><strong>红色</strong>节点的<strong>子节点</strong>一定是<strong>黑色</strong></li>
<li><strong>任意一个节点</strong>到每个<strong>叶子节点</strong>的路径都包含<strong>相同数量</strong>的黑色节点</li>
</ul>
<h5 id="2-插入元素（每个新插入的节点默认是红色）"><a href="#2-插入元素（每个新插入的节点默认是红色）" class="headerlink" title="2. 插入元素（每个新插入的节点默认是红色）"></a>2. 插入元素（每个新插入的节点默认是红色）</h5><p>红黑树在插入节点时：</p>
<ol>
<li>先按搜索的顺序，把节点放在合适位置（类似二叉查找）</li>
<li>然后判断是否满足红黑树定义</li>
<li>不满足就会发生<strong>旋转</strong>和<strong>变色</strong>现象</li>
</ol>
<p>判断条件如下：</p>
<table>
<thead>
<tr>
<th align="center">情况</th>
<th align="center">做法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">父节点为黑色</td>
<td align="center">什么都不做</td>
</tr>
<tr>
<td align="center">父节点红色，且叔叔也是红色</td>
<td align="center">父亲叔叔变黑，祖父变红</td>
</tr>
<tr>
<td align="center">父红色，且叔叔为空或黑色</td>
<td align="center">旋转 + 变色</td>
</tr>
</tbody></table>
<img data-src="https://gitee.com/aurora1004/pictures/raw/master/20210430111115.png" style="zoom:67%;" />

<p>父节点红色，叔叔为黑色的情形：</p>
<h5 id="3-HashMap红黑树部分源码"><a href="#3-HashMap红黑树部分源码" class="headerlink" title="3. HashMap红黑树部分源码"></a>3. HashMap红黑树部分源码</h5><p>红黑树插入节点 <code>x</code> 时，进行了以下判断：</p>
<ol>
<li>若x的父亲是null，说明x是根节点，直接返回x（这里x就是根节点了，所以返回x）</li>
<li>若x的父亲是黑色 或者 x的祖父是空（即x的父亲为根节点，而根节点一定是黑色的），直接返回根节点</li>
<li></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">            x.red = <span class="keyword">true</span>; <span class="comment">// 要插入的节点</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123; <span class="comment">// x父亲为空，即x为根节点</span></span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)<span class="comment">// x父亲为黑色 或者 x祖父为空，不用调整</span></span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;<span class="comment">// 如果父亲叔叔都是红色</span></span><br><span class="line">                        xppr.red = <span class="keyword">false</span>;						 <span class="comment">// 则把父亲叔叔改成黑色，祖父改成红色</span></span><br><span class="line">                        xp.red = <span class="keyword">false</span>;							 <span class="comment">// 更新当前节点为祖父，进行下一次循环</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                            root = rotateLeft(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            xp.red = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="E:\吴和泽\NotepadFile\resources\rotate.png"></p>
<p><strong>左旋转，即以旋转点为中心，逆时针旋转</strong></p>
<p><strong>右旋，则是以旋转点为中心，顺时针旋转</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>) <span class="comment">// 这里分两步，赋值和判断											   									 	 // 赋值：r1 = r.left 且 p.right = r.left</span></span><br><span class="line">                    rl.parent = p;					 <span class="comment">// 判断：r.left != null</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>树的各种概念</title>
    <url>/2021/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/</url>
    <content><![CDATA[<h4 id="一、满二叉树"><a href="#一、满二叉树" class="headerlink" title="一、满二叉树"></a>一、满二叉树</h4><blockquote>
<p>从根节点到每一个叶子节点，所经过的路径数是相同的</p>
</blockquote>
<p>简单来说，就是二叉树是满的</p>
<h4 id="二、完全二叉树"><a href="#二、完全二叉树" class="headerlink" title="二、完全二叉树"></a>二、完全二叉树</h4><p>除了最后一层，其他都是满的</p>
<p>而且最后一层的节点必须靠左边</p>
<h4 id="三、二叉搜索树"><a href="#三、二叉搜索树" class="headerlink" title="三、二叉搜索树"></a>三、二叉搜索树</h4><blockquote>
<p>1.是一颗二叉树</p>
<p>2.任意节点的左子树上的节点一定小于该节点，右子树上的节点一定大于该节点</p>
</blockquote>
<p>这种树结构适合查找</p>
<h4 id="四、二叉平衡树"><a href="#四、二叉平衡树" class="headerlink" title="四、二叉平衡树"></a>四、二叉平衡树</h4><p>二叉平衡树又叫做<strong>AVL树</strong></p>
<p><strong>二叉搜索树在极端情况下会退化成链表，为了防止这种情况出现，提出了平衡树的概念</strong></p>
<blockquote>
<p>平衡树是指任意节点的左右子树高度不超过1</p>
</blockquote>
<p><strong>这样，我们就可以把二叉搜索树优化成平衡的二叉搜索树。</strong></p>
<p>注意：二叉平衡树是更加严格的搜索数。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>有限状态机</title>
    <url>/2021/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><blockquote>
<p><strong>有限状态机</strong>（Finite-state machine，FSM），简称状态机，是表示<strong>有限个状态</strong>以及在这些状态之间的<strong>转移</strong>和动作等行为的数学模型。</p>
</blockquote>
<h4 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2.适用范围"></a>2.适用范围</h4><p>在解决比较繁琐，容易思维混乱的问题时，可以使用有限状态机模型，限定该问题的范围和各种情形，并画出状态转移图或列出表格，以便厘清细节。</p>
<h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h4><p>链接直达：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转整数（atoi）</a></p>
<ul>
<li>题目描述</li>
</ul>
<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>
<ul>
<li>状态机表格</li>
</ul>
<table>
<thead>
<tr>
<th align="center">状态\条件</th>
<th align="center">‘ ’</th>
<th align="center">+/-</th>
<th align="center">number</th>
<th align="center">other</th>
</tr>
</thead>
<tbody><tr>
<td align="center">start</td>
<td align="center">start</td>
<td align="center">signed</td>
<td align="center">get_number</td>
<td align="center">end</td>
</tr>
<tr>
<td align="center">signed</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">get_number</td>
<td align="center">end</td>
</tr>
<tr>
<td align="center">get_number</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">get_number</td>
<td align="center">end</td>
</tr>
<tr>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">end</td>
<td align="center">end</td>
</tr>
</tbody></table>
<ul>
<li>题解代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        FSMTable fsm = <span class="keyword">new</span> FSMTable();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">            fsm.get(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(fsm.sign * fsm.ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FSMTable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;           <span class="comment">//符号,1 or -1</span></span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;           <span class="comment">//结果</span></span><br><span class="line">        String state = <span class="string">&quot;start&quot;</span>; <span class="comment">//记录当前状态,从start状态开始</span></span><br><span class="line">        HashMap&lt;String, String[]&gt; table = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FSMTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//构建状态表</span></span><br><span class="line">            table.put(<span class="string">&quot;start&quot;</span>, <span class="keyword">new</span> String[] &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;get_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">            table.put(<span class="string">&quot;signed&quot;</span>, <span class="keyword">new</span> String[] &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;get_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">            table.put(<span class="string">&quot;get_number&quot;</span>, <span class="keyword">new</span> String[] &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;get_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">            table.put(<span class="string">&quot;end&quot;</span>, <span class="keyword">new</span> String[] &#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取字符,进行状态转移</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            state = table.get(state)[judge(c)];</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;get_number&quot;</span>.equals(state)) &#123;</span><br><span class="line">                ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// c - &#x27;0&#x27; 即为字符 c 代表的数字</span></span><br><span class="line">                ans = sign == <span class="number">1</span> ? Math.min((<span class="keyword">long</span>)Integer.MAX_VALUE, ans) : Math.min(-(<span class="keyword">long</span>)Integer.MIN_VALUE, ans);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;signed&quot;</span>.equals(state)) &#123;</span><br><span class="line">                sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断字符，返回状态</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="笔记——排序"><a href="#笔记——排序" class="headerlink" title="笔记——排序"></a>笔记——排序</h1><h2 id="一、简单排序"><a href="#一、简单排序" class="headerlink" title="一、简单排序"></a>一、简单排序</h2><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><ul>
<li><p><strong>说明</strong></p>
<p>每次比较<strong>相邻</strong>两个元素大小，把较大的移到后面</p>
<p>在第k轮排序完成后（k从1开始），数组的<strong>最后k位</strong>是排好序的</p>
</li>
<li><p><strong>代码</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span> <span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每排完一个元素，i值-1</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">        <span class="comment">//比较相邻元素</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i; j ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums[j] &gt; nums[j+<span class="number">1</span>] ) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>复杂度分析</strong></p>
<ol>
<li>时间复杂度为    $O(n^2)$</li>
</ol>
</li>
</ul>
<hr>
<h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h4><ul>
<li><strong>组成</strong></li>
</ul>
<p><code>已排序 + 未排序</code></p>
<ul>
<li><p><strong>说明</strong></p>
<p>每次在已排序部分的末尾添加一个位置，然后所有未排序元素竞争这个位置，最小的进入</p>
<p>具体地说，就是从前往后，在数组中找到未排序的位置，然后遍历后面剩余数字，<strong>找到最小的</strong>，交换到前面去</p>
</li>
<li><p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span> <span class="params">( <span class="keyword">int</span>[] nums )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;<span class="comment">//前i个元素都是排好序的</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums[j] &lt; nums[i] ) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[minIndex];</span><br><span class="line">        nums[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>复杂度分析</strong></p>
<ol>
<li>时间复杂度    $O(n^2)$</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h4><ul>
<li><p><strong>说明</strong></p>
<p>像是打扑克牌一样，每拿到一张牌，就遍历前面，找到合适的位置插入。</p>
<p>具体来说，应该是从排好序的元素里，<strong>从后往前</strong>依次判断是否要交换</p>
</li>
<li><p><strong>对比</strong></p>
</li>
</ul>
<blockquote>
<p><strong>选择排序</strong>和<strong>插入排序</strong>，都有一部分是排序好的，不同之处在于：</p>
<p><u><strong>选择排序</strong></u>是从没排序的元素里找到最小的，然后放到已经排序部分的最后；</p>
<p>而**<u>插入排序</u>**是在已经排序的元素（严格来说，并没有排完序，只是有序）里找到合适的位置，插入当前元素</p>
</blockquote>
<ul>
<li><strong>代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span> <span class="params">( <span class="keyword">int</span>[] nums )</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从第二个元素开始</span></span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i ++ ) &#123;</span><br><span class="line">        <span class="comment">//依次向前一个元素比较</span></span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j -- ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( nums[j] &lt; nums[j-<span class="number">1</span>] ) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = nums[j-<span class="number">1</span>];</span><br><span class="line">				nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line">				nums[j] = temp;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//表明元素已经在正确位置</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优化版代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span> <span class="params">( <span class="keyword">int</span>[] nums )</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i ++ ) &#123;</span><br><span class="line">        <span class="comment">// 用临时变量tmp存储当前值</span></span><br><span class="line">        <span class="comment">// 然后让大于tmp的数字都向后移动一位，留出空位来插入</span></span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i]</span><br><span class="line">		<span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">            nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>复杂度分析</strong><ol>
<li>时间复杂度    $O(n^2)$</li>
</ol>
</li>
</ul>
<hr>
<h2 id="二、进阶排序"><a href="#二、进阶排序" class="headerlink" title="二、进阶排序"></a>二、进阶排序</h2><h4 id="1-希尔排序-面试不重要"><a href="#1-希尔排序-面试不重要" class="headerlink" title="1.希尔排序(面试不重要)"></a>1.希尔排序(面试不重要)</h4><ul>
<li><strong>说明</strong></li>
</ul>
<ol>
<li>希尔排序是插入排序的改良版，插入排序在寻找插入位置时，需要进行相邻元素的多次比较与交换，而希尔排序则定义了<code>增长量</code>，可以间隔的比较与交换。</li>
<li>希尔排序按<code>增长量</code>来分组，对每组数据进行插入排序；然后减小<code>增长量</code>，重复操作。</li>
</ol>
<ul>
<li><strong>代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span> <span class="params">( <span class="keyword">int</span>[] nums )</span> </span>&#123;</span><br><span class="line">	<span class="comment">//初始化增长量</span></span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> ( h &lt; nums.length/<span class="number">2</span> ) &#123;</span><br><span class="line">		h = h * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//开始排序</span></span><br><span class="line">	<span class="keyword">while</span> ( h &gt;= <span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="comment">//进阶版插入排序</span></span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i = h; i &lt; nums.length; i ++ ) &#123;</span><br><span class="line">			<span class="keyword">for</span> ( <span class="keyword">int</span> j = i; j &gt;= h; j -= h ) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( nums[j] &lt; nums[j-h] ) &#123;</span><br><span class="line">					<span class="keyword">int</span> temp = nums[j-h];</span><br><span class="line">					nums[j-h] = nums[j];</span><br><span class="line">					nums[j] = temp;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//更新增长量</span></span><br><span class="line">		h = h / <span class="number">2</span>;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong><del>复杂度分析</del></strong></li>
</ul>
<p>emmm……，超纲了，不用了解</p>
<hr>
<h4 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h4><ul>
<li>说明</li>
</ul>
<ol>
<li>快速排序可以看作是冒泡排序的进阶版，区别在于快排的交换是<code>跳跃式</code>的</li>
<li>快排使用了一个<code>基准点</code>，每次排序的目的都是把小于基准点的数放到基准点左边，大于等于的数放在右边</li>
<li>数组长度较小时，使用插入排序而不是快速排序</li>
</ol>
<ul>
<li>代码（基础版）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">            insertSort(nums, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, index - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, index + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; left &amp;&amp; tmp &lt; nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> randomIndex = RANDOM.nextInt(right - left + <span class="number">1</span>) + left; <span class="comment">// 包含nums[right]</span></span><br><span class="line">        swap(nums, left, randomIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left]; <span class="comment">// 定义基准值</span></span><br><span class="line">        <span class="keyword">int</span> lt = left;          <span class="comment">// 小于pivot的最右边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                lt ++;</span><br><span class="line">                swap(nums, lt, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, lt, left);</span><br><span class="line">        <span class="keyword">return</span> lt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双指针碰撞</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> randomIndex = RANDOM.nextInt(right - left + <span class="number">1</span>) + left; <span class="comment">// 包含nums[right]</span></span><br><span class="line">        swap(nums, left, randomIndex);</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> lt = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> gt = right;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lt &lt;= right &amp;&amp; nums[lt] &lt; pivot) &#123;</span><br><span class="line">                lt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (gt &gt;= left &amp;&amp; nums[gt] &gt; pivot) &#123;</span><br><span class="line">                gt --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lt &gt;= gt) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 等概分布</span></span><br><span class="line">            swap(nums, lt, gt);</span><br><span class="line">            lt ++;</span><br><span class="line">            gt --;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, gt);</span><br><span class="line">        <span class="keyword">return</span> gt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>三指针（相同元素划分到基准值，不进行递归）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待补充</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>复杂度分析</p>
<ol>
<li><p>时间复杂度</p>
<p>最坏情况为$O(n^2)$，平均为$O(nlogn)$</p>
</li>
</ol>
</li>
</ul>
<h4 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h4><ul>
<li><strong>说明</strong></li>
</ul>
<p>将待排序的数字一分为二，排序子数组后，最后进行合并</p>
<ul>
<li><strong>优化</strong><ul>
<li>划分的数组长度小于等于7时，采用插入排序</li>
<li>使用全局辅助数组temp，避免多次创建</li>
</ul>
</li>
<li><strong>代码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        part(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   分治</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">part</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">            insertSort(nums, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        part(nums, left, mid, temp);</span><br><span class="line">        part(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        merge(nums, left, mid, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   合并</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(nums, left, temp, left, right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   插入排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; left &amp;&amp; tmp &lt; nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>复杂度说明</strong><ul>
<li>时间复杂度$O(nlogn)$</li>
<li>空间复杂度$O(n)$</li>
</ul>
</li>
</ul>
<h4 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4.堆排序"></a>4.堆排序</h4><ul>
<li>说明</li>
</ul>
<p>用数组实现，先按大根堆来建堆，然后下沉后形成升序的数组。</p>
<ul>
<li>实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建堆，从最后的父节点开始下沉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        upToDown(nums, i, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排序，逐渐缩小堆的范围</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, i);</span><br><span class="line">        upToDown(nums, <span class="number">0</span>, i-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下沉，超过end或遇到两个更小的子节点时，停止下沉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upToDown</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 取较大的子节点</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt;= end - <span class="number">1</span> &amp;&amp; nums[next] &lt; nums[next+<span class="number">1</span>]) &#123;</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[k] &gt;= nums[next]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, k, next);</span><br><span class="line">        k = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="三、排序算法的稳定性总结"><a href="#三、排序算法的稳定性总结" class="headerlink" title="三、排序算法的稳定性总结"></a>三、排序算法的稳定性总结</h2><table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">是否稳定</th>
<th align="center">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">稳定</td>
<td align="center">因为只有前一个元素大于后一个元素时，才发生交换</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">不稳定</td>
<td align="center">为每个位置选择当前最小的元素进行交换，会破坏稳定性</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">稳定</td>
<td align="center">原因和冒泡排序类似，只有大于时才插入到其后面</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">不稳定</td>
<td align="center">首次排序时是稳定的，但他分成了好几组，不同组之间排序时可能会打乱顺序</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">不稳定</td>
<td align="center">基准值左右两侧交换时会破坏稳定性</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>信件错排</title>
    <url>/2021/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="1-信件错排"><a href="#1-信件错排" class="headerlink" title="1.信件错排"></a>1.信件错排</h1><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>存在<strong>n个信封</strong>和<strong>n封信</strong>，每封信都有个正确的信封存放，那么所有信<strong>都放错</strong>的情况有几种？</p>
<p>可以只写出转移方程</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$dp[i]$ 表示 $i$ 封信错排的总数</p>
<p>假设现在有5个信封和5封信，编号为1~5</p>
<p>如果我们把<code>信1</code>放入到<code>信封2</code>中，那么<code>信2</code>想要维持错排的状态，就有两种可能：一是放入<code>信封1</code>，二是放到<code>其他信封(3,4,5)</code>中</p>
<p><img data-src="E:\吴和泽\LearningFile\resources\dp-2.PNG"></p>
<p>针对情况一，信2放入到信封1后，就剩下了编号为<strong>3、4、5</strong>的信和信封，问题就转化为求3封信3个信封错排情况，即 $dp[i-2]$</p>
<p>针对情况二，信2要放入<strong>3、4、5</strong>中，如果我们把<code>信2</code>和<code>信封1</code>看成是一对，就有四对要错排的元素，那么就变成了求四封信四个信封的错排数，即 $dp[i-1]$</p>
<h3 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h3><p>信1放入信封2时， $dp[i] = dp[i-1] + dp[i-2]$</p>
<p>而最开始，信1还可能放到<strong>3、4、5</strong>中，总共有 $n-1$ 种可能</p>
<p><strong>所以</strong>：<br>$$<br>dp[i] = (i-1) * (dp[i-1] + dp[i-2])<br>$$<br>至于具体解，可以通过 <strong>一个for循环</strong> 和 <strong>滑动窗口</strong> 来计算</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>指数求余——循环求余和快速幂求余</title>
    <url>/2021/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%99%E6%95%B0/</url>
    <content><![CDATA[<h2 id="余数公式介绍"><a href="#余数公式介绍" class="headerlink" title="余数公式介绍"></a>余数公式介绍</h2><ul>
<li>$(x+y)⊕q=(x⊕q+y⊕q)⊕q$<ul>
<li>和的取余等于先取余再和再取余</li>
</ul>
</li>
<li>$x*y⊕q=(x⊕q)*y⊕q$<ul>
<li>积的取余等于先取余再积再取余</li>
</ul>
</li>
<li>$x^y⊕q=(x⊕q)^y⊕q$</li>
</ul>
<h2 id="循环取余"><a href="#循环取余" class="headerlink" title="循环取余"></a>循环取余</h2><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="一、异或"><a href="#一、异或" class="headerlink" title="一、异或"></a>一、异或</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><blockquote>
<p>二进制数A，B，A异或B表示成：A xor B</p>
<p>如果AB相同，结果为假；如果AB不同，结果为真</p>
<p>注：这里的<strong>相同</strong>与<strong>不同</strong>指的是AB的真假，例如AB同为真，或一真一假等情形。</p>
</blockquote>
<h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h2><ol>
<li><code>0</code>异或<code>任何数</code>，都等于它本身</li>
<li><code>1</code>异或<code>任何数</code>，结果等于该数字的二进制取反的结果</li>
<li><u>两个相同的数异或，结果为0</u></li>
</ol>
<p>上述第三个特点，可以用来找到<strong>若干偶数个</strong>相同数字中唯一一个<strong>个数为奇数</strong>的数字，如3322114，个数为奇数的是4</p>
<h2 id="3-面试题…"><a href="#3-面试题…" class="headerlink" title="3. 面试题…"></a>3. 面试题…</h2><ul>
<li><strong>一堆数字，里面有许多出现两次的数字，只有一个数字出现一次，请找出它</strong></li>
</ul>
<p>解法：所有数字异或，结果就是只出现一次的数字</p>
<ul>
<li><strong>加强版，有两个数字只出现一次，找出它们</strong></li>
</ul>
<p>解法：</p>
<ol>
<li>先进行一次异或，得到<code>A</code>和<code>B</code>异或后的值</li>
<li>然后把该值转化成二进制，找到某位是1的<ol>
<li>为1说明目标数字在这一位上的值是不同的</li>
<li>因为0与1异或才能得到1</li>
</ol>
</li>
<li>把所有数字，按该位是0或是1，分成两组<ol>
<li>目标值就分成两组了</li>
</ol>
</li>
<li>对两组分别进行异或，得到两个目标值</li>
</ol>
<h1 id="二、与"><a href="#二、与" class="headerlink" title="二、与"></a>二、与</h1><h2 id="1-n-amp-n-1"><a href="#1-n-amp-n-1" class="headerlink" title="1. n &amp; n-1"></a>1. n &amp; n-1</h2><p>该式能把数字n的二进制表示中，最后的一位1变成0</p>
<p>如：已知$10 = (1010)_2\quad9 = (1001)_2\quad8 = (1000)_2$，10 &amp; (10 - 1) = 1000</p>
<h1 id="三、左移右移"><a href="#三、左移右移" class="headerlink" title="三、左移右移"></a>三、左移右移</h1><ul>
<li><p>左移  <code>&lt;&lt;</code></p>
</li>
<li><p>右移  <code>&gt;&gt;</code></p>
</li>
<li><p>无符号右移  <code>&gt;&gt;&gt;</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/12/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h3 id="一、最基础版"><a href="#一、最基础版" class="headerlink" title="一、最基础版"></a>一、最基础版</h3><p>特点</p>
<ul>
<li><p>循环条件：$left &lt;= right，即left = right + 1时退出循环$</p>
</li>
<li><p>命中<code>target</code>直接返回，退出循环就说明没找到</p>
</li>
</ul>
<p>这样的二分查找有个缺点，无法找到相同数字的边界，只能看情况找。</p>
<p><strong>例如数组[1,2,2,2,3]，查找2的话会命中中间的，无法处理边界。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、搜索左侧边界"><a href="#二、搜索左侧边界" class="headerlink" title="二、搜索左侧边界"></a>二、搜索左侧边界</h3><p><strong>特点</strong></p>
<ul>
<li><strong>找到相同元素时收缩右侧边界，目的在于向左侧靠拢</strong></li>
<li>退出循环时$left = right + 1$，此时<ul>
<li><code>target</code>大于所有元素，会发生越界，返回<code>-1</code></li>
<li><code>left</code>没有命中，返回<code>-1</code></li>
<li><code>left</code>命中元素，返回<code>left</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">           left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;<span class="comment">//注意点1:收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意点2:判断越界、命中情况</span></span><br><span class="line">    <span class="keyword">if</span> (left == nums.length || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、搜索右侧边界"><a href="#三、搜索右侧边界" class="headerlink" title="三、搜索右侧边界"></a>三、搜索右侧边界</h3><p><strong>和左侧边界的方法类似，区别在于命中时要收缩左侧边界，即向右侧靠拢。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">           left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;<span class="comment">//注意点1:收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意点2:判断越界、命中情况</span></span><br><span class="line">    <span class="keyword">if</span> (left == nums.length || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p>
<p><strong>主要元素</strong></p>
<ul>
<li><p><strong>Aggregate</strong></p>
<p>提供接口创建迭代器</p>
</li>
<li><p><strong>Iterator</strong></p>
<p>迭代器接口，拥有<code>next()</code>和<code>hasNext()</code>方法</p>
</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/image-20201102012333804.png" alt="image-20191130164425351"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>手动构建一个迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">        <span class="function">MyIterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">MyIterator</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">Item <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer[] items;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 初始化数据 */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            items = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyIterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator&lt;&gt;(items);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">MyIterator</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Item[] items;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> position;</span><br><span class="line"></span><br><span class="line">        ConcreteIterator (Item[] items) &#123;</span><br><span class="line">            <span class="keyword">this</span>.items = items;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items[position++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> position &lt; items.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        ConcreteAggregate aggregate = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        aggregate.initData();</span><br><span class="line">        MyIterator iterator = aggregate.createIterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%B4%A3%E4%BB%BB%E9%93%BE/</url>
    <content><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p><strong>定义</strong></p>
<blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。</p>
<p>将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p>
</blockquote>
<p><strong>解释</strong></p>
<p>当请求有可能经过多个对象处理时，并且它们之间存在逻辑上的先后顺序时，不要把条件和具体的处理逻辑耦合在一起。</p>
<p>比较好的做法是定义成内部的链式传递，客户端只能感知到与它最近的一端。</p>
<p><strong>主要对象</strong></p>
<ul>
<li><strong>Handler接口</strong><ul>
<li>处理请求的接口，包含当前节点的处理方法以及继任者。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Client</strong><ul>
<li>客户端，调用Handler来处理请求</li>
</ul>
</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/ca9f23bf-55a4-47b2-9534-a28e35397988.png" alt="img"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>某公司职员想要申请聚餐费用，申请需经过<code>项目经理 - 部门经理 - 总经理</code>。其中，具体的逻辑为：</p>
<ol>
<li>项目经理负责500元以下的审批，超过则上报给部门经理审批</li>
<li>部门经理负责1000元以下的审批，超过则上报给总经理审批</li>
<li>总经理会对超过2000元的审批直接拒绝</li>
<li>此外，每个经理都会进行能否通过审批的判断。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ze.aurora.behaviour;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 责任链</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 申请聚餐费用时，可能会经过“项目经理 - 部门经理 - 总经理”这样的审批顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aurora</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/17 14:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> Handler successor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ProjectManagerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> someCondition = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.successor = successor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">500</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;项目经理审批通过&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;项目经理拒绝审批&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;项目经理 -&gt; 部门经理&quot;</span>);</span><br><span class="line">                successor.handle(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DepartmentManagerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> someCondition = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.successor = successor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;部门经理审批通过&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;部门经理拒绝审批&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;部门经理 -&gt; 总经理&quot;</span>);</span><br><span class="line">                successor.handle(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GeneralManagerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> someCondition = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.successor = successor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">2000</span> &amp;&amp; someCondition) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;总经理审批通过&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;总经理拒绝审批&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 构造责任链 */</span></span><br><span class="line">        ProjectManagerHandler projectManagerHandler = <span class="keyword">new</span> ProjectManagerHandler();</span><br><span class="line">        DepartmentManagerHandler departmentManagerHandler = <span class="keyword">new</span> DepartmentManagerHandler();</span><br><span class="line">        GeneralManagerHandler generalManagerHandler = <span class="keyword">new</span> GeneralManagerHandler();</span><br><span class="line"></span><br><span class="line">        projectManagerHandler.setSuccessor(departmentManagerHandler);</span><br><span class="line">        departmentManagerHandler.setSuccessor(generalManagerHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 费用申请 */</span></span><br><span class="line">        projectManagerHandler.handle(<span class="number">1200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特点分析"><a href="#特点分析" class="headerlink" title="特点分析"></a>特点分析</h4><p><strong>符合单一职责原则</strong>。</p>
<ul>
<li>责任链模式将调用链上的每个角色的职责划分的更加清晰。如果某一角色的处理逻辑发生变化，我们可以很快的定位并进行改动。</li>
</ul>
<p><strong>符合迪米特法则</strong></p>
<ul>
<li>调用方与处理方解耦，调用方不清楚是谁处理了请求，它只需接收最后处理的结果即可。</li>
</ul>
<p><strong>动态的构造责任链</strong></p>
<ul>
<li>一旦传递过程发生了改变，我们可以灵活的改变责任链的传递，并且调用方也无需感知。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%AE%BF%E9%97%AE%E8%80%85/</url>
    <content><![CDATA[<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p><strong>定义</strong></p>
<blockquote>
<p>当想要为一个对象的组合增加新的能力时，且这个组合的封装并不重要，那么就可以使用访问者模式。</p>
</blockquote>
<p><strong>解释</strong></p>
<p>例如为String类添加功能，我们可以在自定义的类中组合String对象，实现新功能。</p>
<p>这么做的话，不需要修改原来的String类就能做到扩展或修改功能，但是原先String类的封装就会变得不是很完美（因为新功能没有写在里面）。</p>
<p><strong>主要元素</strong></p>
<ul>
<li><strong>Visitor</strong>：访问者接口，定义<code>visit()</code>方法对某一元素进行访问。</li>
<li><strong>Element</strong>：被访问的元素接口，定义<code>accept()</code>接受访问者</li>
<li><strong>ObjectStructure</strong>：对象结构，通常是对所有元素进行遍历访问</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/79c6f036-bde6-4393-85a3-ef36a0327bd2.png" alt="img"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>顾客想要获取菜单或原料的一些信息，但是菜单和原料很有可能会变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVisitor</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">visitMenu</span><span class="params">(MenuItem element)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">visitMaterial</span><span class="params">(Material element)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitor</span> <span class="keyword">implements</span> <span class="title">IVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMenu</span><span class="params">(MenuItem element)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// visitor add ...</span></span><br><span class="line">            element.getState();</span><br><span class="line">            <span class="comment">// visitor add ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMaterial</span><span class="params">(Material element)</span> </span>&#123;</span><br><span class="line">            element.getState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        Element(String name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor visitor)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MenuItem(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor visitor)</span> </span>&#123;</span><br><span class="line">            visitor.visitMenu(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;的营养价值为10&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Material</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Material(String name) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(IVisitor visitor)</span> </span>&#123;</span><br><span class="line">            visitor.visitMaterial(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;的营养价值为5&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">        List&lt;Element&gt; lists;</span><br><span class="line"></span><br><span class="line">        ObjectStructure() &#123;</span><br><span class="line">            <span class="keyword">this</span>.lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addElement</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">            lists.add(element);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recurse</span><span class="params">(IVisitor visitor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(Element e : lists) &#123;</span><br><span class="line">                e.accept(visitor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectStructure obj = <span class="keyword">new</span> ObjectStructure();</span><br><span class="line">        obj.addElement(<span class="keyword">new</span> MenuItem(<span class="string">&quot;宫爆鸡丁&quot;</span>));</span><br><span class="line">        obj.addElement(<span class="keyword">new</span> Material(<span class="string">&quot;鸡肉&quot;</span>));</span><br><span class="line"></span><br><span class="line">        obj.recurse(<span class="keyword">new</span> ConcreteVisitor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
    <content><![CDATA[<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p>
<p><strong>主要元素</strong></p>
<ul>
<li><p><strong>AbstractExpression</strong></p>
<p>抽象类，提供抽象方法<code>interpret()</code></p>
</li>
<li><p><strong>Context</strong></p>
<p>表达式上下文，对多个解释器共享。</p>
</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/2b125bcd-1b36-43be-9b78-d90b076be549.png" alt="img"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>实现一个能够处理and和or逻辑的解释器，并对字符串进行匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String exp)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span></span>&#123;</span><br><span class="line">        AbstractExpression expression1;</span><br><span class="line">        AbstractExpression expression2;</span><br><span class="line"></span><br><span class="line">        AndExpression(AbstractExpression expression1, AbstractExpression expression2) &#123;</span><br><span class="line">            <span class="keyword">this</span>.expression1 = expression1;</span><br><span class="line">            <span class="keyword">this</span>.expression2 = expression2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String exp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> expression1.interpret(exp) &amp;&amp; expression2.interpret(exp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OrExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span></span>&#123;</span><br><span class="line">        AbstractExpression expression1;</span><br><span class="line">        AbstractExpression expression2;</span><br><span class="line"></span><br><span class="line">        OrExpression(AbstractExpression expression1, AbstractExpression expression2) &#123;</span><br><span class="line">            <span class="keyword">this</span>.expression1 = expression1;</span><br><span class="line">            <span class="keyword">this</span>.expression2 = expression2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String exp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> expression1.interpret(exp) || expression2.interpret(exp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span></span>&#123;</span><br><span class="line">        String letter;</span><br><span class="line"></span><br><span class="line">        TerminalExpression(String letter) &#123;</span><br><span class="line">            <span class="keyword">this</span>.letter = letter;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String exp)</span> </span>&#123;</span><br><span class="line">            StringTokenizer tokenizer = <span class="keyword">new</span> StringTokenizer(exp);</span><br><span class="line">            <span class="keyword">while</span>(tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">                String next = tokenizer.nextToken();</span><br><span class="line">                <span class="keyword">if</span> (letter.equals(next)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractExpression A = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        AbstractExpression B = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        AbstractExpression C = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        AbstractExpression D = <span class="keyword">new</span> TerminalExpression(<span class="string">&quot;D&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造表达式 D and (A or (B or C))</span></span><br><span class="line">        AbstractExpression BC = <span class="keyword">new</span> OrExpression(B, C);</span><br><span class="line">        AbstractExpression exp = <span class="keyword">new</span> OrExpression(A, BC);</span><br><span class="line">        AbstractExpression exp1 = <span class="keyword">new</span> AndExpression(D, exp);</span><br><span class="line"></span><br><span class="line">        System.out.println(exp1.interpret(<span class="string">&quot;D A&quot;</span>));;</span><br><span class="line">        System.out.println(exp1.interpret(<span class="string">&quot;A B&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%82%E5%AF%9F%E8%80%85/</url>
    <content><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p>
<p><strong>主要元素</strong></p>
<ul>
<li><p><strong>Subject</strong></p>
<p>主题接口</p>
</li>
<li><p><strong>Observer</strong></p>
<p>观察者接口</p>
</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/a8c8f894-a712-447c-9906-5caef6a016e3.png" alt="img"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>多个观察者观察天气变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observable observer)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observable observer)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WeatherCenter</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Observable&gt; observers;</span><br><span class="line"></span><br><span class="line">        WeatherCenter() &#123;</span><br><span class="line">            observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observable observer)</span> </span>&#123;</span><br><span class="line">            observers.add(observer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observable observer)</span> </span>&#123;</span><br><span class="line">            observers.remove(observer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Observable observer: observers) &#123;</span><br><span class="line">                observer.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WeatherObserver</span> <span class="keyword">implements</span> <span class="title">Observable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.toString() + <span class="string">&quot; find that weather has changed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WeatherCenter sub = <span class="keyword">new</span> WeatherCenter();</span><br><span class="line">        sub.addObserver(<span class="keyword">new</span> WeatherObserver());</span><br><span class="line">        sub.addObserver(<span class="keyword">new</span> WeatherObserver());</span><br><span class="line"></span><br><span class="line">        sub.notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>预先封装多种算法，算法之间可以进行相互替换；因此算法的变化独立于使用算法的客户。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/cd1be8c2-755a-4a66-ad92-2e30f8f47922.png" alt="img"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IStrategy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Strategy1</span> <span class="keyword">implements</span> <span class="title">IStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;handle 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Strategy2</span> <span class="keyword">implements</span> <span class="title">IStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;handle 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">        IStrategy strategy;</span><br><span class="line"></span><br><span class="line">        Context(IStrategy strategy) &#123;</span><br><span class="line">            <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            strategy.handle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(IStrategy strategy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> Strategy1());</span><br><span class="line">        context.exec();</span><br><span class="line"></span><br><span class="line">        context.setStrategy(<span class="keyword">new</span> Strategy2());</span><br><span class="line">        context.exec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p><strong>定义</strong></p>
<p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p>
<p><strong>解释</strong></p>
<p>当对象在不同条件下会有不同的行为时，我们可以提取出对象的状态特征，并与相应的处理方法绑定。</p>
<p>这样条件变化时，对象的状态也会变化，调用的处理方法也就不一样了。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><strong>主要元素</strong></p>
<ul>
<li><p>State</p>
<p>状态接口，定义了某个状态的处理方法。</p>
</li>
<li><p>Context</p>
<p>动态维护当前状态对象。</p>
</li>
</ul>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/79df886f-fdc3-4020-a07f-c991bb58e0d8.png" alt="img"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在投票系统中，用户至多投一票。如果重复投5票后，会被判定为恶意用户，之前投票取消；如果重复投票达8票后，会对用户进行封禁，无法登录系统。</p>
<p>因此用户的投票状态可以是：</p>
<ol>
<li>正常投票</li>
<li>重复投票</li>
<li>恶意投票</li>
<li>封禁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ze.aurora.behaviour;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aurora</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/12/17 15:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VoteState</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">vote</span><span class="params">(String user, String content, VoteSystem system)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NormalVoteState</span> <span class="keyword">extends</span> <span class="title">VoteState</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">vote</span><span class="params">(String user, String content, VoteSystem system)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;投票成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RepeatVoteState</span> <span class="keyword">extends</span> <span class="title">VoteState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">vote</span><span class="params">(String user, String content, VoteSystem system)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请不要重复投票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MaliciousVoteState</span> <span class="keyword">extends</span> <span class="title">VoteState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">vote</span><span class="params">(String user, String content, VoteSystem system)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恶意投票，令投票作废&quot;</span>);</span><br><span class="line">            system.voteRecord.remove(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BlackVoteState</span> <span class="keyword">extends</span> <span class="title">VoteState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">vote</span><span class="params">(String user, String content, VoteSystem system)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;判定为极端恶意行为，永久封禁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">VoteSystem</span> </span>&#123;</span><br><span class="line">        VoteState state;</span><br><span class="line">        Map&lt;String, String&gt; voteRecord;</span><br><span class="line">        Map&lt;String, Integer&gt; voteCount;</span><br><span class="line"></span><br><span class="line">        VoteSystem() &#123;</span><br><span class="line">            state = <span class="keyword">null</span>;</span><br><span class="line">            voteRecord = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            voteCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">vote</span><span class="params">(String user, String content)</span> </span>&#123;</span><br><span class="line">            voteRecord.put(user, content);</span><br><span class="line">            <span class="keyword">int</span> oldVoteCnt = voteCount.getOrDefault(user, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> newVoteCnt = oldVoteCnt + <span class="number">1</span>;</span><br><span class="line">            voteCount.put(user, newVoteCnt);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newVoteCnt == <span class="number">1</span>) &#123;</span><br><span class="line">                state = <span class="keyword">new</span> NormalVoteState();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newVoteCnt &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                state = <span class="keyword">new</span> RepeatVoteState();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newVoteCnt &lt; <span class="number">8</span>) &#123;</span><br><span class="line">                state = <span class="keyword">new</span> MaliciousVoteState();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = <span class="keyword">new</span> BlackVoteState();</span><br><span class="line">            &#125;</span><br><span class="line">            state.vote(user, content, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VoteSystem system = <span class="keyword">new</span> VoteSystem();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            system.vote(<span class="string">&quot;aurora&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特点分析"><a href="#特点分析" class="headerlink" title="特点分析"></a>特点分析</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h2><p><strong>使用场景</strong></p>
<p>整体的算法框架是固定的，但是中间的某些步骤会随着具体情况而变化</p>
<p><strong>做法</strong></p>
<p>在抽象类中，实现共通的方法和整体步骤，把会发生变化的方法抽象化，交给子类去实现。</p>
<h2 id="二、代码示例"><a href="#二、代码示例" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 人的一生从整体看来是一样的，经历出生、生活和死亡三个阶段。</span></span><br><span class="line"><span class="comment"> * 但是每个人生活的方式不同，随具体的人而变化。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Aurora</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/10/8 19:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        born();</span><br><span class="line">        live();</span><br><span class="line">        die();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">born</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;born&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;die&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NormalPerson</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;normal live&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、具体应用"><a href="#三、具体应用" class="headerlink" title="三、具体应用"></a>三、具体应用</h2><p>JUC包中的AQS（抽象的队列式的同步器）就使用了模板方法：</p>
<ul>
<li>自带一套锁和同步的模板（包括获取锁、获取不到锁时入队维护）</li>
<li>把尝试获取锁、尝试释放锁等方法抽象化，交给子类去实现</li>
</ul>
<h3 id="3-1自有模板"><a href="#3-1自有模板" class="headerlink" title="3.1自有模板"></a>3.1自有模板</h3><p>如下，AQS中已实现了获取锁的整体逻辑：</p>
<ol>
<li>先尝试获取锁</li>
<li>获取成功则表示该线程已拥有锁</li>
<li>获取失败则把该线程入队，并进行自旋</li>
</ol>
<p>但是内部调用的<code>tryAcquire()</code>是留给子类去实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>AQS留给子类实现的方法共有5个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 相似的4个</span></span><br><span class="line"><span class="comment">// tryRelease</span></span><br><span class="line"><span class="comment">// tryAcquireShared</span></span><br><span class="line"><span class="comment">// tryReleaseShared</span></span><br><span class="line"><span class="comment">// isHeldExclusively</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-2子类实现"><a href="#3-2子类实现" class="headerlink" title="3.2子类实现"></a>3.2子类实现</h3><p>JUC包中的<code>ReentrantLock</code>内部使用Sync类实现锁和同步，而Sync类就继承了AQS，拥有自己的实现。</p>
<p><strong>tryAcquire()</strong></p>
<p>对AQS提供的方法的实现</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>nonfairTryAcquire()</strong></p>
<p>非公平地尝试获取锁</p>
<ol>
<li>根据state状态来判断锁是否空闲（等于0）<ul>
<li>空闲：尝试加锁</li>
<li>不空闲：进入下一个分支</li>
</ul>
</li>
<li>不空闲的话，看拥有锁的线程是不是自己<ul>
<li>当前线程持有锁：再次加锁，即<code>可重入</code>的概念</li>
<li>非当前线程持有：获取锁失败</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3改动"><a href="#3-3改动" class="headerlink" title="3.3改动"></a>3.3改动</h3><p>AQS使用的设计模式与上述普通的模板方法略有不同：</p>
<p>它提供的5个交由子类实现的方法，并没有用<code>abstract</code>修饰</p>
<p><strong>原因：因为AQS的锁有两种类型：互斥和共享，一般的同步器只需要实现其中一种锁即可。而如果用abstract修饰，则子类必须实现所有抽象方法，会造成不必要的实现。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%A9%BA%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p><strong>正式定义</strong></p>
<blockquote>
<p>命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p>
</blockquote>
<p><strong>理解</strong></p>
<p>当存在多种不同命令要执行时，使用<code>命令模式</code>可以将命令的请求者从命令的执行者中解耦开来，而实现这一步的做法就是<strong>将命令封装成对象</strong>，内部的执行细节对请求者屏蔽。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/c44a0342-f405-4f17-b750-e27cf4aadde2.png" alt="img"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>存在一个遥控器，可装配多个可拆卸的控件，每个控件都只有开和关两个操作，例如控制灯光开关、控制音响开关等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装的命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;light is on&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;light is off&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">        Light light;</span><br><span class="line"></span><br><span class="line">        LightOnCommand(Light light) &#123;</span><br><span class="line">            <span class="keyword">this</span>.light = light;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            light.on();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            light.off();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">        Light light;</span><br><span class="line"></span><br><span class="line">        LightOffCommand(Light light) &#123;</span><br><span class="line">            <span class="keyword">this</span>.light = light;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            light.off();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            light.on();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No Command&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;No Command&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遥控器类，可以请求执行当前装配的控件的开关操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line">        ICommand[] onCommands;</span><br><span class="line">        ICommand[] offCommands;</span><br><span class="line">        ICommand undoCommand;</span><br><span class="line"></span><br><span class="line">        RemoteControl(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            onCommands = <span class="keyword">new</span> ICommand[size];</span><br><span class="line">            offCommands = <span class="keyword">new</span> ICommand[size];</span><br><span class="line">            undoCommand = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 令数组初始化为空命令</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                onCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">                offCommands[i] = <span class="keyword">new</span> NoCommand();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setOnCommands</span><span class="params">(ICommand command, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; onCommands.length - <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            onCommands[position] = command;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setOffCommands</span><span class="params">(ICommand command, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; offCommands.length - <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            offCommands[position] = command;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCommand</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; onCommands.length - <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            onCommands[position].execute();</span><br><span class="line">            undoCommand = onCommands[position];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">offCommand</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; offCommands.length - <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            offCommands[position].execute();</span><br><span class="line">            undoCommand = offCommands[position];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            undoCommand.undo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RemoteControl control = <span class="keyword">new</span> RemoteControl(<span class="number">1</span>);</span><br><span class="line">        Light light = <span class="keyword">new</span> Light();</span><br><span class="line">        control.setOnCommands(<span class="keyword">new</span> LightOnCommand(light), <span class="number">0</span>);</span><br><span class="line">        control.setOffCommands(<span class="keyword">new</span> LightOffCommand(light), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        control.onCommand(<span class="number">0</span>);</span><br><span class="line">        control.offCommand(<span class="number">0</span>);</span><br><span class="line">        control.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p><strong>宏命令</strong></p>
<p>如果我们希望遥控器能够按下一个按钮，执行多个命令，那么这个命令的集合就是<code>宏命令</code>。</p>
<p>实现宏命令，我们只需要一个实现命令接口的对象，然后在其内部用数组（原先是单个引用）存储多个命令即可。</p>
<p><strong>队列请求</strong></p>
<p>遥控器中的命令数组可以看作是包含多个请求的队列，可以由另一个线程来取出请求，执行它的<code>execute()</code>方法。</p>
<p><strong>日志请求</strong></p>
<p>通过在<code>Command</code>接口中添加<code>store()</code>和<code>load()</code>方法来实现操作的记录与恢复。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E8%A3%85%E9%A5%B0/</url>
    <content><![CDATA[<h2 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>为对象动态地添加功能。</p>
<p><strong>主要元素</strong></p>
<ul>
<li><p><strong>组件</strong></p>
<p>接口，提供简单方法</p>
</li>
<li><p><strong>装饰者</strong></p>
<p>抽象类，实现组件接口，<strong>可以不实现接口方法</strong></p>
</li>
<li><p><strong>具体装饰者</strong></p>
<p>继承装饰者类，并提供额外方法（和组件方法相比）</p>
</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png" alt="img"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>生成器模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>对于一个<code>复杂对象</code>的构造过程，可以使用builder来实现每一步逻辑，然后由director指导进行整体组装（实际调用builder对象的方法）。</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/db5e376d-0b3e-490e-a43a-3231914b6668.png" alt="img"></p>
<p>具体代码可查看<code>StringBuilder</code>类，它便是采用了生成器模式。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">        FileBuilder builder;</span><br><span class="line">        </span><br><span class="line">        Director(FileBuilder builder) &#123;</span><br><span class="line">            <span class="keyword">this</span>.builder = builder;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            builder.buildHeader();</span><br><span class="line">            builder.buildBody();</span><br><span class="line">            builder.buildFooter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">FileBuilder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">buildHeader</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">buildFooter</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TXTBuilder</span> <span class="keyword">implements</span> <span class="title">FileBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TXT header&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TXT body&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFooter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;TXT footer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">XMLBuilder</span> <span class="keyword">implements</span> <span class="title">FileBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;XML header&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;XML body&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFooter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;XML footer&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileBuilder builder = <span class="keyword">new</span> XMLBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        director.construct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成器与模板方法"><a href="#生成器与模板方法" class="headerlink" title="生成器与模板方法"></a>生成器与模板方法</h2><ol>
<li>目的不同<ul>
<li>生成器的目的是为了构建一个复杂对象，而模板方法是实现一套完整的算法框架</li>
</ul>
</li>
<li>方式不同<ul>
<li>生成器通过director组合builder的方式架构，而模板方法主要使用的是继承</li>
</ul>
</li>
<li>但两者都能实现整体算法步骤与某些具体步骤实现的分离</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/40c0c17e-bba6-4493-9857-147c0044a018.png" alt="img"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>在工厂中，具体的获取方法延迟到子类去实现，然后通过不同的工厂来获得不同产品。</p>
<p>和简单工厂相比，它的特点是由调用方决定创建什么工厂，以此来获得产品。</p>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png" alt="img"></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethod</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 具体方法交给子类延迟实现*/</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MilkFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Milk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TeaFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tea();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> TeaFactory();</span><br><span class="line">        Product product = factory.createProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>一个工厂提供多个方法来创建组成产品的不同部分，因此它实际创建了一系列产品，即<code>产品簇</code>。</p>
<p>而抽象工厂的多个实现类则代表了不同型号的产品簇。</p>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/e2190c36-8b27-4690-bde5-9911020a1294.png" alt="img"></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">IntelCPU</span> <span class="keyword">extends</span> <span class="title">CPU</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AMDCPU</span> <span class="keyword">extends</span> <span class="title">CPU</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SamsungMemory</span> <span class="keyword">extends</span> <span class="title">Memory</span> </span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TOSHIBAMemory</span> <span class="keyword">extends</span> <span class="title">Memory</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">        <span class="function">CPU <span class="title">createCPU</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Memory <span class="title">createMemory</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CPU <span class="title">createCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> IntelCPU();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Memory <span class="title">createMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SamsungMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CPU <span class="title">createCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AMDCPU();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Memory <span class="title">createMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TOSHIBAMemory();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ComputerFactory factory = <span class="keyword">new</span> ConcreteFactory1();</span><br><span class="line">        <span class="comment">// cpu和memory作为一个产品整体，不可随意搭配</span></span><br><span class="line">        factory.createCPU();</span><br><span class="line">        factory.createMemory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三种工厂模式的优缺点"><a href="#三种工厂模式的优缺点" class="headerlink" title="三种工厂模式的优缺点"></a>三种工厂模式的优缺点</h2><p><strong>简单工厂</strong></p>
<ol>
<li>将创建对象的逻辑分离开</li>
<li>违背开放-封闭原则（增加产品时需要修改工厂类）</li>
</ol>
<p><strong>工厂方法</strong></p>
<ol>
<li>满足开放-封闭原则（增加产品时再写一个工厂实现类即可）</li>
<li>将决定某个产品的逻辑交给了客户来执行</li>
</ol>
<p><strong>抽象工厂</strong></p>
<ol>
<li>方便产品簇之间的切换（取决于用户使用哪个工厂实现类）</li>
<li>增加产品时要在抽象工厂中新增方法，然后所有实现类可能都要增加新产品的实现</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><h2 id="原型模式描述"><a href="#原型模式描述" class="headerlink" title="原型模式描述"></a>原型模式描述</h2><p>要求某个对象提供自身的<code>拷贝方法</code>，能够返回一个全新的具有相同类型和属性的对象。</p>
<p>这样做可以防止将多种对象的复制操作硬编码在业务逻辑中，造成耦合。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/b8922f8c-95e6-4187-be85-572a509afb71.png" alt="img"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>场景：学生和老师实现<code>Prototype</code>接口，实现自己的克隆方法。</strong></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Prototype <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        String id;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Student student = <span class="keyword">new</span> Student();</span><br><span class="line">            student.name = <span class="keyword">this</span>.name;</span><br><span class="line">            student.id = <span class="keyword">this</span>.id;</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        String department;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">            teacher.name = <span class="keyword">this</span>.name;</span><br><span class="line">            teacher.department = <span class="keyword">this</span>.department;</span><br><span class="line">            <span class="keyword">return</span> teacher;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.pdai.tech/md/dev-spec/pattern/7_prototype.html">https://www.pdai.tech/md/dev-spec/pattern/7_prototype.html</a></p>
<p><a href="https://www.jianshu.com/p/1638e7b068c1">https://www.jianshu.com/p/1638e7b068c1</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>确保类只有一个实例</p>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/eca1f422-8381-409b-ad04-98ef39ae38ba.png" alt="img"></p>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>把构造方法变为私有，通过静态方法来获取静态对象实例。</p>
<p>只有在用到对象时，才进行创建，节省了资源。</p>
<p><strong>但是，多个线程同时进入判断后，会实例化多个对象，所以线程不安全。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>直接把对象实例化，但这样丢失了节省资源的好处。</p>
<p>这样不会有线程不安全的风险。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="function"><span class="title">getUniqueInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h3><p>我们可以只对判断语句内部加锁，这样只有对象还没被实例化过，才会进行加锁并创建对象。</p>
<p>如果对象被实例化过，其他线程就不会阻塞，直接得到对象。</p>
<p><strong>注意</strong></p>
<p><strong>1.这里要用到两个if判断，如果只有外层一个判断，仍然会有多个线程进入判断内部，依次执行实例化操作</strong></p>
<p><strong>2.uniqueInstance使用volatile修饰，防止指令重排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        		<span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        			uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        		&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>加载外部类时，内部类并不会被加载到内存中。</p>
<p>只有调用<code>getUniqueInstance()</code>，触发了<code>SingletonHolder.INSTANCE</code>后，才会加载内部类，并实例化对象。</p>
<p>这种实现不仅具有延迟初始化，还利用了JVM提供对线程安全的支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Singleton firstSingleton = Singleton.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>常见的原则有7个，如下：</p>
<table>
<thead>
<tr>
<th align="center">原则</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单一职责</td>
<td align="center">一个类、模块应该负责<strong>一项职责</strong></td>
</tr>
<tr>
<td align="center">里氏替换原则</td>
<td align="center">父类的引用可以被子类替换，这样说明子类只是<strong>对父类的扩展</strong>，尽量不要替换父类的功能</td>
</tr>
<tr>
<td align="center">依赖倒置原则</td>
<td align="center">上层模块不依赖于底层模块，两者都应该依赖于抽象；抽象不依赖于细节，细节应该依赖抽象；它的实质就是<strong>针对接口编程</strong></td>
</tr>
<tr>
<td align="center">接口隔离原则</td>
<td align="center">接口应该尽量细化，不能过于臃肿，防止强迫客户使用某些接口</td>
</tr>
<tr>
<td align="center">迪米特法则</td>
<td align="center">一个对象应该对其他对象尽可能少的了解，减少类之间的耦合</td>
</tr>
<tr>
<td align="center">开放-封闭原则</td>
<td align="center">模块对扩展开放，对修改封闭</td>
</tr>
<tr>
<td align="center">组合/聚合原则</td>
<td align="center">多使用组合/聚合的方式来完成某些行为、动作，而不是继承的方式</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>当需要让一个对象的方法模仿成另一个对象的方法时，我们可以让第一个对象中持有第二个对象</p>
<p>然后调用具体方法时，调用第二个对象的方法。</p>
<p><strong>主要元素</strong></p>
<ul>
<li><p><strong>Target</strong></p>
<p>客户期望得到的接口</p>
</li>
<li><p><strong>Adaptee</strong></p>
<p>已经存在的，需要适配的类</p>
</li>
<li><p><strong>Adapter</strong></p>
<p>把源接口转化成目标接口</p>
</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/image-20201117020248795.png" alt="img"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>把对象组合成树形结构，表示整体和部分，从而能够处理单独一个对象或者是一个组合对象。</p>
<p><strong>主要元素</strong></p>
<ul>
<li><p><strong>组件</strong></p>
<p>父类，提供抽象方法</p>
</li>
<li><p><strong>组合</strong></p>
<p>子类，拥有多个组件对象，表示整体</p>
</li>
<li><p><strong>叶子</strong></p>
<p>子类，表示部分</p>
</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png" alt="img"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>把对象的实现和抽象分离开来。</p>
<p>方式就是有两个抽象类，其中一个类中存有另一个类的对象，然后又带有该抽象类的方法</p>
<p><strong>主要对象</strong></p>
<ul>
<li><p><strong>Abstraction</strong></p>
<p>抽象类，带有另一个抽象类的对象和方法</p>
</li>
<li><p><strong>RedinedAbstraction</strong></p>
</li>
<li><p><strong>Implementor</strong></p>
<p>实现接口类，另一个类所持有</p>
</li>
<li><p><strong>ConcreteImplementor</strong></p>
</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png" alt="img"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82/</url>
    <content><![CDATA[<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>提供统一的接口来访问子系统中的一群接口</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/f9978fa6-9f49-4a0f-8540-02d269ac448f.png" alt="img"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>通过另一个对象来存放当前对象的一些状态，然后在需要时，可以从备份中恢复到上一个状态</p>
<p><strong>相关元素</strong></p>
<ul>
<li>Originator：原始对象</li>
<li>Caretaker：负责保存好备忘录</li>
<li>Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/50678f34-694f-45a4-91c6-34d985c83fee.png" alt="img"></p>
<p><strong>例子：</strong>计算器保存上一次的两个数到备忘录中，在需要时可以直接回滚。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83/</url>
    <content><![CDATA[<h2 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h2>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2021/12/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85/</url>
    <content><![CDATA[<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>把多个对象之间复杂的依赖关系，转化为统一对一个对象的依赖。</p>
<p>把对象都集中在中介者这里，通过它来调用相应方法。</p>
<p><strong>主要元素</strong></p>
<ul>
<li><p><strong>Mediator</strong></p>
<p>抽象的中介者类</p>
</li>
<li><p><strong>ConcreteMediator</strong></p>
<p>中介者子类，带有<code>ConcreteColleague</code>对象，通过这些对象来调用方法</p>
</li>
<li><p><strong>Colleague</strong></p>
<p>抽象的同事类</p>
</li>
<li><p><strong>ConcreteColleagur</strong></p>
<p>同事子类，重写具体方法</p>
</li>
</ul>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/30d6e95c-2e3c-4d32-bf4f-68128a70bc05.png" alt="img"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>原码、反码和补码</title>
    <url>/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/</url>
    <content><![CDATA[<h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p><strong>符号位 + 数值</strong></p>
<p>例如：</p>
<p>+3的原码为<code>00000011</code></p>
<p>-3的原码为<code>10000011</code></p>
<p>其中第一位表示<strong>符号位</strong>，0为正，1为负；后面表示<strong>真值的绝对值</strong></p>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p><strong>正数：和原码一致，保持不变</strong></p>
<p><strong>负数：符号位不变，其余位取反</strong></p>
<p>例如：</p>
<p>+3的反码为<code>00000011</code></p>
<p>-3的反码为<code>11111100</code></p>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p><strong>正数：和原码一致，保持不变</strong></p>
<p><strong>负数：反码基础上+1，或者说，符号位不变，其余位取反后，末位加1</strong></p>
<p>例如：</p>
<p>+3的补码为<code>00000011</code></p>
<p>-3的补码为<code>11111101</code></p>
<h4 id="为什么要有补码？"><a href="#为什么要有补码？" class="headerlink" title="为什么要有补码？"></a>为什么要有补码？</h4><p>首先，看完上面三个概念，我们应该最容易理解原码</p>
<p><strong>而对计算机来说，还要在最前面判断符号位是一件挺麻烦的事，既耗时又浪费了符号所在位的空间。</strong></p>
<p>于是人们开始思考能让符号也参与到运算中来，而不是在计算前就要判断正负</p>
<p><strong>那么先来看看正数和负数的原码相加会有什么结果</strong></p>
<p>00000011</p>
<p>10000011</p>
<p>得到 10000100，这个值转换为十进制就是<code>-4</code></p>
<p>而<code>+3</code>与<code>-3</code>相加，答案理应是<code>0</code>才对</p>
<p><strong>原码不行，那么我们再来试试反码</strong></p>
<p>00000011</p>
<p>11111100</p>
<p>得到11111111，注意这是反码表示的，把结果转换成原码就是<code>10000000</code>，即<code>-0</code></p>
<p>但是这样还是有个问题，即计算结果的符号位没有意义</p>
<p><strong>于是补码就出现了</strong></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>面试题记录</title>
    <url>/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h4 id="一、TCP三次握手的过程"><a href="#一、TCP三次握手的过程" class="headerlink" title="一、TCP三次握手的过程"></a>一、TCP三次握手的过程</h4><h6 id="1-符号说明"><a href="#1-符号说明" class="headerlink" title="1.符号说明"></a>1.符号说明</h6><ul>
<li>ACK：确认标志，请求连接时为0，连接建立后所有发送的报文的ACK必须为1</li>
<li>SYN：同步序列号，只在三次握手建立连接时有效，值为1</li>
<li>ISN ：初始序列号，由生成器生成一个32位的ISN，生成器用32位长的时钟，每隔一段时间增长一次，大约<strong>5小时</strong>会重新循环。而数据包的默认最大寿命<strong>MSL</strong>为<strong>2分钟</strong>，所以可以认为初始序列号是唯一的</li>
</ul>
<h6 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h6><p>假设客户端和服务器的初始序列号分别为X，Y</p>
<ol>
<li><p>客户端发送建立连接请求，<code>SYN = 1，seq = X</code></p>
</li>
<li><p>服务器收到请求并回复，<code>SYN = 1，ack = X + 1，seq= Y</code></p>
</li>
<li><p>客户端收到回复，并告诉服务器我收到了 <code>SYN = 0，ack = Y + 1，seq = X + 1，</code></p>
</li>
</ol>
<p>三次握手可以理解为</p>
<ol>
<li>客户端 - &gt; 服务器  SYN，my ISN is X</li>
<li>服务器 - &gt; 客户端  ACK，your ISN is X</li>
<li>服务器 - &gt; 客户端  SYN，my ISN is Y</li>
<li>客户端 - &gt; 服务器  ACK，your ISN is Y</li>
</ol>
<p>其中2，3 可以合并</p>
<h4 id="二、为什么要进行三次握手，而不用两次或四次？"><a href="#二、为什么要进行三次握手，而不用两次或四次？" class="headerlink" title="二、为什么要进行三次握手，而不用两次或四次？"></a>二、为什么要进行三次握手，而不用两次或四次？</h4><p>目的是建立可靠的通信信道，同时避免资源浪费。</p>
<p>如果是采用两次握手的话，只保证了客户端的发送和接受，而服务器不知道它发出的报文是否被客户端接受到。</p>
<p>而三次握手则保证了服务器和客户端的发送接收都没有问题。</p>
<p>四次握手的话会浪费更多的网络资源</p>
<h4 id="三、第二次握手为什么要传回SYN？"><a href="#三、第二次握手为什么要传回SYN？" class="headerlink" title="三、第二次握手为什么要传回SYN？"></a>三、第二次握手为什么要传回SYN？</h4><p>第二次握手既传了ACK，又传了SYN。</p>
<p>传ACK是为了告诉发送方，我收到了你发送的信息，这表明客户端到服务器的通信是正常的。</p>
<p>而回传SYN则是为了建立并确认服务端到客户端的通信。</p>
<h4 id="四、四次挥手的过程"><a href="#四、四次挥手的过程" class="headerlink" title="四、四次挥手的过程"></a>四、四次挥手的过程</h4><ol>
<li>客户端向服务器发起<code>FIN请求</code></li>
<li>服务器收到断开连接请求后，并没有立即关闭，而是先发送<code>ACK应答报文</code>，通知客户端，它已经收到请求</li>
<li>服务器等待资源发送完毕，再发出<code>FIN报文</code></li>
<li>客户端收到服务器的FIN报文后，发出<code>ACK确认报文</code>给服务器，并开始计时，在<strong>2MSL（max segment lifetime）</strong>后关闭连接</li>
</ol>
<h4 id="五、为什么连接的时候是三次握手，关闭的时候却是四次挥手？"><a href="#五、为什么连接的时候是三次握手，关闭的时候却是四次挥手？" class="headerlink" title="五、为什么连接的时候是三次握手，关闭的时候却是四次挥手？"></a>五、为什么连接的时候是三次握手，关闭的时候却是四次挥手？</h4><p>因为在三次握手的时候，服务器接收到客户端的连接请求时，可以立即发出ACK应答报文并请求建立连接</p>
<p>而在四次挥手过程中，服务器接收到客户端的FIN请求，它可能还有数据包还没发送完，只能先返回ACK报文来应答，等数据包发送完之后，才能返回FIN请求给客户端。</p>
<h4 id="六、TIME-WAIT状态为什么要定义为2MSL？"><a href="#六、TIME-WAIT状态为什么要定义为2MSL？" class="headerlink" title="六、TIME_WAIT状态为什么要定义为2MSL？"></a>六、TIME_WAIT状态为什么要定义为2MSL？</h4><ol>
<li><p>尽可能能的确保最后的ACK报文顺利到达服务器</p>
<p> 第四次握手时，客户端向服务器发送的ACK报文可能会丢失，服务器收不到ACK报文，就会进行超时重传FIN</p>
<p> <strong>补充：</strong>那么为什么不把时间设置成<strong>RTT（报文从发送到接受再到确认的一次往返时间）</strong></p>
<p> <strong>答：</strong>即第二点理由</p>
</li>
<li><p>为了确保老的重复的报文段消失在网络中</p>
</li>
<li><p>一些路由器会缓存数据包，TIME_WAIT可以有效地应对这种情况</p>
</li>
</ol>
<h4 id="七、TCP三次握手可以传递数据吗？"><a href="#七、TCP三次握手可以传递数据吗？" class="headerlink" title="七、TCP三次握手可以传递数据吗？"></a>七、TCP三次握手可以传递数据吗？</h4><p>前两次不可以，因为此时连接还没建立。</p>
<p>第三次可以，因为客户端收到服务器传来的ACK报文后，处于建立连接的状态，并且知道服务器接收和发送能力是正常的，所以可以传递数据。</p>
<h4 id="八、TCP如果没有完成第四次挥手会发生什么？"><a href="#八、TCP如果没有完成第四次挥手会发生什么？" class="headerlink" title="八、TCP如果没有完成第四次挥手会发生什么？"></a>八、TCP如果没有完成第四次挥手会发生什么？</h4><p>服务器端的重传计时器达到规定时间片，依旧没有收到来自客户端的ACK报文，就开始进行超时重传，重新发送FIN报文给客户端。</p>
<h4 id="九、计网五层模型和七层模型（应用层协议有哪些）"><a href="#九、计网五层模型和七层模型（应用层协议有哪些）" class="headerlink" title="九、计网五层模型和七层模型（应用层协议有哪些）"></a>九、计网五层模型和七层模型（应用层协议有哪些）</h4><p>五层模型，从上到下：</p>
<ul>
<li><strong>应用层</strong>——<strong>DNS、HTTP</strong>、SMTP、FTP、telnet</li>
</ul>
<p>提供应用进程间的服务</p>
<ul>
<li><strong>传输层</strong>——<strong>TCP、UDP</strong></li>
</ul>
<p>提供端到端的通信</p>
<p>即数据传输路径中最两端的两台网络设备之间的通信</p>
<ul>
<li><strong>网络层</strong>——<strong>IP</strong>、ARP、ICMP、IGMP</li>
</ul>
<p>路由、寻址，把数据包传送到目的地</p>
<ul>
<li><strong>数据链路层</strong>——PPP、CSMA/CD</li>
</ul>
<ul>
<li><strong>物理层</strong>——电路交换、分组交换</li>
</ul>
<p><strong>透明</strong>地传输比特流，<strong>透明</strong>即让上层感受不到传输介质、接口光纤不同所带来的变化</p>
<p>七层模型：多了两层，表示层和会话层</p>
<h4 id="十、浏览器输入URL后发生了什么？（使用了哪些协议）"><a href="#十、浏览器输入URL后发生了什么？（使用了哪些协议）" class="headerlink" title="十、浏览器输入URL后发生了什么？（使用了哪些协议）"></a>十、浏览器输入URL后发生了什么？（使用了哪些协议）</h4><ol>
<li><strong>DNS解析</strong></li>
</ol>
<p>根据域名，在<strong>浏览器缓存、系统缓存、路由器缓存</strong>等依次向上查找。</p>
<p>另外，<strong>DNS重定向/负载均衡</strong></p>
<ol start="2">
<li><strong>建立TCP连接</strong></li>
</ol>
<p>三次握手</p>
<ol start="3">
<li><strong>发送HTTP请求</strong></li>
</ol>
<p>因为HTTP请求是明文，存在信息泄露的风险。</p>
<p>所以采用HTTPS协议进行加密（HTTP + SSL）</p>
<ol start="4">
<li><p><strong>服务器处理请求并返回HTTP报文</strong></p>
</li>
<li><p><strong>浏览器解析渲染页面</strong></p>
</li>
</ol>
<p>浏览器边解析边渲染</p>
<p>解析HTML和CSS文件，得到DOM树和渲染树</p>
<p>然后布局渲染树，并把它绘制到屏幕上</p>
<h6 id="协议："><a href="#协议：" class="headerlink" title="协议："></a>协议：</h6><p>1.DNS    解析域名，获得ip地址</p>
<p>2.TCP     与服务器建立连接</p>
<p>3.IP        使用TCP建立连接时，网络层用到了IP协议</p>
<p>4.OSPF  进行路由选择</p>
<p>5.ARP     路由器与服务器通信时，根据ip地址得到MAC地址</p>
<p>6.HTTP   发送网页数据的请求</p>
<h4 id="十一、TCP和UDP的区别"><a href="#十一、TCP和UDP的区别" class="headerlink" title="十一、TCP和UDP的区别"></a>十一、TCP和UDP的区别</h4><p>TCP：可靠、需要建立连接、消耗资源较多</p>
<p>UDP：不保证数据的正确，无连接，消耗资源少，程序结构简单</p>
<h4 id="十二、TCP的可靠传输"><a href="#十二、TCP的可靠传输" class="headerlink" title="十二、TCP的可靠传输"></a>十二、TCP的可靠传输</h4><h5 id="（一）如何确保可靠性传输："><a href="#（一）如何确保可靠性传输：" class="headerlink" title="（一）如何确保可靠性传输："></a>（一）如何确保可靠性传输：</h5><p>使用超时重传来实现可靠传输，如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<h5 id="（二）拥塞控制："><a href="#（二）拥塞控制：" class="headerlink" title="（二）拥塞控制："></a>（二）拥塞控制：</h5><blockquote>
<p>发送方维护变量<strong>拥塞窗口（cwnd）</strong>，出现拥塞时，控制发送方的发送速率，算法如下：</p>
</blockquote>
<p><strong>1.慢开始</strong> 从发送1个报文段开始，如果该报文段被接受，就把数量*2</p>
<p>**2.拥塞避免 **慢开始会增长地很快，当cwnd大于门限时，每次只增1</p>
<p>如果出现了超时，就将门限设置为cwnd / 2，然后cwnd = 1，重新执行满开始</p>
<p><strong>3.快重传与快恢复</strong></p>
<blockquote>
<p>接收方收到的报文段应该是有序的，例如M1，M2收到，又来了个M4，这时候接收方发送对M2的确认</p>
</blockquote>
<p>一旦发送方收到三个重复的确认，就可以判定下一个报文段丢失，立刻重传</p>
<p>出现快重传后，网络并没有拥塞，只是丢失了个别报文段，因此执行快恢复。</p>
<p>即把cwnd的值设置的大一些，具体操作为：</p>
<p>门限 / 2，cwnd = 门限，这表示直接进入拥塞避免状态。</p>
<h5 id="（三）TCP传输时，客户端突然断开连接，服务器如何判定？"><a href="#（三）TCP传输时，客户端突然断开连接，服务器如何判定？" class="headerlink" title="（三）TCP传输时，客户端突然断开连接，服务器如何判定？"></a>（三）TCP传输时，客户端突然断开连接，服务器如何判定？</h5><p>利用TCP协议层提供的保活探测方法来判定</p>
<h5 id="（四）TCP的端口是为了区分什么？"><a href="#（四）TCP的端口是为了区分什么？" class="headerlink" title="（四）TCP的端口是为了区分什么？"></a>（四）TCP的端口是为了区分什么？</h5><p>区分一台设备中的不同应用进程</p>
<h4 id="十三、常见的HTTP状态码"><a href="#十三、常见的HTTP状态码" class="headerlink" title="十三、常见的HTTP状态码"></a>十三、常见的HTTP状态码</h4><p>200，204（没有实体内容），206（部分内容）</p>
<p>301（永久重定向），302（临时），303（临时，必须用GET请求），304（客户端发送附带条件，条件满足后的返回内容），307（临时）</p>
<p>400（请求报文错误），401（需要HTTP认证），403（没有访问服务器的权限），404（没找到资源）</p>
<p>500（服务器出错），503（服务器处于维护或超负载状态）</p>
<h4 id="十四、HTTP报文"><a href="#十四、HTTP报文" class="headerlink" title="十四、HTTP报文"></a>十四、HTTP报文</h4><h5 id="（一）请求报文和响应报文的组成"><a href="#（一）请求报文和响应报文的组成" class="headerlink" title="（一）请求报文和响应报文的组成"></a>（一）请求报文和响应报文的组成</h5><p>请求报文由<strong>请求行、请求首部、请求实体</strong>组成</p>
<p>响应报文由<strong>状态行、响应首部、响应实体</strong>组成</p>
<h5 id="（二）HTTP请求报文包含哪些方法，GET和POST的区别"><a href="#（二）HTTP请求报文包含哪些方法，GET和POST的区别" class="headerlink" title="（二）HTTP请求报文包含哪些方法，GET和POST的区别"></a>（二）HTTP请求报文包含哪些方法，GET和POST的区别</h5><p><strong>方法</strong>有get，post，head，put，delete，options，trace，connect</p>
<p><strong>区别：</strong></p>
<p>1.GET用来获取资源，不会修改服务器的数据</p>
<p>而POST用来传输实体，可能会修改数据</p>
<p>2.GET的请求参数会附在URL之后，参数大小有限制</p>
<p>而POST参数是放在请求实体中</p>
<h4 id="十五、HTTP和HTTPS的区别"><a href="#十五、HTTP和HTTPS的区别" class="headerlink" title="十五、HTTP和HTTPS的区别"></a>十五、HTTP和HTTPS的区别</h4><p><strong>区别：</strong></p>
<ol>
<li>明文，安全性</li>
<li>需要证书，费用不同</li>
<li>连接方式不同</li>
</ol>
<p><strong>补充：</strong></p>
<ul>
<li>HTTPS使用混合加密机制</li>
</ul>
<blockquote>
<p>服务器持有公钥 A 和私钥 A’</p>
<p>客户端发起连接，服务器把 A 发送给客户端</p>
<p>客户端接收 A ，本地再生成一个对称密钥 X ，用 A 加密 X ，发送给服务器</p>
<p>服务器用 A‘ 解密，得到对称密钥 X</p>
<p>然后双方用 X 加密报文进行通信</p>
</blockquote>
<ul>
<li>数字证书</li>
</ul>
<blockquote>
<p>混合加密机制也有漏洞。</p>
<p>如果遇到“中间人攻击”，即中间人劫持服务器发送的公钥，换成自己的</p>
<p>所以需要让客户端判断它收到的公钥是否是服务器的，而不是中间人篡改后的</p>
<p>于是CA机构就出现了，网站向该机构申请数字证书，把公钥写入证书中，把证书传给客户端就可以了。</p>
</blockquote>
<ul>
<li>数字签名</li>
</ul>
<blockquote>
<p>证书也可能被篡改，所以就需要签名来判断证书是否为真。</p>
<p>签名制作：（CA持有一对非对称密钥）</p>
<ol>
<li><p>CA对证书明文进行hash</p>
</li>
<li><p>hash后的值进行私钥加密，得到签名</p>
</li>
</ol>
<p>浏览器判定：（浏览器持有CA公钥）</p>
<ol>
<li>用公钥解密签名</li>
<li>根据证书说明的hash算法对明文hash</li>
<li>比较前两者的值是否相等</li>
</ol>
</blockquote>
<h4 id="十六、HTTP1-0、1-1和2-0的区别"><a href="#十六、HTTP1-0、1-1和2-0的区别" class="headerlink" title="十六、HTTP1.0、1.1和2.0的区别"></a>十六、HTTP1.0、1.1和2.0的区别</h4><p><strong>1.0与1.1：</strong>1.1默认使用长连接，支持流水线的请求</p>
<p><strong>2.0和1.x相比：</strong></p>
<ul>
<li>支持多路复用</li>
</ul>
<blockquote>
<p>能够在一个连接中并发处理多个请求</p>
</blockquote>
<ul>
<li>头部数据压缩（开始行 + 首部。主体一般都是压缩的）</li>
</ul>
<blockquote>
<p>客户端和服务器同时维护一个缓存表，避免重复传输</p>
<p>此外，利用哈夫曼编码压缩首部字段</p>
</blockquote>
<ul>
<li>服务端推送</li>
</ul>
<blockquote>
<p>客户端请求资源时，会把相关资源（JS，CSS等）一起发送给客户端</p>
</blockquote>
<ul>
<li>二进制、分帧层</li>
</ul>
<blockquote>
<p>1.x是用文本协议的格式解析的，2.0采用二进制解析</p>
<p>把报文分成headers和data帧</p>
</blockquote>
<ul>
<li>总结</li>
</ul>
<p>数据流共用一个连接，提高了TCP的利用率，同时也降低了延迟。</p>
<h4 id="十七、HTTP的缓存机制"><a href="#十七、HTTP的缓存机制" class="headerlink" title="十七、HTTP的缓存机制"></a>十七、HTTP的缓存机制</h4><p>介绍：</p>
<p>①Expires：过期时间</p>
<p>②Cache-Control：public，private，max-age，no-cache（不建议缓存，但还是有，相当于最大存活时间为0），no-store（不缓存），会覆盖①</p>
<p>③Last-Modified / If-Modified-Since：最后修改时间</p>
<p>④Etag / If-None-Match：唯一标识，如果修改了就会变化，优先级大于③</p>
<ul>
<li>存储策略</li>
</ul>
<blockquote>
<p>服务器响应客户端的第一次请求时，缓存协商。</p>
<p>可以是1234的任意一个（甚至多个）</p>
</blockquote>
<ul>
<li>过期策略</li>
</ul>
<blockquote>
<p>客户端想要请求资源时，判断有无缓存，有缓存的话是否过期。</p>
</blockquote>
<ul>
<li>对比策略</li>
</ul>
<blockquote>
<p>如果请求头里有If-Modified-Since，就比较修改时间</p>
<p>如果请求头里有If-None-Match，就查找是否有Etag等于该值的数据</p>
<p>缓存没有过期的话，返回304；过期的话，重新进行缓存协商，并返回200和新的数据</p>
</blockquote>
<h4 id="十八、什么是cookie和session，区别是什么，禁用cookie怎么办？"><a href="#十八、什么是cookie和session，区别是什么，禁用cookie怎么办？" class="headerlink" title="十八、什么是cookie和session，区别是什么，禁用cookie怎么办？"></a>十八、什么是cookie和session，区别是什么，禁用cookie怎么办？</h4><p>cookie和session都是会话跟踪的技术</p>
<p>cookie是保存在客户端的，在发送请求时携带cookie，服务器可以根据cookie跟踪会话</p>
<p>session是保存在服务端的。客户端第一次请求时，在服务器生成的一小块区域，然后服务器把session_id发给客户端，接下来的请求都带上session_id</p>
<p>区别：</p>
<ol>
<li>存放的位置不同</li>
<li>请求过多时，session会影响服务器性能</li>
<li>单个cookie保存的数据有大小限制，浏览器一般也有数量限制</li>
</ol>
<h4 id="十九、页面加载不出来的原因"><a href="#十九、页面加载不出来的原因" class="headerlink" title="十九、页面加载不出来的原因"></a>十九、页面加载不出来的原因</h4>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>计网——链路层</title>
    <url>/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>结点：主机、路由器</p>
<p>链路：两个结点之间的物理通道</p>
<p>数据链路：逻辑通道，链路加上硬件软件</p>
<p>帧：链路层的协议数据单元，封装了网络层数据包</p>
<h2 id="一、封装成帧"><a href="#一、封装成帧" class="headerlink" title="一、封装成帧"></a>一、封装成帧</h2><h3 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h3><blockquote>
<p>在一段数据的前后添加首部和尾部，形成帧</p>
<p>接收方收到物理层的比特流后，可以根据首部尾部的标记，识别出帧的开始和结束位置</p>
</blockquote>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/12844.png" alt="12844"></p>
<h3 id="2-区分帧的几种方法"><a href="#2-区分帧的几种方法" class="headerlink" title="2. 区分帧的几种方法"></a>2. 区分帧的几种方法</h3><ul>
<li><p><strong>字符计数法</strong></p>
<p>帧首部用第一个字节表示这个帧的长度</p>
<p>发生错误后影响之后所有的帧</p>
</li>
<li><p><strong>字符填充法</strong></p>
<p>特定的首部尾部来作为界限，中间如果遇到同名的，填充字节来转义</p>
</li>
<li><p><strong>零比特填充法</strong></p>
<p>发送方根据规则填充0，然后接收方去掉首部尾部后，对数据按规则删除0</p>
</li>
<li><p><strong>违规编码法</strong></p>
<p>用独特的电压来表示首部尾部</p>
</li>
</ul>
<h2 id="二、差错检验"><a href="#二、差错检验" class="headerlink" title="二、差错检验"></a>二、差错检验</h2><h3 id="1-错误有哪些？"><a href="#1-错误有哪些？" class="headerlink" title="1. 错误有哪些？"></a>1. 错误有哪些？</h3><ul>
<li>位错，比特位发生变动</li>
<li>帧错，帧丢失、重复、乱序等</li>
</ul>
<p>错误来源于外界的冲击噪声或者随机噪声（热噪声）。</p>
<h3 id="2-差错控制方法"><a href="#2-差错控制方法" class="headerlink" title="2. 差错控制方法"></a>2. 差错控制方法</h3><p>这里主要针对比特错，即位错。</p>
<p>相应的解决方法有两类，<strong>检错编码</strong>和<strong>纠错编码</strong>，顾名思义，一个是检查错误，一个是纠正错误。</p>
<h3 id="3-检错编码"><a href="#3-检错编码" class="headerlink" title="3. 检错编码"></a>3. 检错编码</h3><p>这里都用到了<code>冗余编码</code>的思想，即发送时在数据前面加上一段比特，接收方根据它来判断数据是否变化</p>
<p><strong>『奇偶校验码』</strong></p>
<p>冗余码：只使用1位，取0或1</p>
<p>冗余码取值：满足<code>数据+冗余码</code>中<code>1</code>的个数是奇数还是偶数（奇校验还是偶校验）</p>
<p>思想：约定奇或偶校验，然后发生方设置冗余码并满足校验，接收方收到后判断1的个数是否和约定的校验方式相符。</p>
<p>例如，现有数据编码<code>1100101</code>，采用偶校验的话，要保证添加冗余码后有偶数个1，所以冗余码选择0就可以，编码后为<code>01100101</code></p>
<p><strong>特点：只能检测出奇数位发生错误的情况</strong></p>
<p><strong>『循环冗余码CRC』</strong></p>
<p>冗余码：有多位，根据计算得到。</p>
<p>思想：</p>
<ol>
<li>约定一个多项式</li>
<li>数据比特在末尾添<code>阶数</code>个0</li>
<li>添零后的数据与多项式进行模2除法，得到冗余码并填充在末尾的0中</li>
<li>接收方让数据除以约定的多项式，除尽了说明没错</li>
</ol>
<p>图片描述</p>
<p>发送方计算冗余码</p>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/Snipaste_2021-04-29_22-11-00.png" alt="Snipaste_2021-04-29_22-11-00"></p>
<p>接收方校验</p>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/20210429230102.png"></p>
<h3 id="4-纠错编码"><a href="#4-纠错编码" class="headerlink" title="4. 纠错编码"></a>4. 纠错编码</h3><p>纠错编码介绍一个叫做<code>海明码</code>的方法。</p>
<blockquote>
<p>海明码是广泛用于内存和磁盘纠错的编码。</p>
</blockquote>
<ol>
<li><p><strong>首先先要知道冗余码的位数</strong></p>
<p>通过<code>海明不等式</code>来确定</p>
<p>根据  $n + r \leq\ 2^r - 1$计算得到，其中n表示数据位数，r表示冗余码位数。</p>
</li>
<li><p><strong>确定校验码和数据的位置</strong></p>
<p>把校验码依次放在$2^i$的位置，然后数据依次填充。</p>
</li>
<li><p><strong>计算冗余码的值</strong></p>
<p>需要分组，按<code>XXX1</code>、<code>XX1X</code>、<code>X1XX</code>、<code>1XXX</code>来分组</p>
<p>然后冗余位的取值要满足该组的1的个数为偶数</p>
<p>PS：冗余位取值，可以用<code>异或后结果为0</code>来计算</p>
</li>
<li><p><strong>接收方判断</strong></p>
<p>收到数据后，进行分组并重新计算每组的异或值</p>
<p>将值<code>倒序</code>排列，得到的十进制即出错的位置。</p>
</li>
</ol>
<h2 id="三、流量控制"><a href="#三、流量控制" class="headerlink" title="三、流量控制"></a>三、流量控制</h2><blockquote>
<p>思想：当发送方发送的帧太多，以致接收方来不及处理的时候，接收方就不进行回复确认，来达到<strong>控制发送方速率</strong>的目的</p>
</blockquote>
<h3 id="流量控制的方法"><a href="#流量控制的方法" class="headerlink" title="流量控制的方法"></a>流量控制的方法</h3><p>主要思想是<code>滑动窗口</code>，发送方维持一个<code>固定</code>的窗口，发送帧之后，接收方回复确认，发送方收到确认消息后，更新窗口中的帧。</p>
<p>与流量控制相关的协助主要有3种，分别是<strong>停止-等待协议</strong>、<strong>后退N帧协议</strong>和<strong>选择重传协议</strong>。</p>
<p>下面就依次介绍一下。</p>
<h3 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h3><p>在<code>停止-等待协议</code>中，发送方发送一个帧，就会停下来等待确认消息，收到确认后再发送下一个帧。</p>
<p>如果在超时时间内没有收到确认消息，就进行重传。</p>
<p>懂得都懂，这样做发送方大部分时间都在等待，信道利用率比较低！</p>
<h4 id="优化思想"><a href="#优化思想" class="headerlink" title="优化思想"></a>优化思想</h4><blockquote>
<p>思考：为什么要一帧一帧地发送？可以发送多个帧吗？多个帧发送，又会涉及到顺序的问题</p>
</blockquote>
<p>针对以上思考，我们提出两种优化思路：</p>
<ol>
<li>为帧添加序号</li>
<li>多个帧一起发送</li>
</ol>
<p>后面介绍的两种协议就采用了这些思路。</p>
<h3 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h3><p><strong>主要思想：发送方维持一个大于1的滑动窗口，每收到一个ACK，移动窗口；接收方维持大小为1的窗口，逐个接收</strong></p>
<p><strong>特点：</strong></p>
<ul>
<li><p>累计确认</p>
<p>一旦确认某个帧被接收，那么该帧的前面所有帧也都是确定被接收方收到的</p>
</li>
<li><p>超时重传机制</p>
<p>超时时发送方发送所有未确认的帧</p>
</li>
</ul>
<p><strong>例子：</strong>假设有编号为0~7的帧，现在发送方收到了0，2，3帧的ACK，如果这时产生了超时，要重新发送些帧</p>
<p><strong>答案：</strong>4，5，6，7</p>
<p><strong>缺点：</strong>重传时，要把未确认的帧全都重新传一遍，没有必要</p>
<p>下一个协议就避免了这一缺点。</p>
<h3 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h3><p><strong>主要思想：发送方维持一个大于1的滑动窗口，每收到一个ACK，移动窗口；接收方维持同样大小的窗口，缓存接收</strong></p>
<p>注意，因为SR协议接收方窗口大小不为1，所以遇到不连续的数据，它是可以先缓存接收的；等到前面的数据也收到后，就形成连续的帧号，窗口就可以移动了。这和GBN只能接收当前一个帧，不连续就丢弃的情况不同。</p>
<h2 id="四、其他协议"><a href="#四、其他协议" class="headerlink" title="四、其他协议"></a>四、其他协议</h2><h3 id="1-ALOHA"><a href="#1-ALOHA" class="headerlink" title="1.ALOHA"></a>1.ALOHA</h3><p>想发数据就发</p>
<h3 id="2-CSMA"><a href="#2-CSMA" class="headerlink" title="2.CSMA"></a>2.CSMA</h3><p>先监听信道，看看拥不拥挤再发</p>
<h3 id="3-CSMA-CD"><a href="#3-CSMA-CD" class="headerlink" title="3.CSMA/CD"></a>3.CSMA/CD</h3><p>一边监听一边发，如果拥挤了就停下来</p>
<h3 id="4-CSMA-CA"><a href="#4-CSMA-CA" class="headerlink" title="4.CSMA/CA"></a>4.CSMA/CA</h3><p>先听后发，适用于传输介质为无线局域网的，所以更常用。</p>
<h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><p>覆盖范围从几十公里到几千公里的网络，它是通过<code>交换机</code>来交换分组的。</p>
<p>顺便一提，路由器是网络层的设备，也是用来进行分组交换的，两者的区别在于交换机只能在单个网络中转发分组，而路由器能在多个网络中转发分组。</p>
<h3 id="5-PPP协议（点对点协议）"><a href="#5-PPP协议（点对点协议）" class="headerlink" title="5.PPP协议（点对点协议）"></a>5.PPP协议（点对点协议）</h3><p>面向字节</p>
<p>用户使用拨号电路接入因特网时，一般使用PPP协议。</p>
<h3 id="6-HDLC协议"><a href="#6-HDLC协议" class="headerlink" title="6.HDLC协议"></a>6.HDLC协议</h3><p>在同步网上传输数据，面向比特的数据链路层协议</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计网——物理层</title>
    <url>/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h3 id="一、通信方式"><a href="#一、通信方式" class="headerlink" title="一、通信方式"></a>一、通信方式</h3><h4 id="1-单工通信"><a href="#1-单工通信" class="headerlink" title="1. 单工通信"></a>1. 单工通信</h4><p>只能从一个方向通信，并且不会有反方向的交互</p>
<p>只需要一条信道</p>
<h4 id="2-半双工通信"><a href="#2-半双工通信" class="headerlink" title="2. 半双工通信"></a>2. 半双工通信</h4><p>通信双方都可以发送或接收消息，但是一时间内只能有一个在发送，另一个在接收；任何一方都不能同时进行发送和接收。</p>
<p>所以需要两条信道。</p>
<h4 id="3-全双工通信"><a href="#3-全双工通信" class="headerlink" title="3. 全双工通信"></a>3. 全双工通信</h4><p>通信双方都可以同时发送或接受消息</p>
<p>需要两条信道。</p>
<h3 id="二、数据传输方式"><a href="#二、数据传输方式" class="headerlink" title="二、数据传输方式"></a>二、数据传输方式</h3><p>串行传输：直接传输一串比特</p>
<p>并行传输：把一串比特分成多份，同时传输</p>
<p>区别：可从<strong>成本</strong>、<strong>适用距离</strong>、<strong>速度</strong>等方面考虑</p>
<h3 id="三、编码与调制"><a href="#三、编码与调制" class="headerlink" title="三、编码与调制"></a>三、编码与调制</h3><p><strong>信道：</strong>信号的传输媒介</p>
<p>信道按传输信号不同，可分为<strong>模拟信道</strong>和<strong>数字信道</strong>，它们分别传输模拟信号（连续的）和数字信号（离散的，即0，1）</p>
<p><strong>编码：</strong>数字数据转变成数字信号的过程</p>
<p><strong>调制：</strong>数据通过调制器变为模拟信号</p>
<h3 id="四、传输介质"><a href="#四、传输介质" class="headerlink" title="四、传输介质"></a>四、传输介质</h3><h4 id="1-导向性传输介质"><a href="#1-导向性传输介质" class="headerlink" title="1. 导向性传输介质"></a>1. 导向性传输介质</h4><ol>
<li>双绞线</li>
<li>同轴电缆</li>
<li>光纤<ol>
<li>多模光纤</li>
<li>单模光纤</li>
</ol>
</li>
</ol>
<h4 id="2-非导向型传输介质"><a href="#2-非导向型传输介质" class="headerlink" title="2. 非导向型传输介质"></a>2. 非导向型传输介质</h4><ol>
<li>无线电波</li>
<li>微波</li>
<li>红外线、激光</li>
</ol>
<h3 id="五、物理层设备"><a href="#五、物理层设备" class="headerlink" title="五、物理层设备"></a>五、物理层设备</h3><h4 id="1-中继器"><a href="#1-中继器" class="headerlink" title="1. 中继器"></a>1. 中继器</h4><p>再生和还原信号</p>
<h4 id="2-集线器"><a href="#2-集线器" class="headerlink" title="2. 集线器"></a>2. 集线器</h4><p>对信号进行再生放大转发</p>
<hr>
<p>电话通信的例子：</p>
<p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/Snipaste_2021-04-29_20-23-34.png" alt="Snipaste_2021-04-29_20-23-34"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-摘要算法"><a href="#1-摘要算法" class="headerlink" title="1. 摘要算法"></a>1. 摘要算法</h2><p>对<strong>明文</strong>进行hash，生成一段固定长度的密文</p>
<p>有以下几个<strong>特点</strong>：</p>
<ol>
<li>相同的明文，经过相同的摘要算法，得到的密文一定是一样的</li>
<li>摘要算法要尽量<strong>避免碰撞</strong></li>
<li>明文变成密文的过程是<strong>不可逆</strong>的</li>
</ol>
<p>常见的摘要算法有<strong>MD5、SHA</strong></p>
<h2 id="2-对称加密"><a href="#2-对称加密" class="headerlink" title="2. 对称加密"></a>2. 对称加密</h2><p>存在<strong>一个密钥</strong></p>
<blockquote>
<p>明文通过密钥加密，变成密文</p>
</blockquote>
<blockquote>
<p>密文通过密钥解密，得到明文</p>
</blockquote>
<p>如果要保证数据传输的安全性，就得考虑怎样安全的把密钥告知对方</p>
<p>否则一旦密钥泄露，数据就会变得透明</p>
<h2 id="3-非对称加密"><a href="#3-非对称加密" class="headerlink" title="3. 非对称加密"></a>3. 非对称加密</h2><blockquote>
<p>存在<strong>一对密钥</strong>，公钥和私钥</p>
<p>一个来加密，另一个来解密，才能获得原文。</p>
</blockquote>
<p>HTTPS 通信<strong>基础版</strong>：混合加密机制</p>
<p>服务器 S 有一对公钥和私钥，客户端 C 有一个密钥</p>
<ol>
<li><p><code>S</code> 把公钥发给 <code>C</code></p>
</li>
<li><p><code>C</code> 获得公钥后，用公钥加密它自己的密钥，发给 <code>S</code></p>
</li>
<li><p><code>S</code> 收到密文，用私钥解密，得到 <code>C</code> 的密钥</p>
</li>
</ol>
<p>然后双方就可以用对称加密的方式进行通信。</p>
<p><strong>但是……</strong></p>
<p>这样的机制还是会有安全问题</p>
<p>比如客户端判断不出它收到的公钥是服务器发的，还是被<strong>中间人篡改</strong>了的</p>
<p>如果公钥是被中间人篡改过的，那么它就可以<strong>伪装</strong>成服务器，与客户端进行通信</p>
<p>而服务器和客户端都<strong>无法感觉</strong>到这件事。</p>
<h2 id="4-数字签名"><a href="#4-数字签名" class="headerlink" title="4. 数字签名"></a>4. 数字签名</h2><p>基于以上<strong>中间人</strong>的问题，我们又提出了数字签名算法。</p>
<p>它类似于写在纸上的物理签名</p>
<p>数字签名通常是用私钥生成签名，用公钥验证签名</p>
<ol>
<li>发送方利用摘要算法（通常是hash），得到报文摘要，再对其用私钥加密，得到数字签名</li>
<li>然后把数字签名和报文一起发送给接收方</li>
<li>接收方同样对报文进行相同的算法，得到报文摘要</li>
<li>然后用公钥解密数字签名</li>
<li>比较3、4得到的结果是否一样</li>
</ol>
<p>就能够判断是否是发送方发过来的</p>
<h2 id="MD5加盐"><a href="#MD5加盐" class="headerlink" title="MD5加盐"></a>MD5加盐</h2><p><strong>加密过程：</strong></p>
<p>场景：首次向数据库存密码时</p>
<p>过程：</p>
<ol>
<li><p>在本地生成一串随机数（称为<code>盐</code>），并与<code>password</code>相加</p>
</li>
<li><p>根据相加的字符串得到<code>MD5加密</code>后的密文</p>
</li>
<li><p>把<code>盐</code>按一定规则插入到密文中，然后存入数据库</p>
</li>
</ol>
<p><strong>解密过程：</strong></p>
<p>场景：用户输入密码尝试登录</p>
<p>过程：</p>
<ol>
<li>从数据库中读取用户名所对应的<code>密码密文</code></li>
<li>按当时插入的规则取出<code>盐</code></li>
<li>用户此次输入的<code>password</code>加上<code>盐</code>，然后进行<code>MD5加密</code>得到新的密文</li>
<li>新密文与数据库存的密文进行对比即可判断密码是否一致</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>TCP连接</title>
    <url>/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="内容总览"><a href="#内容总览" class="headerlink" title="内容总览"></a>内容总览</h2><p>TCP的内容大致如下：</p>
<ul>
<li><p>TCP基础</p>
</li>
<li><p>连接管理</p>
</li>
<li><p>超时重传机制</p>
</li>
<li><p>滑动窗口与流量控制</p>
</li>
<li><p>拥塞控制</p>
</li>
<li><p>保活机制</p>
</li>
</ul>
<h2 id="TCP基础"><a href="#TCP基础" class="headerlink" title="TCP基础"></a>TCP基础</h2><blockquote>
<p>TCP是一种可靠的、面向连接的协议</p>
</blockquote>
<h3 id="一、IP数据报结构"><a href="#一、IP数据报结构" class="headerlink" title="一、IP数据报结构"></a>一、IP数据报结构</h3><p>IPv4头部20字节、TCP头部20字节，剩下的是数据</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210920183723.png" alt="image-20210920183723024"></p>
<h3 id="二、TCP头部"><a href="#二、TCP头部" class="headerlink" title="二、TCP头部"></a>二、TCP头部</h3><p>头部结构如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210920183503.png" alt="image-20210920183502780"></p>
<h4 id="1-端口"><a href="#1-端口" class="headerlink" title="1.端口"></a>1.端口</h4><p>通过ip头部中的<code>ip地址</code>以及TCP头部的<code>端口号</code>，即可形成一个<code>四元组</code>，标志通信两端。</p>
<h4 id="2-序列号seq"><a href="#2-序列号seq" class="headerlink" title="2.序列号seq"></a>2.序列号seq</h4><p>TCP为报文数据的每个字节都进行了编号，范围为$0\sim2^{32}-1$</p>
<p><strong>序列号含义：</strong>表示这次传输过程中的第一个字节编号</p>
<p><strong>序列号取值：</strong></p>
<ol>
<li>当发送SYN报文时，序列号的值会设置为初始序列号</li>
<li>正常传输时，序列号的值一般等于对方上次发送的ACK值</li>
</ol>
<h4 id="3-确认号ack"><a href="#3-确认号ack" class="headerlink" title="3.确认号ack"></a>3.确认号ack</h4><p><strong>ACK含义：</strong>表示期望接收到的下一个序列号，即下次到来的数据的第一个字节编号</p>
<p>通俗的讲，假如ACK为Y+1，则表示Y号数据包括Y都已经收到，下次想要Y+1。</p>
<h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><p><strong>问题总览</strong></p>
<p>TCP三次握手、四次挥手的过程</p>
<p>为什么要进行三次握手，而不用两次或四次？</p>
<p>第二次握手为什么要传回SYN？</p>
<p>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</p>
<p>TIME_WAIT状态为什么要定义为2MSL？</p>
<p>TCP三次握手可以传递数据吗？</p>
<h3 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h3><blockquote>
<p>三次握手的目的在于交换初始序列号，从而建立通信双方可靠稳定的连接。</p>
</blockquote>
<h4 id="1-符号说明"><a href="#1-符号说明" class="headerlink" title="1.符号说明"></a>1.符号说明</h4><p>介绍下3种标志</p>
<ul>
<li>ACK：确认标志，请求连接时为0，连接建立后所有发送的报文的ACK必须为1</li>
<li>SYN：同步序列号，只在三次握手建立连接时有效</li>
<li>ISN ：初始序列号，由生成器生成一个32位的ISN，生成器用32位长的时钟，每隔一段时间增长一次，大约<strong>5小时</strong>会重新循环。而数据包的默认最大寿命<strong>MSL</strong>为<strong>2分钟</strong>，所以可以认为初始序列号是唯一的</li>
</ul>
<p><strong>序列号保持唯一的作用：</strong>防止同一连接的多个实例错误地接受不属于自己的数据包。（比如用相同的四元组建立两个连接实例，第一个实例关闭后在网络上延迟到达的数据包可能会被第二个实例错误地接收）</p>
<h4 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2.建立连接"></a>2.建立连接</h4><img data-src="https://gitee.com/aurora1004/pictures/raw/master/tcp_1.png" alt="tcp_1" style="zoom: 80%;" />

<h4 id="3-连接说明"><a href="#3-连接说明" class="headerlink" title="3.连接说明"></a>3.连接说明</h4><p>假设客户端和服务器的初始序列号分别为X，Y</p>
<ol>
<li>客户端发送建立连接请求，<code>标志位SYN，seq = X</code></li>
<li>服务器收到请求并回复，<code>标志位SYN、ACK，ack = X + 1，seq= Y</code></li>
<li>客户端收到回复，并告诉服务器我收到了 <code>标志位ACK，ack = Y + 1，seq = X + 1，</code></li>
</ol>
<p><strong>解释</strong></p>
<p>第二次握手使用了SYN和ACK两个标志位，主要是因为在这一次握手中，服务端表达了两个意思：<strong>确认收到客户端的初始序列号、通知客户端自己的初始序列号</strong></p>
<h3 id="二、四次挥手"><a href="#二、四次挥手" class="headerlink" title="二、四次挥手"></a>二、四次挥手</h3><p><strong>挥手过程</strong></p>
<ol>
<li>主动发起的一方，发送一个FIN请求，表示想要关闭连接</li>
<li>被动方接收FIN请求，发送ACK，表示收到请求</li>
<li>被动方传输完数据后，发送FIN请求，表示我也没有数据要传了</li>
<li>主动方发送ACK应答被动方</li>
</ol>
<h3 id="三、状态"><a href="#三、状态" class="headerlink" title="三、状态"></a>三、状态</h3><p>通信双方在建立、断开TCP连接时，各自的状态如下所示：</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210920205827.png" alt="image-20210920205827008"></p>
<h4 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h4><p><strong>状态描述</strong></p>
<p>当主动关闭方收到被动关闭方的FIN报文时，会进入TIME_WAIT状态，</p>
<p>然后保持该状态持续2MSL（maximum segment time）时间。</p>
<p><strong>该状态的作用</strong></p>
<ol>
<li>等待一段时间，确保主动关闭方的ACK可以到达。如果被动方没收到ACK，则它会重传FIN报文。</li>
<li>确保本次连接的所有报文段都从网络上消失。</li>
</ol>
<h2 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h2><p>与拥塞控制相关</p>
<p><strong>概念介绍</strong></p>
<ul>
<li>RTT(round-trip time)：往返时间，从发数据到收到ack响应的时间</li>
<li>RTO(retransmission time out)：超时时间</li>
</ul>
<h2 id="TCP滑动窗口与流量控制"><a href="#TCP滑动窗口与流量控制" class="headerlink" title="TCP滑动窗口与流量控制"></a>TCP滑动窗口与流量控制</h2><h3 id="一、流量控制"><a href="#一、流量控制" class="headerlink" title="一、流量控制"></a>一、流量控制</h3><h4 id="1-流量控制是什么"><a href="#1-流量控制是什么" class="headerlink" title="1.流量控制是什么"></a>1.流量控制是什么</h4><p><strong>流量控制</strong>是指对发送方发送数据的速率进行控制，从而防止接收方来不及处理数据包的一种手段。</p>
<h4 id="2-流量控制的实现"><a href="#2-流量控制的实现" class="headerlink" title="2.流量控制的实现"></a>2.流量控制的实现</h4><p>它主要通过<code>滑动窗口</code>和接收端的<code>窗口通告</code>来实现。</p>
<p><strong>窗口通告</strong>即接收方在返回ACK确认报文时，同时会带上自己的可用窗口大小</p>
<h4 id="3-为什么要流量控制？"><a href="#3-为什么要流量控制？" class="headerlink" title="3.为什么要流量控制？"></a>3.为什么要流量控制？</h4><p>如果不进行流量控制，会发生什么呢？</p>
<ul>
<li>发送速率太快：接收方来不及处理，缓冲区也满了，只能把数据丢掉，即<strong>丢包率上升</strong></li>
<li>发送速率太慢：接收方一直等待数据到来，<strong>浪费大量CPU资源</strong></li>
</ul>
<h3 id="二、滑动窗口"><a href="#二、滑动窗口" class="headerlink" title="二、滑动窗口"></a>二、滑动窗口</h3><blockquote>
<p>TCP连接的每一端都可以<strong>收发数据</strong>，连接的收发数据量是通过一组窗口结构来维护的。</p>
<p>每个TCP活动连接的两端都维护了一个<strong>发送窗口结构</strong>和<strong>接收窗口结构</strong>。</p>
</blockquote>
<p>如下图，就是发送端的发送窗口结构示例：</p>
<p>其中，<code>提供窗口</code>的大小由接收端返回的ACK报文中的窗口大小所控制，计算公式为：$可用窗口大小 = SND.UNA + SND.WND - SND.NXT$</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210922125411.png" alt="image-20210922125411270"></p>
<h4 id="1-窗口对比示例"><a href="#1-窗口对比示例" class="headerlink" title="1.窗口对比示例"></a>1.窗口对比示例</h4><p>发送窗口与接收窗口对照：</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210922124646.png" alt="image-20210922124646465"></p>
<h4 id="2-窗口变化"><a href="#2-窗口变化" class="headerlink" title="2.窗口变化"></a>2.窗口变化</h4><p>滑动窗口<strong>边界变化</strong>的情况有以下几种：</p>
<ol>
<li>左边界右移，即已发送数据得到ACK确认</li>
<li>右边界右移。当已确认数据得到接收方的处理，接收方缓存空出来，通知发送方扩大发送窗口。</li>
</ol>
<p><strong>滑动窗口</strong>的变化：</p>
<ol>
<li>左右边界同时右移，窗口大小保持不变，即<code>滑动</code></li>
<li>左边界右移，右边界不变，窗口大小减小，即<code>窗口缩小</code></li>
</ol>
<p><strong>特殊情况</strong></p>
<p>当窗口缩小至0时，发送方不再发送数据，而是等待接收方的ACK报文。</p>
<p>但是如果接收方在进行延迟ACK的发送，则有可能产生短暂的<code>死锁</code>现象：</p>
<ul>
<li>发送方在等待接收方的窗口大小</li>
<li>接收方在等待发送方发送数据</li>
</ul>
<p><strong>解决方案：发送方开启一个持续计时器，间隔地向接受方发起窗口探测，强制要求它返回ACK</strong></p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>什么是DNS？</p>
<p>如何使用DNS？DNS相关命令</p>
<p>DNS的过程是怎样的？</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="什么是DNS？DNS中的一些概念"><a href="#什么是DNS？DNS中的一些概念" class="headerlink" title="什么是DNS？DNS中的一些概念"></a>什么是DNS？DNS中的一些概念</h3><p><strong>DNS</strong>：Domain Name System，即域名系统</p>
<p><strong>域名</strong>：形如<code>www.baidu.com</code></p>
<p><strong>域名划分</strong>：根域名<code>.</code>、顶级域名<code>com</code>、二级域名<code>baidu</code>等等</p>
<p><strong>服务器</strong>：根域名服务器、顶级域名服务器、本地域名服务器（通常离主机蛮近的）等等</p>
<p><strong>DNS提供了由域名转化到ip地址的功能，主要的形式是一种分布式数据库</strong> </p>
<h3 id="如何使用DNS？DNS相关命令"><a href="#如何使用DNS？DNS相关命令" class="headerlink" title="如何使用DNS？DNS相关命令"></a>如何使用DNS？DNS相关命令</h3><p><a href="https://www.cnblogs.com/sparkdev/p/7777871.html">参考文章：dig命令用法</a></p>
<p>dig命令：从DNS域名服务器中查询主机信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单用法，查看dns的结果</span></span><br><span class="line">dig www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看dns的过程，从根域名服务器依次向下</span></span><br><span class="line">dig +trace www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反向解析，根据ip得到域名，可以进行拦截判断</span></span><br><span class="line">dig -x 8.8.8.8</span><br></pre></td></tr></table></figure>

<h3 id="DNS的过程是怎样的？"><a href="#DNS的过程是怎样的？" class="headerlink" title="DNS的过程是怎样的？"></a>DNS的过程是怎样的？</h3><p>域名解析的过程</p>
<ol>
<li>访问浏览器缓存、访问本地缓存</li>
<li><code>@递归</code>向本地域名服务器发送域名解析请求，它也会先查询本地服务器的缓存</li>
<li><code>@迭代</code>本地域名服务器向根域名服务器发送请求，得知去哪个顶级域名服务器查询；然后本地域名服务器再向顶级域名服务器查询，得知去哪个次级的服务器查询。</li>
</ol>
<p>上述第三步查询的<strong>主体都是本地域名服务器</strong>，因此可以看作是迭代查询的过程。</p>
<ol>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>记录</title>
    <url>/2021/12/13/%E5%B7%A5%E5%85%B7/%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>有时候学着学着想起了或者遇到了知识盲区，怕之后忘记，于是就记在这儿</p>
<ul>
<li><p><input disabled="" type="checkbox">  堆结构、堆排序</p>
</li>
<li><p><input disabled="" type="checkbox">  优先级队列</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  快排</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  归并排序</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  加密算法（MD5，加盐…）</p>
</li>
<li><p><input checked="" disabled="" type="checkbox">  原码、反码、补码</p>
</li>
<li><p><input disabled="" type="checkbox">  Spring</p>
<ul>
<li><input disabled="" type="checkbox"> AOP</li>
<li><input disabled="" type="checkbox"> IOC</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox">  SpringBoot</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 自动装配</li>
<li><input disabled="" type="checkbox"> 切面</li>
<li><input disabled="" type="checkbox"> …</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox">  SpringCloud</p>
<ul>
<li><input disabled="" type="checkbox"> …</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox">  transient</p>
</li>
<li><p><input disabled="" type="checkbox">  并查集</p>
</li>
<li><p><input disabled="" type="checkbox">  线段树</p>
</li>
<li><p><input disabled="" type="checkbox">  kmp算法</p>
</li>
<li><p><input disabled="" type="checkbox">  看人月神话</p>
</li>
<li><p><input disabled="" type="checkbox">  浮点数表示及计算</p>
</li>
<li><p><input disabled="" type="checkbox">  图片压缩（博客放图片）</p>
</li>
<li><p><input disabled="" type="checkbox">  base64长链转短链</p>
</li>
<li><p><input disabled="" type="checkbox">  JVM</p>
<ul>
<li><input disabled="" type="checkbox"> 垃圾回收器CMS、G1、ZGC区别、优化</li>
<li><input disabled="" type="checkbox"> Java工作内存模型</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox">  redis</p>
<ul>
<li><input disabled="" type="checkbox"> sortedset</li>
<li><input disabled="" type="checkbox"> 自增id</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox">  MongDB</p>
</li>
<li><p><input disabled="" type="checkbox">  RabbitMQ</p>
</li>
<li><p><input disabled="" type="checkbox">  docker</p>
</li>
<li><p><input disabled="" type="checkbox">  操作系统</p>
<ul>
<li><input disabled="" type="checkbox"> 死锁</li>
<li><input disabled="" type="checkbox"> 段页式作用</li>
</ul>
</li>
<li><p><input disabled="" type="checkbox">  nginx</p>
<ul>
<li><input disabled="" type="checkbox"> 稍微了解一些即可</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>快速导航</title>
    <url>/2021/12/13/%E5%B7%A5%E5%85%B7/%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<h4 id="导航链接"><a href="#导航链接" class="headerlink" title="导航链接"></a>导航链接</h4><ul>
<li><a href="https://mermaid-js.github.io/mermaid/#/">美人鱼</a></li>
</ul>
<p>可以方便地在博客中绘制类图、甘特图、时序图等</p>
<ul>
<li><a href="https://console.leancloud.app/apps">LeanCloud</a></li>
</ul>
<p>管理发布的说说</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/e74eb43960a1">MarkDown数学公式</a></p>
</li>
<li><p><a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-source.md">SpringCloud中文文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>养眼</title>
    <url>/2021/12/13/%E5%B7%A5%E5%85%B7/%E5%85%BB%E7%9C%BC/</url>
    <content><![CDATA[<p><img data-src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg"><br><img data-src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg"><br><img data-src="https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg"><br><img data-src="https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg"><br><img data-src="https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg"><br><img data-src="https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg"><br><img data-src="https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg"><br><img data-src="https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>书单</title>
    <url>/2021/12/13/%E5%B7%A5%E5%85%B7/%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<h1 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h1><ul>
<li><input disabled="" type="checkbox"> Redis设计与实现</li>
<li><input disabled="" type="checkbox"> 高性能MySQL</li>
<li><input disabled="" type="checkbox"> 操作系统精髓与设计原理</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Protobuf入门</title>
    <url>/2021/12/13/%E5%B7%A5%E5%85%B7/protocol%20buffers/</url>
    <content><![CDATA[<h1 id="文档链接"><a href="#文档链接" class="headerlink" title="文档链接"></a>文档链接</h1><p><a href="https://developers.google.com/protocol-buffers">protocol-buffers官网</a></p>
<p><a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3教程</a></p>
<p><a href="https://halfrost.com/protobuf_encode/#toc-0">高效的数据压缩编码方式 Protobuf </a></p>
<h1 id="protocol-buffers"><a href="#protocol-buffers" class="headerlink" title="protocol buffers"></a>protocol buffers</h1><h3 id="什么是protocol-buffers"><a href="#什么是protocol-buffers" class="headerlink" title="什么是protocol buffers"></a>什么是protocol buffers</h3><p><strong>官方文档</strong></p>
<blockquote>
<p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p>
</blockquote>
<p><strong>翻译</strong></p>
<blockquote>
<p>protocol buffers是Google开源的一种对结构化数据进行序列化的方式。它具有语言无关、平台无关和可扩展性；和xml相比，它更小，更快并且更加简单。</p>
<p>用户只需要定义一次所需的结构化数据， 就可以利用生成的各种语言的代码从数据流中读写数据</p>
</blockquote>
<h3 id="选择语言进行安装"><a href="#选择语言进行安装" class="headerlink" title="选择语言进行安装"></a>选择语言进行安装</h3><p><a href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers/protobuf (github.com)</a></p>
<h1 id="一、定义Message"><a href="#一、定义Message" class="headerlink" title="一、定义Message"></a>一、定义Message</h1><p>示例：在<code>.proto</code>文件中定义一个名叫<code>SearchRequest</code>的消息格式，用来表示搜索的请求</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./mvp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserLoginReq</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> UserName = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> Password = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserLoginRsp</span> </span>&#123;</span><br><span class="line">        <span class="built_in">bool</span> IsLogin = <span class="number">1</span>;</span><br><span class="line">        User UserInfo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一行<code>syntax = &quot;proto3&quot;</code>表示使用proto3的语法，要放在正文（非空行和非注释行）中的第一行，如果没有这一行，则表示使用proto2语法</li>
<li><code>go_package</code>指定生成目标代码的目录</li>
<li>消息体<code>UserLoginReq</code>由2个字段构成，每个字段包含类型、名称和值。</li>
</ul>
<h3 id="1-1-指定字段类型"><a href="#1-1-指定字段类型" class="headerlink" title="1.1 指定字段类型"></a>1.1 指定字段类型</h3><p>如示例中的<code>UserName</code>字段，类型为<code>string</code>；</p>
<p>类型既可以是数值类型，也可以是复合类型（枚举、其他消息体）</p>
<h3 id="1-2-设定字段值"><a href="#1-2-设定字段值" class="headerlink" title="1.2 设定字段值"></a>1.2 设定字段值</h3><p>字段值是唯一的，被用来标识该字段在消息的二进制格式</p>
<p><strong>字段值从1到15使用一个字节来编码，16到2047使用两个字节来编码，因此对于频繁出现的字段，它的值应该设成1到15之间。</strong></p>
<p>关于更多，可以先去了解下<code>protocol buffer</code>的编码</p>
<h3 id="1-3-指定字段规则"><a href="#1-3-指定字段规则" class="headerlink" title="1.3 指定字段规则"></a>1.3 指定字段规则</h3><ul>
<li><p><strong>singular</strong></p>
<p>  表示该字段出现次数不多于1（0个或者1个）</p>
<p>  proto3默认使用这种规则</p>
</li>
<li><p><strong>repeated</strong></p>
<p>  表示字段可以出现任意次，可以理解成数组</p>
</li>
</ul>
<h1 id="二、定义Service"><a href="#二、定义Service" class="headerlink" title="二、定义Service"></a>二、定义Service</h1><p>如果想要将上面定义的<code>Message</code>类型用于<code>rpc调用</code>，就要定义一个服务，服务中可以声明多个接口。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">rpc</span> Login(UserLoginReq) <span class="keyword">returns</span> (UserLoginRsp)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-完整示例"><a href="#2-1-完整示例" class="headerlink" title="2.1 完整示例"></a>2.1 完整示例</h3><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./mvp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">rpc</span> Login(UserLoginReq) <span class="keyword">returns</span> (UserLoginRsp)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户登陆请求</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserLoginReq</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> UserName = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> Password = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户登陆响应</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserLoginRsp</span> </span>&#123;</span><br><span class="line">        <span class="built_in">bool</span> IsLogin = <span class="number">1</span>;</span><br><span class="line">        User UserInfo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户消息格式</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="built_in">uint64</span> UserID = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> NickName = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">uint64</span> Age = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">repeated</span> <span class="built_in">string</span> ImgURL = <span class="number">4</span>;</span><br><span class="line">        UserType UserType = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义枚举类型：用户权限类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UserType</span> </span>&#123;</span><br><span class="line">        UT_Nil = <span class="number">0</span>;</span><br><span class="line">        UT_Visit = <span class="number">1</span>;</span><br><span class="line">        UT_Normal = <span class="number">2</span>;</span><br><span class="line">        UT_Admin = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、生成Go代码"><a href="#三、生成Go代码" class="headerlink" title="三、生成Go代码"></a>三、生成Go代码</h1><h3 id="3-1-下载插件"><a href="#3-1-下载插件" class="headerlink" title="3.1 下载插件"></a>3.1 下载插件</h3><p><code>protocol buffer complier</code>需要一个插件才能生成Go代码，因此先下载插件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure>

<p>下载完毕后在<code>$GOPATH/bin</code>路径下会生成<code>protoc-gen-go</code></p>
<h3 id="3-2-利用插件生成代码"><a href="#3-2-利用插件生成代码" class="headerlink" title="3.2 利用插件生成代码"></a>3.2 利用插件生成代码</h3><p>在项目的根目录下用终端（或cmd）输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. <span class="variable">$SRC_DIR</span>/addressbook.proto</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li><p><code>go_out</code>：表示生成go代码</p>
</li>
<li><p><code>$SRC_DIR/addressbook.proto</code>：表示协议所在位置</p>
</li>
<li><p>如果想要指定代码生成的位置，则在协议文件中添加</p>
  <figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;yourpath&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、demo"><a href="#四、demo" class="headerlink" title="四、demo"></a>四、demo</h1><h3 id="4-1-编码并写入文件"><a href="#4-1-编码并写入文件" class="headerlink" title="4.1 编码并写入文件"></a>4.1 编码并写入文件</h3><p>主要使用<code>Marshal()</code>进行编码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestProtoWrite 测试把消息写入指定文件中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProtoWrite</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    login := &amp;mvp.UserLoginReq &#123;</span><br><span class="line">        UserName: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">        Password: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out, err := proto.Marshal(login)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Fail to encode message login:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = ioutil.WriteFile(FilePath, out, fs.FileMode(<span class="number">777</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Fail to write file:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-读取消息并解码"><a href="#4-2-读取消息并解码" class="headerlink" title="4.2 读取消息并解码"></a>4.2 读取消息并解码</h3><p>使用<code>Unmarshal()</code>进行解码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestProtoRead 测试从指定文件中读取消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProtoRead</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    in, err := ioutil.ReadFile(FilePath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Fail to read file:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    login := &amp;mvp.UserLoginReq&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err = proto.Unmarshal(in, login); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Fail to decode message login:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(login)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五、编码详解"><a href="#五、编码详解" class="headerlink" title="五、编码详解"></a>五、编码详解</h1><h3 id="5-1-Base-128-Varints"><a href="#5-1-Base-128-Varints" class="headerlink" title="5.1 Base 128 Varints"></a>5.1 Base 128 Varints</h3><h5 id="官方文档说明"><a href="#官方文档说明" class="headerlink" title="官方文档说明"></a>官方文档说明</h5><blockquote>
<p>To understand your simple protocol buffer encoding, you first need to understand <em>varints</em>. Varints are a method of serializing integers using one or more bytes. Smaller numbers take a smaller number of bytes.</p>
<p>Each byte in a varint, except the last byte, has the <em>most significant bit</em> (msb) set – this indicates that there are further bytes to come. The lower 7 bits of each byte are used to store the two’s complement representation of the number in groups of 7 bits, <strong>least significant group first</strong>.</p>
</blockquote>
<h5 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h5><blockquote>
<p>为了帮助你理解<code>protocol buffer</code>的编码方式，你需要先了解一下<code>varints</code>。<code>varints</code>是一种将整数类型序列化成一个或多个字节的方法。越小的数字序列化后产生的字节数就越少。</p>
<p>varints中除了最后一个字节，其他字节的最高有效位都置为1，用来表示接下来还有字节；剩余的低7位则是对每7位为一组的二进制数据的补码表示。</p>
</blockquote>
<h5 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h5><p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210701200434.png"></p>
<p>解码过程就是上述编码的逆过程，这里就不再赘述。</p>
<h3 id="5-2-消息类型编码"><a href="#5-2-消息类型编码" class="headerlink" title="5.2 消息类型编码"></a>5.2 消息类型编码</h3><blockquote>
<p>从之前的消息示例中我们可以看出，消息是由一系列的键值对组成的。</p>
</blockquote>
<h5 id="键值对介绍"><a href="#键值对介绍" class="headerlink" title="键值对介绍"></a>键值对介绍</h5><p>键被称为<code>tag</code>，由<code>field number</code>和<code>wire type</code>构成，前者表示设定的字段号，后者可以查表得。</p>
<p>值就是该字段被赋予的数值。</p>
<p><code>tag</code>的计算方式为：<br>$$<br>tag = (field number &lt;&lt; 3)  | wire type<br>$$<br>表格如下，其中3，4已被废弃，就是说<code>wire type</code>取值应该只有0，1，2，5，因此用三比特即可表示<code>wire type</code>。</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Meaning</th>
<th align="left">Used For</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">Varint</td>
<td align="left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">64-bit</td>
<td align="left">fixed64, sfixed64, double</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Length-delimited</td>
<td align="left">string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Start group</td>
<td align="left">groups (deprecated)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">End group</td>
<td align="left">groups (deprecated)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">32-bit</td>
<td align="left">fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>现有以下消息，假设传入消息，a的值是150</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个消息体编码后得到的结果是<code>08 96 01</code>（16进制）</p>
<ul>
<li><p>计算tag</p>
<p>  0001 ++ 000，得到<code>0001000</code>，即<strong>08</strong></p>
</li>
<li><p>对150进行编码，采取上述<code>varints</code>方式</p>
<ul>
<li>10010110</li>
<li>1，0010110</li>
<li>00000001，10010110</li>
<li>得到编码<code>10010110，00000001</code></li>
<li>用16进制表示，即<strong>96 01</strong></li>
</ul>
</li>
</ul>
<h3 id="5-3-字符串编码"><a href="#5-3-字符串编码" class="headerlink" title="5.3 字符串编码"></a>5.3 字符串编码</h3><p>和普通的整型相比，字符串在消息体中的编码方式多了一个length，表示字符串编码后的长度。</p>
<p>形式为<code>key length content</code>。</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>b赋值为testing</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">string</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码后的结果是<code>12 07 74 65 73 74 69 6e 67</code></p>
<p>其中<strong>07</strong>表示长度，后面的7个16进制就是testing的utf8编码</p>
<p>最开始的<strong>12</strong>就是key，由0010010转换成16进制得到。</p>
<h2 id="六、"><a href="#六、" class="headerlink" title="六、"></a>六、</h2>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Maven问题和解决方案记录</title>
    <url>/2021/12/13/%E5%B7%A5%E5%85%B7/maven%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="一、无脑配镜像"><a href="#一、无脑配镜像" class="headerlink" title="一、无脑配镜像"></a>一、无脑配镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tmd啥镜像都不用配</span></span><br></pre></td></tr></table></figure>

<h3 id="二、删除lastupdated文件"><a href="#二、删除lastupdated文件" class="headerlink" title="二、删除lastupdated文件"></a>二、删除lastupdated文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listDirectory</span><span class="params">(File dir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dir.exists())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;目录：&quot;</span> + dir + <span class="string">&quot;不存在.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dir.isDirectory()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(dir + <span class="string">&quot; 不是目录。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory())</span><br><span class="line">                <span class="comment">//递归</span></span><br><span class="line">                listDirectory(file);</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 删除以 lastUpdated 结尾的文件</span></span><br><span class="line">                String fileName = file.getName();</span><br><span class="line">                <span class="keyword">boolean</span> isLastupdated = fileName.toLowerCase().endsWith(<span class="string">&quot;lastupdated&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (isLastupdated)&#123;</span><br><span class="line">                    <span class="keyword">boolean</span> is_delete = file.delete();</span><br><span class="line">                    System.out.println(<span class="string">&quot;删除的文件名 =&gt; &quot;</span> + file.getName() + <span class="string">&quot;  || 是否删除成功？ ==&gt; &quot;</span> + is_delete);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 指定maven的本地仓库</span></span><br><span class="line">    listDirectory(<span class="keyword">new</span> File(<span class="string">&quot;E:\\programs\\mvnrepository&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h3><h5 id="描述1："><a href="#描述1：" class="headerlink" title="描述1："></a>描述1：</h5><blockquote>
<p>Could not transfer artifact xxx from/to xxx解决方案</p>
</blockquote>
<h5 id="解决方案1："><a href="#解决方案1：" class="headerlink" title="解决方案1："></a>解决方案1：</h5><ol>
<li>用上述工具类删除下载失败的文件</li>
<li>在<code>pom.xml</code>文件中，右键-&gt;Maven-&gt;reload project</li>
<li>完美运行</li>
</ol>
<h5 id="解决方案2："><a href="#解决方案2：" class="headerlink" title="解决方案2："></a>解决方案2：</h5><p>删除文件不用多说</p>
<p>然后在终端输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean &amp;&amp; mvn compile -Dmaven.wagon.http.ssl.insecure=<span class="literal">true</span> -Dmaven.wagon.http.ssl.allowall=<span class="literal">true</span> -Dmaven.wagon.http.ssl.ignore.validity.dates=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后刷新试试（注意，maven没有配置镜像，裸连）</p>
<hr>
<h5 id="描述2："><a href="#描述2：" class="headerlink" title="描述2："></a>描述2：</h5><p>出现SSL证书问题</p>
<h5 id="解决方案2：-1"><a href="#解决方案2：-1" class="headerlink" title="解决方案2："></a>解决方案2：</h5><p>最简单粗暴的，在终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean &amp;&amp; mvn compile -Dmaven.wagon.http.ssl.insecure=<span class="literal">true</span> -Dmaven.wagon.http.ssl.allowall=<span class="literal">true</span> -Dmaven.wagon.http.ssl.ignore.validity.dates=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如果显示<strong>无法识别mvn命令</strong>，那就是<strong>环境变量</strong>没配置对，重新去配下maven的环境变量</p>
<p><a href="https://blog.csdn.net/qq_22041375/article/details/103491941">剩余方法参考这里</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Git&amp;GitHub使用</title>
    <url>/2021/12/13/%E5%B7%A5%E5%85%B7/Git&amp;Github%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、拉取某一远程分支"><a href="#一、拉取某一远程分支" class="headerlink" title="一、拉取某一远程分支"></a>一、拉取某一远程分支</h2><p>项目分支太多，只想要某一分支时，可以添加<code>--single-branch</code>参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b 分支名 --single-branch 仓库路径</span><br></pre></td></tr></table></figure>



<h2 id="二、合并分支并解决冲突"><a href="#二、合并分支并解决冲突" class="headerlink" title="二、合并分支并解决冲突"></a>二、合并分支并解决冲突</h2><p><strong>开发流程</strong></p>
<p>master -&gt; 创建特性分支 -&gt; 在特性分支上开发 -&gt; 拉取最新master，合并到特性分支 -&gt; 提交到远程仓库，并提MR</p>
<p><strong>解释</strong></p>
<ol>
<li>开发需求时，通常是从master分支中拉一个新的分支，称为特性分支，然后在特性分支上开发。</li>
</ol>
<ol start="2">
<li><p>开发完毕后，申请<code>merge request</code>到master分支上。</p>
</li>
<li><p>但是这时候master分支可能已经发生了变化，比如同事早一步开发完，合到了master分支上。</p>
</li>
<li><p>这时候就需要把master拉下来，合并到特性分支上。</p>
</li>
</ol>
<p>具体的操作方式很简单，在<code>idea</code>上先把master分支<code>pull</code>下来</p>
<p>然后点击master分支（不要切换），选择<code>merge into current</code>，如果有冲突，进行解决即可。</p>
<h2 id="三、项目中引用外部协议"><a href="#三、项目中引用外部协议" class="headerlink" title="三、项目中引用外部协议"></a>三、项目中引用外部协议</h2><h5 id="1-修改协议项目中的go-mod"><a href="#1-修改协议项目中的go-mod" class="headerlink" title="1. 修改协议项目中的go.mod"></a>1. 修改协议项目中的go.mod</h5><p>把<code>go.mod</code>的module路径改成带GitHub的，如</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">module github.com<span class="regexp">/Aurora-Ze/</span>protocol</span><br></pre></td></tr></table></figure>

<h5 id="2-修改协议文件"><a href="#2-修改协议文件" class="headerlink" title="2. 修改协议文件"></a>2. 修改协议文件</h5><p><code>go_package</code>符合url路径</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> user.cgi;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/Aurora-Ze/protocol/user/cgi&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-引入"><a href="#3-引入" class="headerlink" title="3. 引入"></a>3. 引入</h5><p>在随便一个go文件中的<code>import</code>块里添加，然后<code>Alt + Enter</code>提示同步依赖</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;github.com/Aurora-Ze/protocol/user/cgi&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="四、添加Github-SSH-key"><a href="#四、添加Github-SSH-key" class="headerlink" title="四、添加Github SSH key"></a>四、添加Github SSH key</h2><p>如果想要通过SSH的方式克隆项目，就要先在本地生成SSH密钥对，然后把公钥添加到GitHub配置中，就可以建立起本地和远程GitHub仓库的连接。</p>
<p>通过SSH有个好处，就是不需要再输入账号和个人令牌进行登陆验证，避免信息泄露</p>
<h5 id="1-设置name和email"><a href="#1-设置name和email" class="headerlink" title="1. 设置name和email"></a>1. 设置name和email</h5><p>在项目目录下，打开cmd输入</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git config <span class="keyword">user</span>.name &quot;xxx&quot;</span><br><span class="line">git cinfig <span class="keyword">user</span>.email &quot;xxx@gmail.com&quot;</span><br></pre></td></tr></table></figure>

<h5 id="2-生成密钥"><a href="#2-生成密钥" class="headerlink" title="2. 生成密钥"></a>2. 生成密钥</h5><p>密钥默认生成在用户目录下的<code>.ssh</code>文件夹中，如果已经存在，请备份或指定其他位置</p>
<p>按三次回车后生成密钥，然后把<code>.pub</code>中内容添加到GitHub的<code>SSH and GPG keys</code>中上</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="variable">ssh</span><span class="operator">-</span><span class="variable">keygen</span> <span class="operator">-</span><span class="built_in">C</span> <span class="string">&quot;xxx@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>-t：指定密钥类型，默认rsa</li>
<li>-C：添加注释</li>
<li>-f：指定密钥保存的文件</li>
<li>-b：指定密钥长度，最小1024位，默认3072</li>
</ul>
<p>如果想要更高的安全性，密钥签名算法可以选择<code>ed25519</code>，其长度为256位，无需设置密钥尺寸</p>
<h5 id="3-指纹"><a href="#3-指纹" class="headerlink" title="3.指纹"></a>3.指纹</h5><p>生成密钥对后，命令行中会显示一串字母，称为指纹。第一次连接远程主机时，也会显示指纹。</p>
<p>指纹是公钥经过哈希和编码后生成的较短的字符串，通过它可以判断本地密钥对的公钥和远程主机配置的公钥是否一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your public key has been saved <span class="keyword">in</span> C:/Users/xxx/.ssh/test_rsa/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:nCWjRmyWUj7+E8/X9UW5KRdsl9Ml4W0z1t8X5vsRmFs 87654321xxx@gmail.com</span><br></pre></td></tr></table></figure>



<h2 id="五、把多个提交合并为一个"><a href="#五、把多个提交合并为一个" class="headerlink" title="五、把多个提交合并为一个"></a>五、把多个提交合并为一个</h2><blockquote>
<p>为了让master分支更加干净一些，我们在提MR之前，最好先把自己分支上的多个提交合并成一个。</p>
<p>有两种方式可以实现</p>
</blockquote>
<p><strong>第一种：替换旧的提交</strong></p>
<p>在每次提交时，添加<code>amend</code>参数，即</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>该参数会覆盖上一次的提交，并生成新的commit</p>
<p>只要我们在第二次及以后每次提交时，都采用该命令，就可以始终保持commit记录为一个了。</p>
<p><strong>注意</strong>：之后<code>push</code>到远程分支，要带上<code>-f</code>参数，即<strong>强制推送</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -f </span><br></pre></td></tr></table></figure>

<p><strong>局限性</strong>：如果我们已经有了多次提交，那么这个方式就不太适用。</p>
<p><strong>第二种：rebase命令</strong></p>
<p>用git log查看提交日志，选择最近的一次他人提交，复制id</p>
<p>git rebase -i id，然后在vim模式下把不想要的提交前缀改为d，想要合并的改为s，保持上面第一个为pick即可</p>
<p>最后rebase完毕后，<strong>记得要强制push</strong></p>
<p><code>问题</code>：在idea的终端进行rebase操作时，遇到退不出vim模式的情况（按esc后鼠标指针跳到代码中）</p>
<p><code>解决</code>：鼠标右键终端标签，选择move to editor</p>
<h2 id="六、更新远程分支列表"><a href="#六、更新远程分支列表" class="headerlink" title="六、更新远程分支列表"></a>六、更新远程分支列表</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">update</span> origin <span class="comment">--prune</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>分布式id生成</title>
    <url>/2021/12/13/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="分布式id生成方式"><a href="#分布式id生成方式" class="headerlink" title="分布式id生成方式"></a>分布式id生成方式</h1><h3 id="一、数据库自增ID"><a href="#一、数据库自增ID" class="headerlink" title="一、数据库自增ID"></a>一、数据库自增ID</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>创建表时设置主键为<code>auto_increment</code></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>实现简单，但是每次生成ID都要访问一次数据库，带来压力；而且多台设备下可能会重复。</p>
<h3 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h3>]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><a href="https://segmentfault.com/a/1190000023615225">https://segmentfault.com/a/1190000023615225</a></p>
]]></content>
  </entry>
  <entry>
    <title>操作系统——内存管理</title>
    <url>/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-1程序的运行"><a href="#1-1程序的运行" class="headerlink" title="1.1程序的运行"></a>1.1程序的运行</h2><p>主要有三步，<strong>编译</strong>、<strong>链接</strong>和<strong>装入</strong>。</p>
<ul>
<li><strong>编译</strong>，源码编译成若干个目标模块</li>
<li><strong>链接</strong>，多个目标模块与所需库函数链接，形成完整模块</li>
<li><strong>装入</strong>，把完整模块装入到内存中</li>
</ul>
<h2 id="1-2链接方式"><a href="#1-2链接方式" class="headerlink" title="1.2链接方式"></a>1.2链接方式</h2><h3 id="1-2-1静态链接"><a href="#1-2-1静态链接" class="headerlink" title="1.2.1静态链接"></a>1.2.1静态链接</h3><p>执行前链接库函数</p>
<h3 id="1-2-2装入时动态链接"><a href="#1-2-2装入时动态链接" class="headerlink" title="1.2.2装入时动态链接"></a>1.2.2装入时动态链接</h3><p>模块放入内存时，链接上目标库函数</p>
<h3 id="1-2-3运行时动态链接"><a href="#1-2-3运行时动态链接" class="headerlink" title="1.2.3运行时动态链接"></a>1.2.3运行时动态链接</h3><p>执行时需要某个模块时，才进行链接</p>
<h2 id="1-3装入方式"><a href="#1-3装入方式" class="headerlink" title="1.3装入方式"></a>1.3装入方式</h2><p>装入过程中，要把模块放入到内存中运行，可是该放在内存的哪个位置呢？</p>
<p>因此出现了3种不同的装入方式，<strong>绝对装入</strong>、<strong>静态重定位</strong>和<strong>动态重定位</strong>。</p>
<h3 id="1-3-1绝对装入"><a href="#1-3-1绝对装入" class="headerlink" title="1.3.1绝对装入"></a>1.3.1绝对装入</h3><p>编译时程序就已经知道了它的物理（绝对）地址，所以装入时直接放在相应位置即可。</p>
<p>只适用于单道程序环境</p>
<h3 id="1-3-2静态重定位"><a href="#1-3-2静态重定位" class="headerlink" title="1.3.2静态重定位"></a>1.3.2静态重定位</h3><p>由装入程序把逻辑地址转变成物理地址</p>
<p><strong>特点：装入时必须分配所需的全部内存空间</strong></p>
<p>早期多道批处理系统使用这种方式。</p>
<h3 id="1-3-3动态重定位"><a href="#1-3-3动态重定位" class="headerlink" title="1.3.3动态重定位"></a>1.3.3动态重定位</h3><p>装入时还是使用的逻辑地址，等到指令真正运行时，才会把逻辑地址转换成物理地址</p>
<p>是通过一个<code>重定位寄存器</code>存储模块的起始位置来实现的。</p>
<h2 id="1-4编址方式"><a href="#1-4编址方式" class="headerlink" title="1.4编址方式"></a>1.4编址方式</h2><p>内存有两种编址方式，分别是<strong>按字节编址</strong>和<strong>按字编址</strong></p>
<ul>
<li><p><strong>按字节编址</strong></p>
<p>  从地址0开始，每个存储单元表示1字节</p>
</li>
<li><p><strong>按字编址</strong></p>
<p>  <code>字</code>指的是处理器的字长，例如32位计算机，字长就是32位，转化成字节就是4字节</p>
<p>  所以每个存储单元就是4字节</p>
</li>
</ul>
<h1 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h1><p>操作系统管理内存，主要做了几件事</p>
<ol>
<li>内存空间的分配与回收</li>
<li>内存空间的扩充</li>
<li>地址转换</li>
<li>内存保护</li>
</ol>
<p>下面我们打乱顺序，从最简单的开始将。</p>
<h1 id="三、内存保护"><a href="#三、内存保护" class="headerlink" title="三、内存保护"></a>三、内存保护</h1><p>内存保护指一个进程应该只能访问自己空间的数据</p>
<p>两种方法：</p>
<ul>
<li>一是设置上限、下限寄存器</li>
<li>二是采用重定位寄存器</li>
</ul>
<h1 id="四、内存空间分配与回收"><a href="#四、内存空间分配与回收" class="headerlink" title="四、内存空间分配与回收"></a>四、内存空间分配与回收</h1><p>内存分配可以采用连续分配，也可以采用非连续分配的方式。</p>
<p>下面这张图介绍了连续分配内存的相关知识。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210505160506.png" alt="连续分配管理"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%94%E3%80%81%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、进程基础"><a href="#一、进程基础" class="headerlink" title="一、进程基础"></a>一、进程基础</h1><h2 id="1-1问题总览"><a href="#1-1问题总览" class="headerlink" title="1.1问题总览"></a>1.1问题总览</h2><h3 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h3><p>什么是进程？进程和程序的区别是什么？</p>
<p>进程的状态有哪些？</p>
<p>进程结构是怎样的，由哪些部分构成？</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>怎样运行进程</p>
<p>创建进程、执行进程</p>
<h2 id="1-2解答"><a href="#1-2解答" class="headerlink" title="1.2解答"></a>1.2解答</h2><h3 id="什么是进程？什么是程序？"><a href="#什么是进程？什么是程序？" class="headerlink" title="什么是进程？什么是程序？"></a>什么是进程？什么是程序？</h3><p>程序是位于磁盘上的代码。而<strong>进程</strong>则是正在执行的程序实例</p>
<h3 id="细说进程的组成？"><a href="#细说进程的组成？" class="headerlink" title="细说进程的组成？"></a>细说进程的组成？</h3><p><strong>进程的内存空间</strong></p>
<p>在32位Linux系统中，进程拥有4GB的虚拟内存，内核1G，用户3G。</p>
<p>进程的用户空间中包含<code>代码、常量数据和用户堆栈</code>等；而内核空间中包含<code>内核栈</code>。</p>
<p><strong>用户栈与内核栈</strong></p>
<p>处于用户态执行时，进程的函数调用等操作都使用<code>用户栈</code></p>
<p>进入内核态后的一些操作都使用<code>内核栈</code>来记录</p>
<h3 id="PCB是什么？"><a href="#PCB是什么？" class="headerlink" title="PCB是什么？"></a>PCB是什么？</h3><p><strong>进程控制块PCB：</strong></p>
<ul>
<li>标志信息（pid、ppid、uid）</li>
<li>处理器信息（保存上下文切换时寄存器中的内容）</li>
<li>进程控制信息（调度、通信）</li>
</ul>
<h3 id="进程状态有哪些？"><a href="#进程状态有哪些？" class="headerlink" title="进程状态有哪些？"></a>进程状态有哪些？</h3><p>创建、就绪、等待、运行、终止</p>
<h3 id="操作系统如何管理进程？"><a href="#操作系统如何管理进程？" class="headerlink" title="操作系统如何管理进程？"></a>操作系统如何管理进程？</h3><p><strong>进程表：</strong>操作系统维护一张<code>进程表</code>，每个表项都代表了一个进程。表项由<code>PID</code>和<code>指向PCB的指针</code>构成</p>
<p><strong>进程操作</strong></p>
<ul>
<li>进程创建<ul>
<li>描述：创建PCB（Linux中表示为<code>task_struct</code>结构体），分配内存空间</li>
<li>命令：<code>fork()</code>，返回子进程PID</li>
</ul>
</li>
<li>处理子进程<ul>
<li>描述：创建子进程后，如果父进程不进行显式处理，子进程就可能变成<code>孤儿</code>或<code>僵尸进程</code></li>
<li>命令：<code>wait()</code>或<code>waitpid()</code>，前者不区分子进程；后者指定子进程pid，且可以设置不阻塞等待</li>
</ul>
</li>
</ul>
<p><strong>进程切换</strong></p>
<ul>
<li>产生原因：中断、时间片到期等</li>
<li>过程：上下文切换，即保存寄存器、程序计数器等数据到进程的PCB中；然后从另一个进程PCB中加载数据到寄存器和PC中。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>操作系统——IO及磁盘</title>
    <url>/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%8C%E3%80%81IO%E5%8F%8A%E7%A3%81%E7%9B%98/</url>
    <content><![CDATA[<h2 id="一、I-O和缓冲区介绍"><a href="#一、I-O和缓冲区介绍" class="headerlink" title="一、I/O和缓冲区介绍"></a>一、I/O和缓冲区介绍</h2><h3 id="1-1抛出问题"><a href="#1-1抛出问题" class="headerlink" title="1.1抛出问题"></a>1.1抛出问题</h3><ol>
<li>什么是IO，有哪些IO类型</li>
<li>进程发起IO请求的过程是怎样的</li>
<li>操作系统怎样处理IO，对IO做了哪些优化</li>
</ol>
<h3 id="1-2阅读文章"><a href="#1-2阅读文章" class="headerlink" title="1.2阅读文章"></a>1.2阅读文章</h3><p><a href="https://houbb.github.io/2020/10/04/os-15-io-cache-buffer">磁盘高速缓存——各类缓冲区介绍</a></p>
<p><a href="https://cloud.tencent.com/developer/news/406991">缓存IO与直接IO</a></p>
<h3 id="1-3理解"><a href="#1-3理解" class="headerlink" title="1.3理解"></a>1.3理解</h3><p>进程在执行时可能需要读取键盘输入、或向磁盘输出数据，这些操作都属于I/O</p>
<p>IO类型：用户（键盘鼠标交互）、磁盘等外设、网络通信</p>
<h4 id="I-O控制"><a href="#I-O控制" class="headerlink" title="I/O控制"></a>I/O控制</h4><p>最开始是由CPU直接向IO设备下达指令，并且要阻塞等待IO操作完成</p>
<p>后来：</p>
<ul>
<li><strong>IO模块</strong>封装各类IO的细节，向上层提供api。</li>
<li><strong>中断指令</strong>可以让CPU执行其他进程，IO操作结束后发送中断指令给CPU，再让其切换到发起IO操作的进行来执行。<ul>
<li><code>问题</code>中断指令是怎么发起的，是硬件提供的，还是操作系统提供的？</li>
</ul>
</li>
<li><strong>DMA模块</strong><code>直接存储访问</code>可以让内存与IO模块直接进行数据传输，CPU只需要在IO开始和结束时进行干涉。</li>
</ul>
<h4 id="I-O缓冲"><a href="#I-O缓冲" class="headerlink" title="I/O缓冲"></a>I/O缓冲</h4><p><strong>局限性</strong></p>
<p>我们都知道读写IO的速度是比CPU执行速度慢很多的</p>
<p>所以当一个进程在读取磁盘上的数据块时，它会挂起（切换其他进程执行）或一直等待</p>
<p>但是因为数据会读到进程的工作空间，所以这个进程的工作空间会被锁住，确保在等待IO期间不被换下（例如分页中的页置换）</p>
<p><strong>优化</strong></p>
<p>操作系统提供I/O缓冲区，缓冲策略可以是读完一个数据块后，立刻读后面的</p>
<h2 id="二、磁盘"><a href="#二、磁盘" class="headerlink" title="二、磁盘"></a>二、磁盘</h2><h3 id="2-1抛出问题"><a href="#2-1抛出问题" class="headerlink" title="2.1抛出问题"></a>2.1抛出问题</h3><ol>
<li>磁盘结构、常用术语</li>
<li>向磁盘读/写数据的过程</li>
<li>磁盘调度算法有哪些，什么场景下用哪个会更好，调度算法是在哪个过程用的</li>
</ol>
<h3 id="2-2阅读文章"><a href="#2-2阅读文章" class="headerlink" title="2.2阅读文章"></a>2.2阅读文章</h3><p><a href="https://www.cnblogs.com/iwehdio/p/13681037.html">IO控制、IO缓冲、磁盘调度</a></p>
<h3 id="2-3总结"><a href="#2-3总结" class="headerlink" title="2.3总结"></a>2.3总结</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><strong>柱面、盘面、磁臂、磁头、磁道、扇区、转速</strong></p>
<h4 id="读写过程"><a href="#读写过程" class="headerlink" title="读写过程"></a>读写过程</h4><ul>
<li><p><strong>寻道</strong></p>
<ul>
<li><code>描述</code>：磁头找到对应的柱面（C、D、E盘等等），然后在盘面上找到对应的磁道</li>
<li><code>时间计算</code>：$T_{寻道}=T_{磁头启动}+m*n(跨越n个磁道，每个磁道耗时m)$</li>
<li><code>优化思路</code>：减少跨越磁道的个数，即<strong>磁盘调度算法</strong></li>
</ul>
</li>
<li><p><strong>旋转延迟</strong></p>
<ul>
<li><code>描述</code>：磁盘要旋转一段距离，好让磁头定位到目标扇区</li>
<li><code>时间计算</code>：$T_{旋转}=\frac{1}{2r}，假设平均需要转半圈$</li>
</ul>
</li>
<li><p><strong>传输</strong></p>
<ul>
<li><code>描述</code>：接下来磁盘继续旋转，这次是进行读写了。</li>
<li><code>时间计算</code>：$T_{传输}=\frac{b}{rN}，表示读写b个字节，磁道总字节为N$</li>
<li><code>优化思路</code>：数据放一块，可以顺序读写，避免再次寻道（随机IO）</li>
</ul>
</li>
</ul>
<p><strong>所以在磁盘上的耗费时间也可以计算：寻道时间、旋转延迟、传输时间</strong></p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p><strong>使用场景</strong></p>
<p>每个IO设备应该都有一个队列，如果磁盘正在处理某次IO，那么其他IO请求就会在队列中等待。</p>
<p>如果按请求进来的顺序执行，就可能存在请求的磁盘位置过于分散，寻道时间大大增加的情况。</p>
<p><strong>调度算法大致有三种类型：队列式、最短距离、扫描</strong></p>
<ul>
<li><strong>FIFO</strong><ul>
<li><code>描述</code>：按队列顺序来处理IO请求</li>
<li><code>缺点</code>：大部分情况就是随机IO</li>
<li><code>应用</code>：访问位置比较密集时，性能还说得上去</li>
<li><code>变种</code>：<strong>LIFO</strong>后进来的先处理，充分利用了局部性</li>
</ul>
</li>
<li><strong>SSTF</strong><ul>
<li><code>描述</code>：每次选择与当前磁道最近的请求进行执行</li>
<li><code>缺点</code>：可能会出现饥饿，距离远的永远达不到；还有就是得计算距离</li>
<li><code>应用</code>：比FIFO快蛮多的</li>
</ul>
</li>
</ul>
<p>下面是扫描算法，有好几种变种</p>
<ul>
<li><p><strong>SCAN</strong></p>
<ul>
<li><code>描述</code>：磁臂沿着一个方向扫描，处理遇到的所有请求，到边界后再调头扫描</li>
<li><code>缺点</code>：对磁臂周围的局部区域不公平，因为等待时间长；多余扫描</li>
</ul>
</li>
<li><p><strong>C-SCAN</strong></p>
<ul>
<li><code>描述</code>：和SCAN类似，但它不调头，而是重复从起点到终点的扫描</li>
<li><code>应用</code>：这样对局部区域比较公平</li>
<li><code>缺点</code>：还有个缺点没解决，就是多余扫描</li>
</ul>
</li>
<li><p><strong>C-LOOK</strong></p>
<ul>
<li><code>描述</code>：前面没有请求了，就直接回到起点</li>
</ul>
</li>
<li><p>N步SCAN：把请求队列划分成多个长度为N的子队列</p>
</li>
<li><p>FSCAN：用两个子队列，新请求全放在另一个队列中</p>
</li>
</ul>
<h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>IO请求多时，一个磁盘处理不过来</p>
<p>那就用多个磁盘集成在一起，就是RAID了</p>
<h4 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h4><p>跟CPU和内存之间建立的高速缓存一样，内存中有一块地方专门做磁盘的缓存。</p>
<p>IO请求先判断能否命中磁盘高速缓存，再去决定是否进行IO</p>
<p><strong>命中缓存时，如何把数据交给进程</strong></p>
<ul>
<li>就硬传，把数据传到进程的工作空间</li>
<li>以共享内存的方式，把地址传给进程即可</li>
</ul>
<p><strong>新的磁盘IO完成后，高速缓存要存入新的数据，采取怎样的更新策略（页置换）</strong></p>
<ul>
<li><strong>LRU</strong><ul>
<li>最近最少使用</li>
<li>用栈（双端队列）维护，每次用到一个页，把它放到栈顶。置换时把栈底（最久没用过）的换出去</li>
<li>缺点：如果大量读入新的页，可能会导致热点页来到栈底，被置换出去</li>
</ul>
</li>
<li><strong>LFU</strong><ul>
<li>使用频率最低</li>
<li>对每个页计数</li>
<li>缺点：可能某个页刚放进来又被置换出去了，对局部性情况不友好。</li>
</ul>
</li>
</ul>
<h2 id="三、Linux中的IO"><a href="#三、Linux中的IO" class="headerlink" title="三、Linux中的IO"></a>三、Linux中的IO</h2><h3 id="3-1抛出问题"><a href="#3-1抛出问题" class="headerlink" title="3.1抛出问题"></a>3.1抛出问题</h3><ol>
<li>IO的读写过程，缓冲区？</li>
<li>执行IO的方式有哪些，系统调用和stdio库函数的区别？</li>
<li>关于磁盘的一些常用指令</li>
</ol>
<h3 id="3-2阅读文章"><a href="#3-2阅读文章" class="headerlink" title="3.2阅读文章"></a>3.2阅读文章</h3><p><a href="https://www.litreily.top/2018/10/25/io-cache/">Linux中的文件I/O缓冲</a></p>
<p><a href="https://segmentfault.com/a/1190000018499770">一文掌握 Linux 性能分析之 I/O 篇</a></p>
<h3 id="3-3理解"><a href="#3-3理解" class="headerlink" title="3.3理解"></a>3.3理解</h3><h4 id="执行IO的过程"><a href="#执行IO的过程" class="headerlink" title="执行IO的过程"></a>执行IO的过程</h4><p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210818012302.jpg"></p>
<p>可以看到其实有两层IO</p>
<ol>
<li><p>首先是在用户空间中，如果调用的是封装的<strong>stdio</strong>库函数的话，它会先处理库提供的缓冲</p>
</li>
<li><p>然后<strong>stdio</strong>库底层实际上也是read、write等系统调用，因此还有内核空间的文件IO缓冲<code>和磁盘高速缓存有什么区别？</code></p>
</li>
</ol>
<h4 id="磁盘IO相关指令"><a href="#磁盘IO相关指令" class="headerlink" title="磁盘IO相关指令"></a>磁盘IO相关指令</h4><p><strong>磁盘基本信息</strong></p>
<ul>
<li>fdisk -l<ul>
<li>磁盘大小、扇区个数和大小。</li>
</ul>
</li>
<li>df<ul>
<li>各个磁盘的使用情况，如剩余空间、利用率等等。</li>
</ul>
</li>
</ul>
<p><strong>磁盘性能分析</strong></p>
<ul>
<li>vmstat<ul>
<li>正在等待的IO任务数、每秒读写磁盘块数</li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210830123620.png" alt="image-20210830123620336"></p>
<ul>
<li>iostat <code>专业分析IO性能的工具</code><ul>
<li>安装：sudo yum install sysstat</li>
<li>使用：iostat（-c，-d）</li>
</ul>
</li>
<li>iotop<ul>
<li>进程维度的IO情况分析</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统——内存管理</title>
    <url>/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="一、内存基础"><a href="#一、内存基础" class="headerlink" title="一、内存基础"></a>一、内存基础</h2><h3 id="1-1问题"><a href="#1-1问题" class="headerlink" title="1.1问题"></a>1.1问题</h3><ol>
<li>什么是内存，它在计算机中的作用</li>
<li>内存的结构是怎样的，它是如何分区的</li>
<li>分区之后，应采取怎样的策略来给进程分配内存空间（放置算法或者说分配策略）</li>
</ol>
<h3 id="1-2解答"><a href="#1-2解答" class="headerlink" title="1.2解答"></a>1.2解答</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>重定位</strong>：进程被换出后再次换进到内存中，会分配到一个不同的内存区域上，因此原先的指令就要做一个映射</li>
<li><strong>保护</strong>：每个进程的内存区域不应该被其他进程所干扰，处理器的硬件层面上应该提供这个判断</li>
<li><strong>共享</strong>：多个程序执行时，可能会有共享一些数据的需求，操作系统需要管理这块共享内存</li>
<li><strong>逻辑组织与物理组织</strong>：逻辑地址连续，物理地址不连续</li>
</ul>
<h4 id="分区的方式"><a href="#分区的方式" class="headerlink" title="分区的方式"></a>分区的方式</h4><p>简单来看，有两种分区的方式，即<strong>固定分区</strong>和<strong>动态分区</strong>。</p>
<p><strong>固定分区</strong></p>
<ul>
<li>定义：内存分为固定大小的块，每块可以相同，也可以不同</li>
<li>缺点<ul>
<li>会有大量的内部碎片产生</li>
<li>限制了活动进程的最大数量</li>
</ul>
</li>
<li>优点：分配简单</li>
</ul>
<p><strong>动态分区</strong></p>
<ul>
<li>定义：根据进程大小来按需分配</li>
<li>缺点：随着进程的换进换出，会产生外部碎片</li>
<li>特点：需要考虑内存的<strong>分配策略</strong>，下面介绍</li>
</ul>
<p><strong>内存分配策略</strong></p>
<ul>
<li>首次适配：从头开始，匹配满足条件的第一块内存</li>
<li>下次适配：从上次分配的地方开始，匹配满足条件的第一块内存</li>
<li>最佳适配：全量扫描，找到最佳的内存块进行分配</li>
</ul>
<h4 id="一种特殊的分区方式：伙伴系统"><a href="#一种特殊的分区方式：伙伴系统" class="headerlink" title="一种特殊的分区方式：伙伴系统"></a>一种特殊的分区方式：伙伴系统</h4><p><strong>描述</strong></p>
<ol>
<li>最开始将内存看成一块整体</li>
<li>当请求内存大小为<code>x</code>时，将一块内存分成等大的两块，即$2^n=2^{n-1} + 2^{n-1}$</li>
<li>直到满足$2^{k-1}&lt;x&lt;=2^k$时，把大小为$2^k$的内存块分配出去。</li>
</ol>
<p><strong>思路：把大于所需内存的第一个2的整数次幂大小的内存块分配出去。</strong></p>
<h4 id="分页、分段"><a href="#分页、分段" class="headerlink" title="分页、分段"></a>分页、分段</h4><p>不管是分页还是分段，都需要将<code>逻辑地址</code>转化为<code>物理地址</code></p>
<p><strong>逻辑地址</strong>：包含了页号和页偏移</p>
<p><strong>物理地址</strong>：物理页的起始地址+页内偏移量</p>
<p>借助<code>页表</code>或<code>段表</code>，通过映射得到物理页的位置，然后再加上页内偏移量就得到最终的物理地址。</p>
<h4 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h4><p><strong>OPT</strong></p>
<ul>
<li>描述：最优策略，置换下次使用距离当前最久的那一页</li>
<li>特点：理想的算法，一般作为参考</li>
</ul>
<p><strong>FIFO</strong></p>
<ul>
<li>描述：先来的页先置换，其实就是把驻留在内存中最久的页置换出去</li>
<li>缺点：对于间隔一段时间后重复使用的页，不太友好</li>
</ul>
<p><strong>LRU</strong></p>
<ul>
<li>描述：把最久未使用的页置换出去</li>
<li>缺点：实现复杂，维护困难（需要维护一个栈）</li>
</ul>
<p><strong>LFU</strong></p>
<ul>
<li>描述：把使用频率最低的页置换出去</li>
<li>缺点：对局部性原理不友好，刚置换进来的页可能又被置换出去了</li>
</ul>
<p><strong>时钟</strong></p>
<ul>
<li>描述：对FIFO的一种优化，同时又希望性能可以逼近LRU</li>
<li>特点：实现相对简单一些</li>
<li>算法<ul>
<li>每页加入内存时，<code>使用位</code>置1</li>
<li>用到某页时：<code>使用位</code>置1</li>
<li>缺页时：从指针开始遍历，遇1置0，遇0则直接置换；然后指针指向下一页，作为下次缺页时的起点</li>
</ul>
</li>
</ul>
<h2 id="二、虚拟内存"><a href="#二、虚拟内存" class="headerlink" title="二、虚拟内存"></a>二、虚拟内存</h2><h3 id="2-1问题"><a href="#2-1问题" class="headerlink" title="2.1问题"></a>2.1问题</h3><ol>
<li>对虚拟内存的简单理解，为什么会有虚拟内存</li>
<li>虚拟内存如何实现虚拟地址到物理地址的转换，转换的过程是怎样的</li>
</ol>
<h3 id="2-2解答"><a href="#2-2解答" class="headerlink" title="2.2解答"></a>2.2解答</h3><h4 id="虚拟内存的由来"><a href="#虚拟内存的由来" class="headerlink" title="虚拟内存的由来"></a>虚拟内存的由来</h4><p>上面提到的分页分段以及内存分配是最简单粗暴的方式，即把整个进程加入到内存中。</p>
<p>事实上，我们只需把进程中<strong>要执行的部分</strong>添加到内存中即可，剩余的可以留在磁盘等辅存中。</p>
<p>通过这种方式，我们可以给进程和用户一种<strong>错觉</strong>，让它们觉得每个人都有4GB的内存空间，而实际上在进程执行时，<strong>内存中只保留了正在执行和将要执行的部分页</strong>，其余页都在磁盘中，等待置换。这就是<strong>虚拟内存</strong>的思想</p>
<h3 id="虚拟地址转化为物理地址"><a href="#虚拟地址转化为物理地址" class="headerlink" title="虚拟地址转化为物理地址"></a>虚拟地址转化为物理地址</h3><p><strong>普通页表、多级页表</strong></p>
<ul>
<li>描述：页表项和虚拟地址一一对应</li>
<li>理解：假设页号为5，那么在页表中查找5对应的页框号，因此<strong>虚拟地址越大，页表就会越大。</strong></li>
</ul>
<p><strong>倒排页表</strong></p>
<ul>
<li>描述：维护哈希表和倒排表。</li>
<li>理解：以页号为键，在哈希表中得到一个指针，指向倒排表；而倒排表中每项与物理页框一一对应，因此<strong>物理内存越大，页表越大</strong></li>
</ul>
<h3 id="转化过程"><a href="#转化过程" class="headerlink" title="转化过程"></a>转化过程</h3><p>省略了TLB缓冲区和内存高速缓存……</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210831205328.png" alt="image-20210831205328599"></p>
<h2 id="三、Linux内存管理"><a href="#三、Linux内存管理" class="headerlink" title="三、Linux内存管理"></a>三、Linux内存管理</h2><p><a href="https://zhuanlan.zhihu.com/p/149581303">linux内存管理</a></p>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><p>使用3级页表，分别是全局目录，页中间目录和页表。</p>
<p>对于某些已有两级分页的硬件，页中间目录大小会设置为1</p>
<h4 id="页面分配"><a href="#页面分配" class="headerlink" title="页面分配"></a>页面分配</h4><p>分配内存采用<code>伙伴算法</code>，维护多种不同大小的页框组</p>
<p><strong>内核内存分配</strong></p>
<ul>
<li>描述：伙伴算法分配的最小空间就是一页，但是内核所需的空间可能经常小于1页。因此在分配小块内存时，使用了<code>slab</code>分配方案。</li>
<li>大致介绍：<ul>
<li>slab是对伙伴算法的补充，维护了一个小内存的缓冲区。</li>
<li>当申请小块内存时，从缓冲区中取</li>
<li>释放时也回到缓冲区中，而不是交给伙伴算法中的链表。</li>
</ul>
</li>
</ul>
<h4 id="页置换算法"><a href="#页置换算法" class="headerlink" title="页置换算法"></a>页置换算法</h4><p><strong>1.时钟算法</strong></p>
<p>Linux2.6.28以前使用的是基于LFU的时钟算法，通过<code>使用位</code>来计数；每次访问某页时，使用位加1。</p>
<p>此外，Linux会在后台周期性的扫描页池，将扫描到的页<code>使用位减一</code>，这样<code>使用位为0</code>的页就是最适合置换的页。</p>
<p><strong>缺点：周期性的扫描会占用处理器的时间</strong></p>
<p><strong>2.两级LRU算法</strong></p>
<p>从Linux2.6.28开始，使用两级的LRU算法。</p>
<p>算法：</p>
<ul>
<li>维护两个链表，分别代表不活跃和活跃的内存页</li>
<li>在超时时间内，一个页如果被访问两次，就会从<code>不活跃链表</code>移到<code>活跃链表</code>中</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210906112000.png" alt="image-20210906111953408"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统——系统调用</title>
    <url>/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%80%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="阅读文章"><a href="#阅读文章" class="headerlink" title="阅读文章"></a>阅读文章</h2><p><a href="https://www.cnblogs.com/chenwb89/p/operating_system_002.html">操作系统篇之一：浅谈实模式与保护模式</a></p>
<p><a href="https://www.cnblogs.com/chenwb89/p/operating_system_003.html">操作系统篇之二：分段机制与GDT|LDT</a></p>
<p><a href="https://www.cnblogs.com/chenwb89/p/operating_system_004.html">操作系统篇之三：调用门与特权级（CPL、DPL和RPL)</a></p>
<p><a href="https://www.cnblogs.com/jiading/p/12606978.html">操作系统篇之四：中断和系统调用</a></p>
<p><strong>「操作系统」</strong>向下管理底层硬件，向上提供计算机的基础服务，如文件管理、内存管理、进程管理等等。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><blockquote>
<p>系统调用是操作系统提供给上层的功能的接口</p>
</blockquote>
<h3 id="为什么会有系统调用？"><a href="#为什么会有系统调用？" class="headerlink" title="为什么会有系统调用？"></a>为什么会有系统调用？</h3><p><strong>思考</strong></p>
<p>运行时数据都在内存中，用户为什么要通过系统调用，而不是直接去内存中取？</p>
<p><strong>解答</strong></p>
<p>是为了数据安全和操作的难易程度考虑。</p>
<p>如果用户可以直接操作内存，那么对内存地址的改动，就很有可能会造成应用程序的崩溃，早期的操作系统经常蓝屏死机就是这个原因。</p>
<h3 id="怎样隔离用户直接操作内存的情况"><a href="#怎样隔离用户直接操作内存的情况" class="headerlink" title="怎样隔离用户直接操作内存的情况"></a>怎样隔离用户直接操作内存的情况</h3><p>实模式与保护模式</p>
<p>系统刚开机或重启那会儿处于实模式，之后便处于保护模式中。</p>
<p>而在保护模式中，有一个叫做<code>特权级</code>的概念，其中，</p>
<ul>
<li>CPL：当前进程的权限级别</li>
<li>DPL：某个内存段的固定权限级别</li>
<li>RPL：进程请求某个内存段时的权限</li>
</ul>
<p><del>如果进程在内核态，它的CPL就会变成0；当它访问某块DPL为3的内存时，</del></p>
<h3 id="既然隔离了，怎样进入内核态呢"><a href="#既然隔离了，怎样进入内核态呢" class="headerlink" title="既然隔离了，怎样进入内核态呢"></a>既然隔离了，怎样进入内核态呢</h3><p>对于<code>Intel x86</code>，硬件提供了中断指令<code>int</code></p>
<p>当发生系统调用时，C语言会把代码解析成汇编指令，然后通过中断指令进入内核态（实际上是修改DPL为3，然后再改回来，从而得到权限）</p>
<h3 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h3><ol>
<li><p>保存<strong>系统调用号</strong>和<strong>输入参数</strong></p>
</li>
<li><p>模式切换，由<strong>用户态</strong>切换到<strong>内核态</strong></p>
</li>
<li><p>找到并执行对应服务<strong>例程</strong></p>
<ul>
<li><p><code>例程</code>：操作系统封装的各类服务API</p>
</li>
<li><p><code>过程</code>：通过<code>system_call</code>内核函数在<code>系统调用表</code>中找到<code>系统调用号</code>对应的服务例程</p>
</li>
</ul>
</li>
<li><p>处理完毕后返回<strong>用户态</strong></p>
</li>
</ol>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><blockquote>
<p>系统调用其实就是<strong>软中断</strong>的一种具体实现。</p>
</blockquote>
<h3 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h3><p>中断可以分为同步中断和异步中断。</p>
<ul>
<li>异步中断：硬件设备产生的中断</li>
<li>同步中断（异常）：由CPU控制单元发出的中断，且要在指令执行完毕后才会发出</li>
</ul>
<h3 id="硬中断的执行过程"><a href="#硬中断的执行过程" class="headerlink" title="硬中断的执行过程"></a>硬中断的执行过程</h3><p><strong>中断产生：</strong></p>
<ul>
<li>情况：IO中断（完成IO）、失效中断（断电）</li>
<li>传输：上述情况发生时，硬件产生<strong>电信号</strong>，通过中断线到达<strong>中断控制器</strong>中。</li>
</ul>
<p><strong>中断处理：</strong></p>
<ul>
<li>中断控制器将<strong>中断类型号</strong>发送给CPU，请求执行</li>
<li>CPU查询<strong>中断向量表</strong>，找到对应的中断服务例程并执行</li>
<li>例程调用对应的<strong>设备驱动</strong>与外部设备进行通信和处理</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令学习</title>
    <url>/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一、基本命令"><a href="#一、基本命令" class="headerlink" title="一、基本命令"></a>一、基本命令</h2><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p><code>cd [path]</code>：前往指定的路径</p>
<ul>
<li><code>cd -</code>：返回到上次的路径</li>
<li><code>cd ~</code>：前往当前用户的用户目录</li>
<li><code>cd /</code>：前往根目录</li>
</ul>
<p><code>pwd</code>：打印当前路径</p>
<h3 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h3><p><code>mkdir [dir_name]</code>：创建一个目录</p>
<p><code>cp [src] [dst]</code>：复制文件</p>
<p><code>mv [src] [dst]</code>：移动文件（也可以用来重命名文件）</p>
<p><code>rm [path]</code>：删除文件</p>
<ul>
<li><code>-r</code>：表示递归的删除整个目录或文件</li>
<li><code>-f</code>：表示不需要确认</li>
</ul>
<h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p><strong>1. 搜索命令、程序等</strong></p>
<p><code>which</code>：在<strong>PATH</strong>指定的路径中查找。（一般用于查找命令）</p>
<p><code>whereis</code>：用于程序名的搜索，如二进制、man说明文件和源代码文件</p>
<p><strong>2. 常规搜索</strong></p>
<p><code>find [path] [condition]</code>：在指定目录中根据某些条件进行查询</p>
<ul>
<li><code>-name logfile</code>：查询文件名为logfile的文件</li>
<li><code>-perm 644</code>：查询权限为644的文件</li>
</ul>
<p><code>locate</code>：可以等价于<code>find -name</code>方式，但是它是从文件数据库中进行查询，因此速度更快。</p>
<h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><p>压缩：<code>gzip [path]</code></p>
<p>解压缩：<code>gzip -d [path]</code></p>
<p>此外，使用<code>tar -czvf [dst] [src]</code>和<code>tar -zxf [src]</code>也可以实现压缩和解压。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><code>ln [src] [dst]</code>命令可以与文件建立链接，其中：</p>
<ul>
<li><strong>硬链接：</strong>一个文件的所有硬链接使用同一个<code>inode</code>。最开始的源文件可以视为是一个硬链接。</li>
<li><strong>软链接<code>-s</code>：</strong>类似于快捷方式的存在，它存储的是<code>源文件的地址</code>，因此源文件删除后就无法再通过软链接来读取</li>
</ul>
<h3 id="grep与xargs"><a href="#grep与xargs" class="headerlink" title="grep与xargs"></a>grep与xargs</h3><p>在管道用法中，比较常见的两个命令就是<code>grep</code>和<code>xargs</code></p>
<ul>
<li><p><code>grep</code>：查询符合条件的字符串</p>
</li>
<li><p><code>xargs</code>：将上游的输出作为下游的输入参数</p>
</li>
</ul>
<p><strong>grep用法</strong></p>
<p><code>tail -f log | grep &quot;error&quot;</code></p>
<p>监听并输出log日志，并查询其中的error字符串（即高亮显示）</p>
<p><strong>xargs用法</strong></p>
<p><code>find . -perm 644 | xargs -I @ mv @ ../newDir</code></p>
<p>查询当前目录中权限为644的所有文件，并移动到指定目录中</p>
<p><code>xargs</code>的<code>-I</code>参数可以定义一个指示符，这里定义为**@<strong>。然后在后面的<code>mv</code>命令中就可以使用</strong>@**来表示参数应放的位置。</p>
<h2 id="二、用户管理"><a href="#二、用户管理" class="headerlink" title="二、用户管理"></a>二、用户管理</h2><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><p><strong>操作用户</strong></p>
<p><code>useradd [username]</code></p>
<p><code>passwd [username]</code></p>
<p><code>userdel [username]</code></p>
<p><code>usermod -g [groupname] [username]</code>：修改某个用户所属的组</p>
<p><strong>操作组</strong></p>
<p><code>groupadd [groupname]</code></p>
<p><code>groupmod [groupname]</code></p>
<p><code>groupdel [groupname]</code></p>
<h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>有三个和用户信息相关的文件，分别是：</p>
<p><code>/etc/passwd</code>：</p>
<p>记录用户基本信息，如用户名、UID、GID等等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># structure </span></span><br><span class="line"><span class="comment"># name:password:uid:gid:comment:directory:shell</span></span><br><span class="line"><span class="comment"># example</span></span><br><span class="line">whz:x:1001:1001::/home/whz:/bin/bash</span><br></pre></td></tr></table></figure>

<p><code>/etc/shadow</code>：记录加密形式的用户密码，只有root用户才能够查看</p>
<p><code>/etc/group</code>：记录组信息</p>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><blockquote>
<p>测试<strong>passwd</strong>命令时发现，普通用户可以修改自己的密码，但是<code>/etc/passwd</code>或<code>/etc/shadow</code>对普通用户来说都是没有权限的，那么它是怎么做到的呢？</p>
</blockquote>
<blockquote>
<p>TIPS</p>
<p><code>/etc/passwd</code>是文件，存储了用户信息。</p>
<p><code>/usr/bin/passwd</code>是命令，修改密码时调用的。</p>
</blockquote>
<p>答案就在<code>/usr/bin/passwd</code>这个命令自身上。</p>
<p>查看<code>passwd</code>命令的权限，发现一个特殊的权限<code>s</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwsr-xr-x. 1 root root 33600 4月   6 2020 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p><code>s(Set UID)</code>表示文件在执行时暂时拥有文件所有者的权限（本例即root权限）。正因为有了root权限，普通用户才得以成功修改密码。</p>
<h2 id="三、Shell脚本"><a href="#三、Shell脚本" class="headerlink" title="三、Shell脚本"></a>三、Shell脚本</h2><p>shell脚本一般以<code>#!/bin/bash</code>作为开头。</p>
<p>下面是一个kafka集群（部署在单台虚拟机上）的启动和关闭脚本示例</p>
<ol>
<li>使用<code>$1</code>来获取执行脚本的第一个参数</li>
<li>case语法来判断参数是<code>start</code>还是<code>stop</code></li>
<li>通过循环来执行kafka提供的启动脚本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">case $1 in </span><br><span class="line">&quot;start&quot;)&#123;</span><br><span class="line"></span><br><span class="line">        for i in kafka1 kafka2 kafka3</span><br><span class="line">        do </span><br><span class="line">                echo &quot;------------ start $i ------------&quot;</span><br><span class="line">                /usr/local/service/$i/bin/kafka-server-start.sh -daemon /usr/local/service/$i/config/server.properties</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">&#125;;;</span><br><span class="line"></span><br><span class="line">&quot;stop&quot;)&#123;</span><br><span class="line">        echo &quot;------------ stop kafka ------------&quot;</span><br><span class="line">        bash /usr/local/service/kafka1/bin/kafka-server-stop.sh</span><br><span class="line">&#125;;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h2 id="四、Systemd"><a href="#四、Systemd" class="headerlink" title="四、Systemd"></a>四、Systemd</h2><h3 id="systemd与systemctl"><a href="#systemd与systemctl" class="headerlink" title="systemd与systemctl"></a>systemd与systemctl</h3><blockquote>
<p><strong>systemd</strong>是Linux系统的一种启动方式，它代替了原先<strong>init</strong>进程的启动方式。</p>
<p><strong>systemctl</strong>是一组控制systemd系统和进行服务管理的命令。</p>
</blockquote>
<p><strong>init</strong>进程采用串行启动的方式，启动时间较长；而<strong>systemd</strong>引入了并行启动的概念。</p>
<p>此外，使用<strong>systemd</strong>后也是存在争议的，因为它违背了Unix的哲学<code>keep it simple, stupid</code>。</p>
<h3 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h3><ul>
<li><code>systemctl start [service]</code></li>
<li><code>systemctl stop [service]</code></li>
<li><code>systemctl restart [service]</code></li>
<li><code>systemctl reload [service]</code></li>
<li><code>systemctl status [service]</code></li>
</ul>
<h2 id="五、权限控制"><a href="#五、权限控制" class="headerlink" title="五、权限控制"></a>五、权限控制</h2><h3 id="传统的权限控制"><a href="#传统的权限控制" class="headerlink" title="传统的权限控制"></a>传统的权限控制</h3><p>在Linux系统中，存在一种传统的权限控制方式：<strong>UGO</strong>，即<code>user-group-other</code>。</p>
<p>ugo把文件的操作者分为三类：<strong>所有者、同组用户和其他用户</strong>。每类用户都按照<code>读、写、执行</code>来分配权限。</p>
<p>新建的目录权限为<code>775</code>，文件为<code>664</code>，这是由默认的<code>777</code>、<code>666</code>权限减去掩码<code>0002</code>得到的。</p>
<hr>
<p>现代的权限控制有两种：<code>ACL</code>和<code>SELinux</code></p>
<h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><blockquote>
<p>Access Control List 是一张表，告知操作系统每个用户对于某个文件来说具备何种权限。</p>
<p>每个文件都拥有一个属性标志着它的权限控制表，表中的每个条目都对应着一个用户所拥有的权限。</p>
</blockquote>
<p><strong>ACL</strong>是对<strong>UGO</strong>的扩展，因为<strong>UGO</strong>进行权限控制的维度是所有者、同组用户和其他用户，无法从更加细化的维度（如每个用户）进行管理。</p>
<p><strong>相关命令</strong></p>
<p><code>getfacl [file]</code>：打印某个文件的ACL规则</p>
<p><code>setfacl -m u:[username]:[rwx] [file]</code>：为某个文件设置一条关于用户的ACL规则，权限为rwx</p>
<hr>
<p>上面提到的两种权限控制都属于<strong>自主访问控制</strong>（DAC），权限管理的主体是用户，只要用户拥有相应文件的权限，就可以访问该文件。</p>
<p>在DAC中，他人一旦非法获得root权限，那么整个操作系统就可能会受到不可预估的后果。</p>
<h3 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h3><blockquote>
<p>SELinux是一种强安全性的权限控制策略，它是<strong>强制访问控制</strong>（MAC）的一种典型形式。</p>
</blockquote>
<p>在SELinux的操作系统中，决定一个资源是否被访问的因素除了上述的<strong>读写执行权限</strong>外，还需要判断每一类进程是否拥有对某一类资源的访问权限。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>评论</title>
    <url>/2021/12/13/TODO/%E8%AF%84%E8%AE%BAadded/</url>
    <content><![CDATA[<p>发现下载的资料里很多都是ziw文件，需要手动改成zip后才能进行解压。这里提供下批量改成zip后缀的代码。[呲牙]</p>
<pre><code>public static void renameZip()  &#123;
    String rootPath = &quot;E:\BaiduNetdiskDownload\在线教育--谷粒学院&quot;;
    File root = new File(rootPath);
    renameZip(root);
&#125;
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">renameZip</span><span class="params">(File root)</span> </span>&#123;</span><br><span class="line">    File[] currentFiles = root.listFiles();</span><br><span class="line">	String fileName; <span class="comment">// 当前文件名</span></span><br><span class="line">	File dstFile;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(File file : currentFiles) &#123;</span><br><span class="line">    	<span class="comment">// 是目录则继续往下递归</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            renameZip(file); </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fileName = file.getName()).length() &gt;= <span class="number">3</span> &amp;&amp;</span><br><span class="line">                <span class="string">&quot;ziw&quot;</span>.equals(fileName.substring(fileName.length() - <span class="number">3</span>))) &#123;</span><br><span class="line">            <span class="comment">// 修改后缀 ziw -&gt; zip</span></span><br><span class="line">            String absolutePath = file.getAbsolutePath();</span><br><span class="line">            dstFile = <span class="keyword">new</span> File(absolutePath.substring(<span class="number">0</span>, absolutePath.length() - <span class="number">3</span>) + <span class="string">&quot;zip&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!dstFile.exists()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> successToRename = file.renameTo(dstFile);</span><br><span class="line">                <span class="keyword">if</span> (!successToRename) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;fail to rename file: &quot;</span> + file.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TODO</category>
      </categories>
  </entry>
  <entry>
    <title>记录</title>
    <url>/2021/12/13/TODO/tmp/</url>
    <content><![CDATA[<h3 id="1-java-关于线程的一些操作，如wait，join，interrupt等"><a href="#1-java-关于线程的一些操作，如wait，join，interrupt等" class="headerlink" title="1.java 关于线程的一些操作，如wait，join，interrupt等"></a>1.java 关于线程的一些操作，如wait，join，interrupt等</h3><h3 id="2-wait、notify是什么，为什么只能在同步代码中用"><a href="#2-wait、notify是什么，为什么只能在同步代码中用" class="headerlink" title="2.wait、notify是什么，为什么只能在同步代码中用"></a>2.wait、notify是什么，为什么只能在同步代码中用</h3><p><strong>Redis</strong></p>
<ul>
<li><code>缓存雪崩</code>、<code>击穿</code>具体概念及解决方案</li>
<li>常见5种数据类型</li>
</ul>
<p><strong>Java线程、多线程</strong></p>
<ul>
<li><code>threadlocal</code>是什么，怎么用</li>
<li><code>join</code>方法</li>
<li><code>FutureTask</code>是什么，怎么用</li>
<li><code>cyclicbarrier</code>、<code>countdownlatch</code>底层实现</li>
<li>CAS底层</li>
<li>开线程数</li>
<li>打印奇数、偶数</li>
<li>start和run区别</li>
</ul>
<p><strong>JVM</strong></p>
<ul>
<li><code>类加载详解</code></li>
<li><code>垃圾收集器详解</code></li>
</ul>
<p><strong>MySQL</strong></p>
<ul>
<li><code>explain</code>输出内容了解一下</li>
<li>什么情况下会<code>索引失效</code></li>
<li>查询优化</li>
<li>视图</li>
<li>三范式</li>
</ul>
<p><strong>算法</strong></p>
<ul>
<li>旋转数组，二分查找求最值</li>
</ul>
<p><strong>操作系统</strong></p>
<ul>
<li>进程、线程区别</li>
<li>上下文切换</li>
<li>进程通信方式：管道</li>
<li>死锁：四个条件</li>
</ul>
<p><strong>计网</strong></p>
<ul>
<li>osi七层模型</li>
</ul>
<h2 id="My"><a href="#My" class="headerlink" title="My"></a>My</h2><p><strong>数据库：abcde字段</strong></p>
<p><strong>原子类、CAS底层</strong></p>
<p><strong>volatile</strong></p>
<p>redis数据结构、排序相关的</p>
<p>四种隔离级别有什么作用</p>
<p>一致性哈希的理解，和普通哈希有什么区别。</p>
]]></content>
      <categories>
        <category>TODO</category>
      </categories>
  </entry>
  <entry>
    <title>I/O模型</title>
    <url>/2021/12/13/TODO/IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="1-传统IO模型"><a href="#1-传统IO模型" class="headerlink" title="1. 传统IO模型"></a>1. 传统IO模型</h4><p>是阻塞式的，服务器监听客户端的请求</p>
<p>每来一个连接请求，服务器就创建一个线程去执行该请求</p>
<p>当请求数量较大时，需要创建非常多的线程，资源耗费大</p>
<p>而且它使用字节流的形式传输数据，效率不高</p>
<h4 id="2-NIO模型"><a href="#2-NIO模型" class="headerlink" title="2. NIO模型"></a>2. NIO模型</h4><p>又叫做非阻塞式IO，由<strong>信道、选择器、缓冲区</strong>构成</p>
<ul>
<li>Channel</li>
</ul>
<p>是传统 IO Stream 流的升级版，支持双向传输</p>
<ul>
<li>Selector</li>
</ul>
<p>从线程池中选择线程，来执行多个注册在它上的信道。</p>
<p>通过一定的选择机制，实现了IO多路复用</p>
<ul>
<li>Buffer</li>
</ul>
<p>缓冲可以看作一块内存区域，先写入，后读取</p>
<h4 id="3-NIO的优势"><a href="#3-NIO的优势" class="headerlink" title="3. NIO的优势"></a>3. NIO的优势</h4><ol>
<li>IO是面向流的，只能按字节读取数据，并且只能从一端读到另一端，不能前后移动流中的数据</li>
</ol>
<p>而NIO是面向缓冲区的，可以读取一块区域</p>
<ol start="2">
<li>IO是阻塞的，这意味着，当一个线程读取数据或写数据时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，在此期间该线程不能干其他任何事情。而NIO是非阻塞的，不需要一直等待操作完成才能干其他事情，而是在等待的过程中可以同时去做别的事情，所以能最大限度地使用服务器的资源。</li>
<li>NIO引入了IO多路复用器selector。selector是一个提供channel注册服务的线程，可以同时对接多个Channel，并在线程池中为channel适配、选择合适的线程来处理channel。由于NIO模型中线程数量大大降低，线程切换效率因此也大幅度提高。</li>
</ol>
]]></content>
      <categories>
        <category>todolist</category>
      </categories>
  </entry>
  <entry>
    <title>思考</title>
    <url>/2021/12/13/Test/%E9%A1%B9%E7%9B%AE%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="技术类"><a href="#技术类" class="headerlink" title="技术类"></a>技术类</h2><ul>
<li>用redis zset整个排行榜</li>
</ul>
<h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><ul>
<li>预防缓存击穿（大量无效的key），添加布隆过滤器</li>
<li>缓存持久化？</li>
</ul>
<h2 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h2><ul>
<li>社交关系中，让好友双方都能看到并修改的设置（或是其他模块）</li>
</ul>
<h2 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h2><ul>
<li><strong>游戏攻略类</strong><ul>
<li><strong>描述</strong>：提供图鉴查询、流程介绍等内容帮助玩家快速上手</li>
<li><strong>示例</strong>：剑盾图鉴<code>@微信小程序</code></li>
</ul>
</li>
<li><strong>一体化宠物服务平台</strong><ul>
<li><strong>描述</strong>：提供宠物分享、购买及宠物自身的各类服务，如清洗、保养、看病等。</li>
<li><strong>示例</strong>：宠物家、它嗅宠物<code>@应用宝</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Test</category>
      </categories>
  </entry>
  <entry>
    <title>markdown内嵌html</title>
    <url>/2021/12/13/Test/%E6%88%91%E6%9C%89%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E6%A2%A6/</url>
    <content><![CDATA[<blockquote title="结束啦" style="padding:12px;border-left-color:#98bf21;background-color:rgb(249, 248, 250);">
 <p style="font-weight: bold;">提示</p>
 <p>到这里，kafka安装及环境搭建就告一段落 </p>
</blockquote>




<table border="1"style={{margin:200}}>
    { {<tbody>
        <tr>
            <th colspan="2">我是占位符</th>
            <th colspan="2">我是占位符</th>
        </tr>
        <tr>
            <th rowspan="2">我是占位符</th>
        	<th>我是占位符</th>
            <th>我是占位符</th>
            <th>我是占位符</th>
        </tr>
        <tr>
            <th>我是占位符</th>
            <th>我是占位符</th>
            <th>我是占位符</th>
        </tr>
    </tbody>
</table>} } 



<p>发生了什么？</p>
]]></content>
      <categories>
        <category>Test</category>
      </categories>
  </entry>
  <entry>
    <title>PART1——数据系统的基石</title>
    <url>/2021/12/13/Reading/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="Part1：数据系统的基石"><a href="#Part1：数据系统的基石" class="headerlink" title="Part1：数据系统的基石"></a>Part1：数据系统的基石</h1><h2 id="一、可靠性、可扩展性、可维护性"><a href="#一、可靠性、可扩展性、可维护性" class="headerlink" title="一、可靠性、可扩展性、可维护性"></a>一、可靠性、可扩展性、可维护性</h2><p>对一个系统来说，有三个特性值得我们去关注。</p>
<ul>
<li><strong>可靠性</strong><ul>
<li>当遇到硬件故障、软件错误时，如何保证系统能够继续使用</li>
</ul>
</li>
<li><strong>可扩展性</strong><ul>
<li>怎样应对服务负载增加的情形</li>
</ul>
</li>
<li><strong>可维护性</strong><ul>
<li>在一个系统开发完毕之后，怎样让运维团队或工程师们轻松理解并维护系统</li>
</ul>
</li>
</ul>
<h2 id="二、数据模型与查询语言"><a href="#二、数据模型与查询语言" class="headerlink" title="二、数据模型与查询语言"></a>二、数据模型与查询语言</h2><p>数据组织的模型：关系模型与文档模型，它们的各自概念及特点</p>
<p>查询语言：命令式和语义化的查询语言</p>
<h2 id="三、存储与检索"><a href="#三、存储与检索" class="headerlink" title="三、存储与检索"></a>三、存储与检索</h2><h5 id="3-1抛出问题"><a href="#3-1抛出问题" class="headerlink" title="3.1抛出问题"></a>3.1抛出问题</h5><ol>
<li>数据存储的方式、结构有哪些？分别是为了处理怎样的场景？有哪些特点？</li>
</ol>
<h5 id="3-2文章阅读"><a href="#3-2文章阅读" class="headerlink" title="3.2文章阅读"></a>3.2文章阅读</h5><p><a href="https://blog.csdn.net/jinking01/article/details/105377370">最容易理解的LSM树–以示例讲解合并查找过程</a></p>
<p><a href="https://www.jianshu.com/p/f911cb9e42de">从B+树到LSM树，及LSM树在HBase中的应用</a></p>
<h5 id="3-3总结"><a href="#3-3总结" class="headerlink" title="3.3总结"></a>3.3总结</h5><p><strong>数据库按应用场景可以分为以下两类：</strong></p>
<p><strong>OLTP</strong>（在线事务处理）</p>
<ul>
<li><code>描述</code>：普通用户操作对数据库层带来的影响</li>
<li><code>特点</code>：并发量大，每次请求处理的数据不多</li>
<li><code>代表</code>：普通数据库</li>
</ul>
<p><strong>OLAP</strong>（在线分析处理）</p>
<ul>
<li><code>描述</code>：专业人员对海量数据进行分析，得到一定结果</li>
<li><code>特点</code>：并发量小，但是每次请求都涉及大规模的数据</li>
<li><code>代表</code>：数据仓库</li>
</ul>
<p><strong>从OLTP到OLAP的数据转化：</strong></p>
<ol>
<li>起初用户的各种行为会产生数据，记录在数据库中</li>
<li>随着业务的慢慢发展，我们想要通过多维度的数据来分析用户群体特征，如偏好、各类趋势等</li>
<li>因此需要用<code>数据仓库</code>来存储基于事实（或者说用户行为）的数据</li>
<li>过程：抽取<code>-&gt;</code>转换<code>-&gt;</code>加载</li>
</ol>
<p><strong>OLTP数据库的探讨：</strong></p>
<p><strong>主流学派</strong></p>
<ul>
<li>日志结构学派<ul>
<li><code>描述</code>：采用类似追加日志的方式，进行数据更新</li>
<li><code>特点</code>：写操作快，读操作慢</li>
<li><code>典型</code>：SSTable、LSM树</li>
</ul>
</li>
<li>就地更新学派<ul>
<li><code>描述</code>：采用页面覆盖的方式更新数据</li>
<li><code>特点</code>：读操作快，写操作慢</li>
<li><code>典型</code>：B/B+树</li>
</ul>
</li>
</ul>
<h2 id="四、编码与演化"><a href="#四、编码与演化" class="headerlink" title="四、编码与演化"></a>四、编码与演化</h2>]]></content>
      <categories>
        <category>数据密集型应用系统设计</category>
      </categories>
  </entry>
  <entry>
    <title>索引及优化</title>
    <url>/2021/12/13/MySQL/%E7%B4%A2%E5%BC%95%EF%BC%9A%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="一、索引数据结构类型"><a href="#一、索引数据结构类型" class="headerlink" title="一、索引数据结构类型"></a>一、索引数据结构类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>这是一类由<code>B-Tree</code>、<code>B+Tree</code>或<code>B*Tree</code>的数据结构来进行表数据存储的索引结构。</p>
<p>至于这三者的区别，因为与索引优化无关，就不再这里介绍。</p>
<p><strong>B+Tree结构</strong></p>
<p>每个节点都可以看作是逻辑页，中间节点存储了指向下层逻辑页的指针，然后叶子节点存储了指向其他叶子节点的指针。</p>
<p><strong>即中上部分是树，且最底层的叶子用双向链表相接</strong></p>
<p>一般来说，B-Tree作为索引，可以支持多种方式的查询（这里指能用到索引的查询方式）</p>
<ul>
<li>全值匹配<ul>
<li>查询条件和索引的所有列匹配</li>
<li>例如以姓名和年龄建了索引，那么执行<code>SELECT * FRPM user WHERE name = &quot;zhangsan&quot; AND age = 18</code>就用到了全值匹配</li>
</ul>
</li>
<li>最左前缀匹配<ul>
<li>用索引的第一列查询</li>
<li>例如只用<code>name</code>来查询，但是如果只用<code>age</code>查询，无法走索引查询，因为索引树在构建时，是先按name再按age的顺序来排的。</li>
</ul>
</li>
<li>范围匹配<ul>
<li>匹配索引第一列的某个范围</li>
</ul>
</li>
</ul>
<p><strong>使用B-Tree这类索引的限制</strong></p>
<p>最左前缀原则，查找时必须匹配索引的第一列才行，不能跳过。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引是通过计算索引列的值得到哈希码，然后去哈希表中拿到对应数据的地址，最后获取数据的。</p>
<p>例如<code>name</code>字段建立了哈希索引，那么在查询<code>name = &quot;zhangsan&quot;</code>时，会计算得到某个key，然后去哈希表中得到value。value表示的就是数据存放的地址。</p>
<p>因此它不支持范围查找、部分索引列查找、排序等等。</p>
<p>但是它也有优点，相对来说查询速度会更快。。</p>
<blockquote>
<p>这里提一句，InnoDB引擎实现了自适应哈希索引，即在B+Tree基础上，对于一些频繁使用的索引值，系统会对它们创建一个哈希索引。</p>
<p>只能说InnoDB牛批！</p>
</blockquote>
<h3 id="空间索引R-Tree"><a href="#空间索引R-Tree" class="headerlink" title="空间索引R-Tree"></a>空间索引R-Tree</h3><p>MyISAM支持空间索引，它不需要前缀匹配，因为它会从所有维度来索引数据？？？</p>
<p>但是MySQL的GIS支持不完善，不推荐使用…</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>这是一种特殊的索引，它查找的是文本中的关键词，而不是直接比较索引值。    </p>
<h2 id="二、索引优点"><a href="#二、索引优点" class="headerlink" title="二、索引优点"></a>二、索引优点</h2><ul>
<li>减少服务器需要扫描的数据量</li>
<li>避免排序和临时表</li>
<li>将随机IO变为顺序IO</li>
</ul>
<h2 id="三、索引优化"><a href="#三、索引优化" class="headerlink" title="三、索引优化"></a>三、索引优化</h2><h3 id="使用独立的列"><a href="#使用独立的列" class="headerlink" title="使用独立的列"></a>使用独立的列</h3><p>假如age建立了索引，那么查询时要使用<code>age = 18</code>而不是<code>age + 1 = 19</code>这种形式。</p>
<h3 id="模拟哈希索引"><a href="#模拟哈希索引" class="headerlink" title="模拟哈希索引"></a>模拟哈希索引</h3><p>假设表采用InnoDB引擎，如果查询条件包含url字符串，如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> url <span class="keyword">WHERE</span> url <span class="operator">=</span> &quot;www.baidu.com&quot;;</span><br></pre></td></tr></table></figure>

<p>对<code>url</code>字段直接建索引，会使得索引的体积非常大，因为url本身是有一定长度的。</p>
<p>这时我们可以采取伪哈希索引，即在表中新增一列<code>url_crc</code>，然后该列的值为对url字段进行哈希后的整型，对整型建索引和查找是比较高效的。</p>
<p>这里有个注意点，因为哈希值可能会发生冲突（即重复），所以查询时还是要带上原url，如下所示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> url <span class="keyword">WHERE</span> url <span class="operator">=</span> &quot;www.baidu.com&quot; <span class="keyword">AND</span> url_crc <span class="operator">=</span> CRC32(&quot;www.baidu.com&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>另一种解决查询条件的字符串过长的方法，是建立前缀索引</p>
<p>在前缀的长度和区分度上寻求一个平衡，使得既能提高查询效率，又不至于出现太多重复的索引值。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>如之前提过的<code>name</code>和<code>age</code>，两者查询是交集的话，就可以建立以name和age共同构建的联合索引，而不是两个单列索引。</p>
<p>如果两者查询是并集，如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;zhangsan&quot; <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p>这样可以建立两个单列索引，但是查询写法要改一下，用<code>union</code>使两个查询都能用到索引（虽然MySQL现在也会优化成联合的方式）</p>
<p><strong>正确做法</strong></p>
<ul>
<li>建两个单列索引</li>
<li>使用联合</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;zhangsan&quot;</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="operator">!=</span> &quot;zhangsan&quot; <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>这是由存储引擎实现的，这里讨论的是InnoDB。</p>
<p>聚簇索引就是在索引中把数据和索引值都放在一起，可以说，<strong>聚簇索引就是一张表</strong>，默认用主键来构建聚簇索引。</p>
<p>在InnoDB的实现中，B+Tree的叶子节点存放了索引列的值和其他列的值（即所有数据），中间节点只存放了索引列的值</p>
<p><strong>好处</strong></p>
<p>查询和非聚簇索引相比更快，因为可以直接拿到数据，不用再去其他地方读</p>
<p>聚簇索引中获取一个页中的相关数据会非常快，比如用户的所有邮箱数据都聚集在一个页中，那么可以快速获得</p>
<p><strong>坏处</strong></p>
<p>插入时：按照主键递增的顺序插入效率最高，如果主键不递增，那么插入到索引的中间位置，开销就会变大</p>
<p>更新时：在聚簇索引中，想要在修改索引列的值，代价会非常高</p>
<p><strong>二级索引</strong></p>
<p>主键构成的索引就是聚簇索引，那么其他列构成的索引就是二级索引了。</p>
<p>二级索引的叶子存储了对应记录的主键，思考一哈，为啥不存指向那行数据的指针呢？</p>
<blockquote>
<p>原因就是降低维护成本。如果二级索引的叶子节点存储数据的行指针，那么数据的位置发生变化（行移动或页分裂）时，就要增加二级索引的维护工作。</p>
</blockquote>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>查询时如果当前索引就包含了要查询的内容，不必再拿着主键去聚簇索引中查找，这种情况就被称为<code>覆盖索引</code></p>
<p>使用覆盖索引查询，就减少了回表的次数，提高查询效率</p>
<h3 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h3><p>两种方式可以得到有序的数据：排序和索引顺序扫描。</p>
<p><strong>索引顺序扫描</strong></p>
<p>在索引按顺序扫描时，如果每条记录都不能覆盖所需字段，它就得回表查询对应的数据行</p>
<p>这样产生的IO开销，会导致索引顺序扫描的速度比顺序全表扫描还来的慢。</p>
<h3 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h3><p><code>重复索引</code>是指索引列及其顺序都一致，这种重复情况应该避免。</p>
<p>而<code>索引冗余</code>是指，某个索引包含了原有的索引，是其超集。</p>
<p>例如现在已经建立<code>name</code>字段的索引，现在又新建了一个<code>name</code>和<code>age</code>字段的联合索引，这种情况就是冗余索引。</p>
<p><strong>那我们可不可以扩展原先的<code>name</code>索引呢，这样不就可以避免索引冗余了</strong></p>
<p>但是扩展<code>name</code>索引，给它加上age字段，会使原来的索引变大，从而影响其他使用原索引的查询速度</p>
<p>索引冗余有个致命的缺陷，就是索引越多，增删改的性能就会越低。所以要根据具体情况来决定是否冗余索引。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/MySQL/%E7%B4%A2%E5%BC%95%EF%BC%9A%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/MySQL/%E4%BA%8B%E5%8A%A1%EF%BC%9A%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-转账"><a href="#1-转账" class="headerlink" title="1.转账"></a>1.转账</h2><p><strong>场景：</strong>事务一般使用MVCC机制来避免并发执行时的数据问题。如果A读自己余额，为100；B向A转账100；A继续读余额，还是100。这样出现了钱少的问题，如何解决？</p>
<p><strong>思路：</strong>读写都加共享锁？</p>
<h2 id="2-幻读"><a href="#2-幻读" class="headerlink" title="2.幻读"></a>2.幻读</h2><h4 id="什么是幻读？"><a href="#什么是幻读？" class="headerlink" title="什么是幻读？"></a>什么是幻读？</h4><p>事务A读两次，在第二次读之前另一个事务插入数据并提交，导致A两次读的结果不一样。</p>
<h4 id="RR下的mvcc是否解决了幻读？"><a href="#RR下的mvcc是否解决了幻读？" class="headerlink" title="RR下的mvcc是否解决了幻读？"></a>RR下的mvcc是否解决了幻读？</h4><p>这个要看情况讨论。</p>
<ol>
<li>如果一个事务中全部都是快照读，那么幻读是不会产生的。<code>@快照读的实现保证了这一点</code></li>
<li>如果一个事务中全部使用当前读，那么也不会产生幻读。<code>@通过间隙锁解决</code></li>
<li>如果两者都用到，则有可能产生幻读。<code>@如示例</code></li>
</ol>
<p><strong>幻读示例</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">事务A 读id范围<span class="number">5</span><span class="operator">~</span><span class="number">10</span>的记录   ## 只有记录<span class="number">7</span></span><br><span class="line"></span><br><span class="line">事务B 修改id7为<span class="number">8</span> 提交</span><br><span class="line"></span><br><span class="line">事务A 修改id为<span class="number">8</span>的记录      ## 触发当前读</span><br><span class="line">事务A 读id范围<span class="number">5</span><span class="operator">~</span><span class="number">10</span>的记录   ## 多了一条记录<span class="number">8</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>事务详解</title>
    <url>/2021/12/13/MySQL/%E4%BA%8B%E5%8A%A1%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、什么是事务"><a href="#一、什么是事务" class="headerlink" title="一、什么是事务"></a>一、什么是事务</h1><h3 id="事务定义如下："><a href="#事务定义如下：" class="headerlink" title="事务定义如下："></a>事务定义如下：</h3><blockquote>
<p>访问并可能更新数据库中各项数据的一个<strong>程序执行单元</strong></p>
</blockquote>
<h3 id="事务特性："><a href="#事务特性：" class="headerlink" title="事务特性："></a>事务特性：</h3><table>
<thead>
<tr>
<th>特性（ACID）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>原子性</td>
<td>事务内的操作要么全部完成，要么全部失败回滚</td>
</tr>
<tr>
<td>一致性</td>
<td>依赖于开发者，来保证数据库在一个事务执行前后都处于正确状态</td>
</tr>
<tr>
<td>隔离性</td>
<td>并发事务之间相互隔离，察觉不到有其他事务在执行</td>
</tr>
<tr>
<td>持久性</td>
<td>事务一旦被提交，对数据的改变就是永久性的，即使故障也不会丢失改变的提交。</td>
</tr>
</tbody></table>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table>
<thead>
<tr>
<th align="center">级别\问题（是否存在）</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是（MVCC时无）</td>
</tr>
<tr>
<td align="center">串行化</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<h1 id="二、事务实现"><a href="#二、事务实现" class="headerlink" title="二、事务实现"></a>二、事务实现</h1><p>上面介绍的四个特性中，隔离性由锁和MVCC来实现；此外，原子性、一致性和持久性通过数据库的<code>redo log</code>和<code>undo log</code>来完成。</p>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p><code>redo log</code>是一种<code>物理格式</code>日志，记录了对页的修改；它实现了事务的持久性，由两部分组成：</p>
<ul>
<li>内存中的<code>重做日志缓冲</code>(redo log buffer)</li>
<li>操作系统缓存中的<code>重做日志文件</code>(redo log file)</li>
</ul>
<p><strong>注意，这里为什么是在操作系统中呢？因为打开日志文件时没有使用<code>O_DIRECT</code>标志位，所以不能绕过操作系统直接添加到磁盘中。</strong></p>
<p>所以从内存中更新数据到磁盘，经历了以下过程：</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210502235152.png" alt="img"></p>
<p>可以看到，从操作系统缓冲写入到磁盘，需要进行<code>fsync()</code>操作；多久执行一次该操作，可以通过参数<code>innodb_flush_log_at_trx_commit</code>来决定。该参数有三个取值，分别是0，1，2。</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">表示主线程每隔一秒执行一次<strong>fsync()</strong></td>
<td align="center">数据库或计算机宕机时，都会丢失一部分数据</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">表示事务每提交一次，就执行一次<strong>fsync()</strong></td>
<td align="center">并发场景下性能较差</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">表示事务提交时，把<strong>重做日志缓冲</strong>写入到<strong>重做日志文件</strong>中</td>
<td align="center">数据库宕机不会影响，因为日志已经在操作系统缓冲区了；系统宕机时，会丢失一部分数据</td>
</tr>
</tbody></table>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>undo log</code>记录的是逻辑操作，具体地说，应该是事务中每步操作的<code>逆向操作</code></p>
<p>例如，事务中执行了一条插入语句，那么<code>undo log</code>就会记录一次删除。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>回滚</p>
<p>在事务失败时，可以根据它回滚到事务开始前的状态。</p>
</li>
<li><p>多版本控制</p>
<p>在MVCC中，如果数据被其它事务占用，就可以根据<code>undo log</code>来获取之前版本的数据，避免阻塞地获取锁。</p>
</li>
</ul>
<h3 id="3种操作的undo-log"><a href="#3种操作的undo-log" class="headerlink" title="3种操作的undo log"></a>3种操作的undo log</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>因为事务隔离性的要求，插入数据只对当前事务可见，其他事务不应该发现。</p>
<p>所以它产生的undo log可以在事务提交后直接删除</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>先执行逻辑删除，把标志位设置成删除，然后等待purge线程进行物理删除</p>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>这里分两类讨论</p>
<ul>
<li><p>不更新主键</p>
<p>直接更新即可，并生成undo log</p>
</li>
<li><p>更新主键</p>
<p>先标记删除原有主键的记录，再执行插入。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>事务并发解决方案</title>
    <url>/2021/12/13/MySQL/%E4%BA%8B%E5%8A%A1%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><p>关于事务的介绍，请看另一篇博客。</p>
<p><strong>解决并发事务访问，主要有两种方式：</strong></p>
<ul>
<li><strong>LBCC</strong>（Lock Based Concurrent Control）</li>
</ul>
<ul>
<li><strong>MVCC</strong>（Multi-Version Concurrent Control）</li>
</ul>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul>
<li>脏读，读到其他事务修改后未提交的数据</li>
<li>不可重复读，多次读数据，得到的不一致</li>
<li>幻读，多次读的结果不同（多了数据或少了数据）</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table>
<thead>
<tr>
<th align="center">级别\问题（是否存在）</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是（MVCC时有）</td>
</tr>
<tr>
<td align="center">串行化</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<h1 id="二、LBCC"><a href="#二、LBCC" class="headerlink" title="二、LBCC"></a>二、LBCC</h1><h2 id="2-1锁的类型"><a href="#2-1锁的类型" class="headerlink" title="2.1锁的类型"></a>2.1锁的类型</h2><p>官网链接：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">MySQL :: MySQL 8.0 Reference Manual :: 15.7.1 InnoDB Locking</a></p>
<p>查阅MySQL官网，得知InnoDB存储引擎提到了以下几种锁方案</p>
<ol>
<li><p>共享锁与排他锁 （行级别）</p>
</li>
<li><p>意向锁 （表级别）</p>
</li>
<li><p>记录锁</p>
</li>
<li><p>间隙锁</p>
</li>
<li><p>Next-Key 锁</p>
</li>
</ol>
<p>还有另外三种不做详细介绍，就简单说明一下概念</p>
<ol>
<li>插入意向锁</li>
<li>自增锁</li>
<li>预测锁</li>
</ol>
<p>下面我们将依次介绍上述5种锁的概念</p>
<h2 id="2-2共享锁与排他锁"><a href="#2-2共享锁与排他锁" class="headerlink" title="2.2共享锁与排他锁"></a>2.2共享锁与排他锁</h2><p>共享锁和排他锁是InnoDB实现的行级别的锁。</p>
<p><code>共享锁</code>又叫读锁，用来读取数据。多个共享锁可以同时存在。</p>
<p><code>排他锁</code>又叫写锁，用来更新或删除数据（插入呢？），不能与其他锁并存</p>
<p>举个简单的例子</p>
<p>如果事务<code>T1</code>在读表中的记录<code>r</code>，那它就对记录<code>r</code>加了读锁</p>
<p>这时候事务<code>T2</code>想要对记录<code>r</code>进行一些操作</p>
<ul>
<li>如果是读操作，<code>T2</code>可以直接对记录<code>r</code>加读锁</li>
<li>如果是写操作，<code>T2</code>必须等待<code>T1</code>释放锁之后，才能对记录<code>r</code>加写锁</li>
</ul>
<h2 id="2-3意向锁"><a href="#2-3意向锁" class="headerlink" title="2.3意向锁"></a>2.3意向锁</h2><h3 id="2-3-1为什么要有意向锁呢？"><a href="#2-3-1为什么要有意向锁呢？" class="headerlink" title="2.3.1为什么要有意向锁呢？"></a>2.3.1为什么要有意向锁呢？</h3><p>针对一个场景：</p>
<p>如果要对一张表加<strong>表锁</strong>，就要先确保表中的<strong>任意一行数据</strong>都没有<strong>被锁定</strong></p>
<p>那么就需要进行全表扫描来判断，效率十分低下</p>
<p><strong>而上述问题的本质，就是锁过于单一，只有读锁、写锁这些行级别锁的话，粒度较少，不具备灵活性。</strong></p>
<p>所以提出了意向锁的思想 。</p>
<h3 id="2-3-2意向锁"><a href="#2-3-2意向锁" class="headerlink" title="2.3.2意向锁"></a>2.3.2意向锁</h3><blockquote>
<p>意向读锁：表明一个事务<strong>想要</strong>对某行数据设置读锁。</p>
<p>意向写锁：表明一个事务<strong>想要</strong>对某行数据设置写锁。</p>
</blockquote>
<p>光说这个概念可能不太好理解，我们结合官网上的描述，来分析下它的主要目的、协议吧。</p>
<h3 id="2-3-3官方解释"><a href="#2-3-3官方解释" class="headerlink" title="2.3.3官方解释"></a>2.3.3官方解释</h3><p><strong>关于意向锁的解释</strong></p>
<blockquote>
<p><code>InnoDB</code> supports <em>multiple granularity locking</em> which permits coexistence of row locks and table locks.</p>
<p><code>InnoDB</code>支持多粒度的锁来保证行锁和表锁的共存。</p>
<p>Intention locks are <code>table-level</code> locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table. </p>
<p>意向锁是表级别的锁，它代表一个事务之后想要获取的是什么类型（读锁或写锁）的锁。</p>
<p>PS：实现了多粒度的锁。</p>
</blockquote>
<p><strong>意向锁的主要目的</strong></p>
<blockquote>
<p>Intention locks do not block anything except full table requests (for example, <code>LOCK TABLES ... WRITE</code>). The main purpose of intention locks is to show that someone is locking a row, or going to lock a row in the table.</p>
<p>意向锁不会阻塞除<code>全表扫描</code>外的任何请求，它的主要目的就是表明其他事务正在锁，或者说将要锁某些记录。</p>
<p>PS：结合上面的例子，有了意向锁之后，就不用靠全表扫描来判断当前事务是否可以加表锁</p>
</blockquote>
<p><strong>意向锁的协议</strong></p>
<blockquote>
<p>Before a transaction can acquire a shared lock on a row in a table, it must first acquire an <code>IS</code> lock or stronger on the table.</p>
<p>一个事务获取某行的读锁之前，必须先获取表的意向读锁。</p>
<p>Before a transaction can acquire an exclusive lock on a row in a table, it must first acquire an <code>IX</code> lock on the table.</p>
<p>一个事务获取某行的写锁之前，必须先获取表的意向写锁。</p>
</blockquote>
<h3 id="2-3-4锁的具体使用"><a href="#2-3-4锁的具体使用" class="headerlink" title="2.3.4锁的具体使用"></a>2.3.4锁的具体使用</h3><p>首先，我们要了解意向锁和读写锁的共存关系（是否兼容）</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">IS</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">X</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>IS</strong></td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><strong>IX</strong></td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><strong>S</strong></td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><strong>X</strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p><strong>分析：</strong></p>
<p>意向锁之间：仅仅代表一个加锁的意向，所以意向锁之间不冲突</p>
<p>读写锁之间：读锁与读锁不冲突，写锁与其他锁（这里只讨论读写锁）都冲突</p>
<p>混合：要注意有读锁的情况下，意向写锁会冲突，即不能有写的念头。</p>
<p><strong>用法：</strong></p>
<p>从官网摘录一段select的语句结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	...</span><br><span class="line">	[FOR &#123;UPDATE | SHARE&#125;</span><br><span class="line">        [<span class="keyword">OF</span> tbl_name [, tbl_name] ...]</span><br><span class="line">        [NOWAIT <span class="operator">|</span> <span class="keyword">SKIP</span> LOCKED]</span><br><span class="line">      <span class="operator">|</span> LOCK <span class="keyword">IN</span> SHARE MODE]</span><br></pre></td></tr></table></figure>

<p><strong>使用意向读锁：</strong></p>
<p><code>select ... for share</code>或<code>select ... lock in share mode</code></p>
<p>两种方式来获取IS锁和对应记录的S锁，基本上是等价的</p>
<p>区别的话</p>
<ol>
<li><p>看上面select语句的格式，可以发现<code>for share</code>可以添加一些参数，参数在后面介绍</p>
</li>
<li><p><code>lock in share mode</code>提供向后兼容性。</p>
</li>
</ol>
<p><strong>使用意向写锁：</strong></p>
<p><code>select ... for update</code>语句会先尝试获取IX锁，然后再获取目标记录的写锁</p>
<p>如果获取不到，则会阻塞等待。（如果超时了就报错）</p>
<p><strong>参数说明：</strong></p>
<ul>
<li>nowait：不等待锁释放，立刻执行，获取不到锁就报错</li>
<li>skip locked：也是立刻执行，但忽略那些被加锁的数据，只操作不加锁的数据。</li>
</ul>
<p>这两个参数在基于语句复制的情况下，是不安全的（官网上提到，但我不懂…猜测一下，可能是在有主从数据库的时候，会不安全吧）</p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html">如果想看更详细的，请转至官网处</a></p>
<hr>
<p>下面开始是一些具体锁的介绍，先贴一张图大致表示一下</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210502173400.png" alt="lock_concret"></p>
<h2 id="2-4记录锁（锁定记录）"><a href="#2-4记录锁（锁定记录）" class="headerlink" title="2.4记录锁（锁定记录）"></a>2.4记录锁（锁定记录）</h2><p>在进行等值查询时，锁住<strong>匹配</strong>到的记录。确切地说，应该是锁住记录的主键（或隐式主键）</p>
<p>例如<code>select * from table1 where id = 4 for update</code>就是锁住了<code>id = 4</code>的记录</p>
<h2 id="2-5间隙锁（锁定范围）"><a href="#2-5间隙锁（锁定范围）" class="headerlink" title="2.5间隙锁（锁定范围）"></a>2.5间隙锁（锁定范围）</h2><p>在查询时，锁定<strong>区间范围</strong></p>
<p>①<code>select * from table1 where id = 6 for update</code></p>
<p>②<code>select * from table1 where id &gt; 20 for update</code></p>
<p>假设表的记录为<strong>1，4，7，10</strong></p>
<p>那么语句①锁住区间（4，7）；语句②锁住区间（10，+∞）</p>
<p><strong>间隙锁之间并不冲突</strong></p>
<h2 id="2-6临界锁（锁定范围，左开右闭）"><a href="#2-6临界锁（锁定范围，左开右闭）" class="headerlink" title="2.6临界锁（锁定范围，左开右闭）"></a>2.6临界锁（锁定范围，左开右闭）</h2><p>条件：进行范围查询时，包含<strong>区间</strong>和<strong>具体记录</strong></p>
<p><code>select * from table where id &gt; 5 and id &lt; 9 for update</code></p>
<p>那么锁定的范围为(4，7] 和 (7，10]，即(4，10]</p>
<p>我们可以发现，<strong>临界锁 = 间隙锁 + 记录锁</strong></p>
<p><em><strong>而间隙锁锁住区间，不让其他事务进行插入，目的就在于避免幻读问题的出现</strong></em></p>
<hr>
<p>讲完这些锁之后，我们谈谈在<strong>不同隔离级别</strong>下<strong>锁</strong>的<strong>实现</strong>：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">机制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RU</td>
<td align="center">不加锁</td>
</tr>
<tr>
<td align="center">Serializable</td>
<td align="center">所有select语句隐式地转化成共享锁，会与update、delete互斥</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">普通select语句</th>
<th align="center">加锁的select和更新语句</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RC</td>
<td align="center">MVCC</td>
<td align="center">记录锁</td>
</tr>
<tr>
<td align="center">RR</td>
<td align="center">MVCC</td>
<td align="center">记录锁、间隙锁、临界锁</td>
</tr>
</tbody></table>
<blockquote>
<p>①普通查询时，为什么RR可以解决不可重复读，而RC不可以</p>
<p>两者都采用MVCC，而因为RR的快照读readview使用的是同一个（第一次读时生成），而RC是每次查询生成一次新的readview</p>
</blockquote>
<h2 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h2><p>加锁最小单位：临界锁</p>
<p>临界锁的变化：</p>
<ul>
<li><p>未命中时变为间隙锁</p>
</li>
<li><p>命中时</p>
<ul>
<li>如果是<strong>单列唯一索引</strong>，则降级为行锁</li>
<li>如果是<strong>非唯一的索引或多列索引</strong>，则锁住左右两个区间及命中的索引值</li>
</ul>
</li>
</ul>
<h1 id="三、MVCC"><a href="#三、MVCC" class="headerlink" title="三、MVCC"></a>三、MVCC</h1><h2 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h2><p>用于实现数据库的并发访问的一种方法，全称为多版本并发控制。</p>
<h2 id="3-2前置概念"><a href="#3-2前置概念" class="headerlink" title="3.2前置概念"></a>3.2前置概念</h2><p>在学习MVCC前，需要先知道两个概念</p>
<p><strong>当前读</strong></p>
<ul>
<li>数据：读取的是数据的最新版本。</li>
<li>特点：读取时还要加锁，保证其他并发事务不能修改当前记录</li>
<li>示例：共享锁、排他锁</li>
</ul>
<p><strong>快照读</strong></p>
<ul>
<li>数据：读取的是数据库某一时刻的快照的数据。</li>
<li>特点：不加锁的、非阻塞的读；读到的数据不一定是最新数据，可能是历史版本。</li>
<li>示例：MVCC普通读</li>
</ul>
<h2 id="3-3思想"><a href="#3-3思想" class="headerlink" title="3.3思想"></a>3.3思想</h2><blockquote>
<p> 维持一个数据的多个版本，使得读写操作没有冲突</p>
</blockquote>
<h2 id="3-4实现"><a href="#3-4实现" class="headerlink" title="3.4实现"></a>3.4实现</h2><p>隐式字段 + undo回滚日志 + 快照</p>
<p><strong>隐式字段</strong></p>
<blockquote>
<p>每行记录除了有用户定义的字段外，还有隐式字段，如行创建id、行删除id、回滚指针、自增ID</p>
</blockquote>
<ul>
<li><p>行创建id：指插入或修改本条记录的事务id</p>
</li>
<li><p>行删除id：指删除本条记录的事务id</p>
</li>
<li><p>回滚指针：指向回滚日志中的关于<strong>这条记录</strong>的<strong>上一个版本</strong></p>
</li>
</ul>
<ul>
<li>自增ID：当表没有设定主键且不存在非空唯一的字段时，会采用自增ID来作为主键，构建主键索引</li>
</ul>
<p><strong>undo回滚日志</strong></p>
<p>记录每次修改的操作，可从前往后遍历来进行数据回滚</p>
<p>在进行<strong>修改（更新、插入、删除）</strong>操作时，mysql会生成一条日志（主键+当前事务id+回滚指针，指向前一条记录）</p>
<p>删除只是把标志位改为true，即逻辑删除</p>
<p><strong>ReadView</strong></p>
<blockquote>
<p>ReadView是事务进行快照读时产生的读视图，记录并维护了系统中当前较为活跃的事务id</p>
</blockquote>
<h2 id="3-5例子"><a href="#3-5例子" class="headerlink" title="3.5例子"></a>3.5例子</h2><p>在某次事务查询时，得到readview 为 <strong>[100,200,300]</strong></p>
<p> 可以看出活跃事务中最小id为100，最大id为300</p>
<p>从回滚日志中依次向后遍历，假设每次遍历到的事务id为x</p>
<p>则有以下三种情况：</p>
<ol>
<li><p>x &lt; 100 表示此事务已提交，数据可见</p>
</li>
<li><p>x &gt; 300 表示此事务是在生成readview之后开启的事务，数据不可见</p>
</li>
<li><p>在100和300中间，此时就要查看x是否在活跃事务id中，如果是，则它仍未提交，数据不可见。</p>
</li>
</ol>
<h2 id="3-6RR和RC隔离级别下"><a href="#3-6RR和RC隔离级别下" class="headerlink" title="3.6RR和RC隔离级别下"></a>3.6RR和RC隔离级别下</h2><p>针对同一个事务来说，</p>
<ul>
<li><p>读已提交：每次查询都会生成新的read-view</p>
</li>
<li><p>可重复读：只用第一次查询时生成的read-view（解决了不可重复读）</p>
</li>
</ul>
<h1 id="四、补充问题"><a href="#四、补充问题" class="headerlink" title="四、补充问题"></a>四、补充问题</h1><h2 id="4-1死锁"><a href="#4-1死锁" class="headerlink" title="4.1死锁"></a>4.1死锁</h2><p><strong>定义</strong></p>
<p>这里的死锁可以理解成两个及以上的事务在共同竞争锁资源，而产生的等待现象。</p>
<p><strong>解决方案一</strong></p>
<p>设置一个超时等待时间，超时后对某个事务进行回滚，然后其他事务就可以执行下去</p>
<p>但是光靠超时来解决的话，可能会有大量事务要进行回滚，会非常耗时</p>
<p><strong>解决方案二</strong></p>
<p>等待图，这可以算是一种死锁检测算法。</p>
<p>画出各个事务之间的依赖关系，如果形成环路，说明存在死锁。</p>
<h2 id="4-2锁升级"><a href="#4-2锁升级" class="headerlink" title="4.2锁升级"></a>4.2锁升级</h2><p><del>知识盲区…</del></p>
<p>InnoDB存储引擎并不存在锁升级的情况，因为它并不是根据每个记录来产生行锁的。</p>
<p>它是根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/MySQL/MySQL%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p><strong>查看MySQL版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; select version();</span><br><span class="line"># 输出示例</span><br><span class="line">+-----------+</span><br><span class="line">| version() |</span><br><span class="line">+-----------+</span><br><span class="line">| 8.0.25    |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>

<p><strong>修改表的结构</strong></p>
<p>使用<code>ALTER TABLE</code>命令来操作表结构。</p>
<p>例如，为<code>user</code>表添加一个<code>deleted</code>字段，默认值为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; alter table user add deleted int default 0;</span><br></pre></td></tr></table></figure>

<p>例如，为<code>user</code>表删除一个字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; alter table user drop deleted;</span><br></pre></td></tr></table></figure>



<h2 id="分析命令"><a href="#分析命令" class="headerlink" title="分析命令"></a>分析命令</h2><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>使用explain + 查询语句来查看该语句执行的一些信息，如是否走索引，过滤的数据量等等。</p>
<p><strong>使用示例</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> salaries <span class="keyword">where</span> emp_no <span class="keyword">between</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">50000</span>;</span><br></pre></td></tr></table></figure>

<p><strong>输出内容分析</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">+<span class="params">----</span>+<span class="params">-------------</span>+<span class="params">----------</span>+<span class="params">------------</span>+<span class="params">------</span>+<span class="params">---------------</span>+<span class="params">------</span>+<span class="params">---------</span>+<span class="params">------</span>+<span class="params">---------</span>+<span class="params">----------</span>+<span class="params">-------------</span>+</span><br><span class="line">| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |</span><br><span class="line">+<span class="params">----</span>+<span class="params">-------------</span>+<span class="params">----------</span>+<span class="params">------------</span>+<span class="params">------</span>+<span class="params">---------------</span>+<span class="params">------</span>+<span class="params">---------</span>+<span class="params">------</span>+<span class="params">---------</span>+<span class="params">----------</span>+<span class="params">-------------</span>+</span><br><span class="line">|  1 | SIMPLE      | salaries | NULL       | ALL  | emp           | NULL | NULL    | NULL | 2837430 |    28.06 | Using where |</span><br><span class="line">+<span class="params">----</span>+<span class="params">-------------</span>+<span class="params">----------</span>+<span class="params">------------</span>+<span class="params">------</span>+<span class="params">---------------</span>+<span class="params">------</span>+<span class="params">---------</span>+<span class="params">------</span>+<span class="params">---------</span>+<span class="params">----------</span>+<span class="params">-------------</span>+</span><br></pre></td></tr></table></figure>

<p>主要关注的有type、key和extra。</p>
<p>type</p>
<table>
<thead>
<tr>
<th align="center">type取值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">system</td>
<td align="center">表只有一行数据，一般是指系统表</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">使用索引时只查到一条数据</td>
</tr>
<tr>
<td align="center">eq_ref</td>
<td align="center">连接时子查询用到唯一索引，数据只有一条</td>
</tr>
<tr>
<td align="center">ref</td>
<td align="center">待定</td>
</tr>
<tr>
<td align="center">range</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">index</td>
<td align="center">看extra有无using，如果无</td>
</tr>
<tr>
<td align="center">all</td>
<td align="center">全表扫描，该优化了</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/MySQL/MySQL%EF%BC%9A%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Linux下安装MySQL8"><a href="#Linux下安装MySQL8" class="headerlink" title="Linux下安装MySQL8"></a>Linux下安装MySQL8</h1><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://zhuanlan.zhihu.com/p/372582996">Linux怎样使用yum安装mysql - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/367327903">Linux （centos8）安装 MySQL 8 数据库（图文详细教程） - 知乎 (zhihu.com)</a></p>
<p><a href="https://blog.csdn.net/lei95/article/details/104736176">MYSQL8.0修改密码后依然无法登陆_lei95的博客-CSDN博客</a></p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p><strong>1.配置安装源</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rpm -Uvh https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></table></figure>

<p><strong>2.安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum --enablerepo=mysql80-community install mysql-community-server</span><br></pre></td></tr></table></figure>

<p><strong>3.启动mysql</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>

<p><strong>4.查看服务状态</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status  mysqld</span><br></pre></td></tr></table></figure>

<p><strong>5.查看临时密码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;A temporary password&quot;</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure>

<p><strong>6.登陆并修改密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 回车后，按提示输入临时密码登陆</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"># 修改密码</span><br><span class="line">UPDATE user SET authentication_string&#x3D;&#39;xxxxxx&#39; WHERE user&#x3D;&#39;root&#39;;</span><br><span class="line"># ALTER USER &#39;root&#39;@&#39;localhost&#39; identified by &#39;vF#bO94433&#39;;</span><br><span class="line"></span><br><span class="line"># 刷新权限表</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"># 退出(\q)之后，把my.cnf文件改回来,</span><br></pre></td></tr></table></figure>

<p><strong>7.重启服务，再次尝试登陆</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<p><strong>这里我遇到一个坑，修改密码后，之后登陆一直报密码错误（哪怕输了正确的密码）</strong></p>
<p><strong>解决方案</strong></p>
<ol>
<li><p>设置免密登陆</p>
<p><code>vi /etc/my.cnf</code>进入配置文件</p>
<p>在末尾添加<code>skip-grant-tables</code></p>
</li>
<li><p>重启mysqld服务</p>
</li>
<li><p>修改密码为空，方便下次直接回车登陆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入mysql数据库</span><br><span class="line">USE mysql;                          </span><br><span class="line"></span><br><span class="line"># 查看root用户的密码,会发现密码没有加密,是明文</span><br><span class="line">SELECT host, user, authentication_string, plugin FROM mysql.user;</span><br><span class="line"></span><br><span class="line"># 修改密码为空</span><br><span class="line">UPDATE user SET authentication_string&#x3D;&#39;&#39; WHERE user&#x3D;&#39;root&#39;;</span><br><span class="line"></span><br><span class="line"># 再次查看</span><br><span class="line">SELECT host, user, authentication_string, plugin FROM mysql.user;</span><br></pre></td></tr></table></figure></li>
<li><p>重启mysqld服务</p>
</li>
<li><p>登陆，密码不用输，直接回车</p>
<p><code>mysql -u root -q</code></p>
</li>
<li><p>修改密码并查看</p>
<p>如果发现密码加密了，表示修改成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; identified by &#39;vF#bO94433&#39;;</span><br><span class="line"></span><br><span class="line">SELECT host, user, authentication_string, plugin FROM mysql.user;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>对外配置</strong></p>
<p><strong>1.开启防火墙</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure>

<p><strong>2.查看防火墙状态</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>

<p><strong>3.开放3306端口</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=3306/tcp</span><br></pre></td></tr></table></figure>

<p><strong>4.刷新</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p><strong>数据库内部配置</strong></p>
<p>修改<code>my.cnf</code>文件，对默认字符集等进行配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># added config</span></span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server = utf8mb4_general_ci</span><br></pre></td></tr></table></figure>



<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><h3 id="创建用户并授权"><a href="#创建用户并授权" class="headerlink" title="创建用户并授权"></a>创建用户并授权</h3><p>创建远程连接的用户，用户名：<code>root</code>，密码：<code>vF#bO94433</code>，访问权限：所有（%）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &#39;root&#39;@&#39;%&#39; identified by &#39;vF#bO94433&#39;;</span><br></pre></td></tr></table></figure>

<p>授权所有数据库的所有权限（*.*）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>

<p>刷新权限表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>查看用户权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show grants for &#39;root&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h3><p>创建所需数据库<code>db_social</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE &#96;db_social&#96;;</span><br></pre></td></tr></table></figure>

<p>如果执行命令的时候提示警告，就查看警告信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW WARNINGS;</span><br></pre></td></tr></table></figure>

<p>选择数据库，创建表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE db_social;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;t_social_report&#96; (</span><br><span class="line">	&#96;report_id&#96; INT UNSIGNED,</span><br><span class="line">    &#96;content_id&#96; VARCHAR(255),</span><br><span class="line">    &#96;user_id&#96; INT UNSIGNED,</span><br><span class="line">    &#96;report_type&#96; INT UNSIGNED,</span><br><span class="line">    &#96;report_content_type&#96; INT UNSIGNED,</span><br><span class="line">    &#96;report_audit_status&#96; INT UNSIGNED,</span><br><span class="line">    &#96;report_audit_result&#96; INT UNSIGNED,</span><br><span class="line">    &#96;created_time&#96; TIMESTAMP,</span><br><span class="line">    &#96;updated_time&#96; TIMESTAMP,</span><br><span class="line">    PRIMARY KEY (&#96;report_id&#96;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/MySQL/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h4 id="一、索引的类别"><a href="#一、索引的类别" class="headerlink" title="一、索引的类别"></a>一、索引的类别</h4><ol>
<li><strong>主键索引</strong>（非空、唯一）</li>
</ol>
<p>设定为主键后，自动建的索引</p>
<blockquote>
<p><strong>PRIMARY KEY</strong>（id）</p>
</blockquote>
<ol start="2">
<li><strong>单列索引</strong>（可空，不唯一）</li>
</ol>
<blockquote>
<p><strong>CREATE</strong> <strong>INDEX</strong> name <strong>ON</strong> table(customer_name)</p>
</blockquote>
<ol start="3">
<li><strong>唯一索引</strong>（可空）</li>
</ol>
<blockquote>
<p><strong>CREATE</strong> <strong>UNIQUE INDEX</strong> name <strong>ON</strong> table(customer_name)</p>
</blockquote>
<ol start="4">
<li><strong>联合索引</strong></li>
</ol>
<p>多个单列索引的开销要大于复合索引，所以数据量大时，用复合索引更好。</p>
<h4 id="二、最左前缀，最右前缀，为什么要最左前缀"><a href="#二、最左前缀，最右前缀，为什么要最左前缀" class="headerlink" title="二、最左前缀，最右前缀，为什么要最左前缀"></a>二、最左前缀，最右前缀，为什么要最左前缀</h4><p>最左前缀匹配一般是针对联合索引来说的</p>
<p>例如联合索引（a，b，c），sql语句的条件要是a、ab、abc、ac时，才会触发索引。</p>
<p>索引在构建时，就是按照从左到右递增的顺序来的，如果查找时不按这个顺序，就只能全表扫描了。</p>
<h4 id="三、mysql隔离级别，默认隔离级别，底层实现（MVCC-next-key锁）"><a href="#三、mysql隔离级别，默认隔离级别，底层实现（MVCC-next-key锁）" class="headerlink" title="三、mysql隔离级别，默认隔离级别，底层实现（MVCC+next-key锁）"></a>三、mysql隔离级别，默认隔离级别，底层实现（MVCC+next-key锁）</h4><p>首先，弄清楚几个<strong>概念</strong>（事务并发情况下）</p>
<ol>
<li><strong>脏读</strong></li>
</ol>
<blockquote>
<p>读到了<strong>其他事务</strong>未提交的数据</p>
<p>未提交意味着数据可能会变化，不代表最终存储的数据</p>
</blockquote>
<ol start="2">
<li><strong>可重复读</strong></li>
</ol>
<blockquote>
<p>在一个事务中，两次任意时刻读的数据是一致的</p>
</blockquote>
<ol start="3">
<li><strong>不可重复读</strong></li>
</ol>
<blockquote>
<p>和可重复读相反，一次事务内，两次读到的数据不一致</p>
</blockquote>
<ol start="4">
<li><strong>幻读（注意）</strong></li>
</ol>
<blockquote>
<p>和不可重复读类似，但是针对插入数据来说的</p>
<p>即前后两次查询间隔中，其他事务插入了一条符合条件的数据，导致前后查询不一致</p>
<p><strong>因为插入数据是对表来说的，所以行锁不能避免幻读，表锁才行</strong></p>
</blockquote>
<p>接下来介绍四种事务隔离级别：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">描述</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交 RU</td>
<td align="center">可以读到其他事务未提交的数据</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">读已提交（不可重复读）RC</td>
<td align="center">只能读到已经提交的数据</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">可重复读 RR</td>
<td align="center">在当前事务持续时，禁止其他事务对此字段的更新</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">串行化</td>
<td align="center">最<strong>严格</strong>，要求所有事务串行执行</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<h4 id="四、innodb和myisam特点和区别"><a href="#四、innodb和myisam特点和区别" class="headerlink" title="四、innodb和myisam特点和区别"></a>四、innodb和myisam特点和区别</h4><table>
<thead>
<tr>
<th>区别\引擎</th>
<th>Innodb</th>
<th>myisam</th>
</tr>
</thead>
<tbody><tr>
<td>事务</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>数据和索引</td>
<td>在一起，聚簇</td>
<td>分离的，B+树叶子存储数据地址</td>
</tr>
<tr>
<td>支持锁</td>
<td>支持行锁和表锁</td>
<td>只支持表锁</td>
</tr>
</tbody></table>
<h4 id="五、行锁和表锁"><a href="#五、行锁和表锁" class="headerlink" title="五、行锁和表锁"></a>五、行锁和表锁</h4><p>行锁：锁一行或多行记录，行锁是基于索引加载的，加在索引匹配到的行上。</p>
<p>表锁 ：锁定整张表，属于全表扫描时做的。</p>
<p><strong>对比：</strong></p>
<p>行锁并发性能高，冲突率低，但会发生死锁</p>
<p>表锁性能低，冲突率高，锁定的范围大</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>笔记1</title>
    <url>/2021/12/13/MySQL/mysql%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h4><ul>
<li><strong>定义</strong></li>
</ul>
<blockquote>
<p>是帮助MYSQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong></p>
</blockquote>
<ul>
<li><strong>那么该采用什么样的数据结构呢？</strong></li>
</ul>
<p>二叉树、红黑树（二叉平衡树）都是不错的</p>
<p>但数据量过大时，树高度会很大，查找数据时会经过多个节点</p>
<p>B+树（多叉平衡树）的话，有多个叉，因此可以有效的减小高度，所以采用<strong>B+树</strong>的结构来构建索引较合适。</p>
<ul>
<li><strong>B树和B+树的区别</strong></li>
</ul>
<p>①B树的叶子节点指针为空，而B+树的叶子节点还有双向指针指向左右两边，<strong>提高区间的访问性</strong></p>
<p>②B树每个节点都存放数据，B+树只有叶子节点存放了数据</p>
<h4 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h4><p>首先，要明确一点，存储引擎是修饰表结构的。</p>
<p>目前主要有两种引擎，<strong>MyISAM</strong>和<strong>InnoDB</strong>（现在流行）</p>
<p>他们都是用B+树的索引结构来构建表的，不同之处在于：</p>
<blockquote>
<p>MyISAM的索引和数据是分离在两个文件中的，索引结构的叶子节点存放数据所在的磁盘地址，根据地址去访问数据</p>
<p>InnoDB的数据就放在叶节点</p>
</blockquote>
<p><strong>为什么建议InnoDB表尽量建主键，并且要是整型自增的？</strong></p>
<p>因为不是自增的话，构建B+树时发生分裂和冗余的次数会增多</p>
<h4 id="三、联合索引"><a href="#三、联合索引" class="headerlink" title="三、联合索引"></a>三、联合索引</h4><p>即多个属性作为索引，构建树时，按照声明的属性顺序来排序</p>
<p><strong>索引最左前缀原则</strong></p>
<p>查找记录时，条件里的列属性必须是联合索引从左到右顺序的，不能跳，才会走索引来查找</p>
<p>例如  有联合索引(name，age，job)   查找语句 select * from table where name = 123 and age = 213 会走索引</p>
<p><strong>走索引</strong></p>
<blockquote>
<p>从B+树的根节点开始，向下查找</p>
</blockquote>
<p><strong>如果不走索引，会怎么查找呢？</strong></p>
<p>会从B+树的最左叶子节点，开始向右查找，即全表扫描。</p>
<p><strong>如果一个表既创建了主键索引，又创建了联合索引，那么联合索引的B+树结构是怎么样的？</strong></p>
<p>首先，明确一点，如果像主键索引那样建表（即索引节点+叶子节点放数据），就意味着表的数据要复制一份给联合索引，会造成数据冗余</p>
<p>那么可以只存放必要的数据，即联合索引的多个主键的数据，这样能保证索引到叶子，然后只要叶子节点存放对应的主键索引，就可以去主键索引里找到整条数据。</p>
<h4 id="五、InnoDB索引"><a href="#五、InnoDB索引" class="headerlink" title="五、InnoDB索引"></a>五、InnoDB索引</h4><p><code>InnoDB</code>把索引分为两类，<strong>聚集索引</strong>和<strong>二级索引</strong></p>
<blockquote>
<p><strong>聚集索引</strong>，就是能<strong>唯一确定</strong>数据的逻辑位置和物理位置的索引，在一个表中，只能有一个聚集索引。</p>
<p>除了聚集索引以外的其他索引，都是二级索引。</p>
</blockquote>
<p><strong>聚集索引选择：</strong></p>
<ol>
<li><p><code>InnoDB</code>会把主键作为聚集索引</p>
</li>
<li><p>如果一个表没有设置主键，那么它会找一个唯一且非空的字段作为聚集索引</p>
</li>
<li><p>如果找不到合适字段，就会创建一个名为<code>GEN_CLUST_INDEX</code>的隐式字段作为聚集索引。</p>
</li>
</ol>
<p><strong>聚集索引的好处：</strong>加快查询速度</p>
<p><strong>怎么加快：</strong>查询时，直接地访问到数据行</p>
<p><strong>二级索引和聚集索引的关系：</strong></p>
<p>二级索引中的每条记录都包含了聚集索引的主键列的值，也包含了二级索引定义的字段列的值</p>
<p>然后通过二级索引查找，最终会根据主键值到聚集索引中去查找数据。</p>
<p>因此，主键不要过长，不然二级索引也会占用很多空间。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>笔记2</title>
    <url>/2021/12/13/MySQL/mysql%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<img data-src="https://gitee.com/aurora1004/pictures/raw/master/mysql-struct.png" alt="mysql-struct" style="zoom:150%;" />

<h3 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h3><h4 id="一、层次划分"><a href="#一、层次划分" class="headerlink" title="一、层次划分"></a>一、层次划分</h4><p>主要分为三个层次：</p>
<ul>
<li>MySQL Server层</li>
<li>存储引擎层</li>
<li>文件系统层</li>
</ul>
<h4 id="二、MySQL-Server层"><a href="#二、MySQL-Server层" class="headerlink" title="二、MySQL Server层"></a>二、MySQL Server层</h4><p>Server层包括<strong>连接层</strong>和<strong>SQL层</strong></p>
<blockquote>
<p>注意，图上的Connectors不属于任何一层，可以将 Connectors 理解为各种客户端、应用服务，主要进行是不同语言与 SQL 的交互。</p>
</blockquote>
<p><strong>1. 连接层</strong></p>
<p>即<strong>Connection Pool</strong>部分，当应用程序通过接口（JDBC、ODBC）连接MySQL时，最先接触到的是连接层。</p>
<p>连接层包括以下三部分</p>
<ul>
<li>通信协议</li>
</ul>
<p>负责检测客户端版本是否兼容MySQL服务端</p>
<ul>
<li>线程处理</li>
</ul>
<p>对每个连接请求分配一个线程</p>
<ul>
<li>用户名密码认证</li>
</ul>
<p>验证用户的账号密码即host主机授权是否可以连接到MySQL服务器</p>
<p><strong>Connection Pool（连接池）</strong></p>
<blockquote>
<p>将用户连接、用户名、密码、权限校验、线程处理等需要缓存的需求缓存下来，下次可以直接用已经建立好的连接，提升服务器性能。</p>
</blockquote>
<p><strong>2. SQL层</strong></p>
<p>SQL 层是 MySQL 的核心，MySQL 的核心服务都是在这层实现的。主要包含<strong>权限判断、查询缓存、解析器、预处理、查询优化器、缓存和执行计划。</strong></p>
<ul>
<li><strong>权限判断</strong>可以审核用户有没有访问某个库、某个表，或者表里某行数据的权限。</li>
<li><strong>查询缓存</strong>通过 Query Cache 进行操作，如果数据在 Query Cache 中，则直接返回结果给客户端，不必再进行查询解析、优化和执行等过程。</li>
<li><strong>查询解析器</strong>针对 SQL 语句进行解析，判断语法是否正确。</li>
<li><strong>预处理器</strong>对解析器无法解析的语义进行处理。</li>
<li><strong>查询优化器</strong>对 SQL 进行改写和相应的优化，并生成最优的执行计划，就可以调用程序的 API 接口，通过存储引擎层访问数据。</li>
</ul>
<p><strong>SQL层具体内容如下：</strong></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Management Services &amp; Utilities</td>
<td align="center">MySQL 的系统管理和控制工具，包括备份恢复、MySQL 复制、集群等。</td>
</tr>
<tr>
<td align="center">SQL Interface</td>
<td align="center">用来接收用户的 SQL 命令，返回用户需要查询的结果。例如 SELECT FROM 就是调用 SQL Interface。</td>
</tr>
<tr>
<td align="center">Parser（查询解析器）</td>
<td align="center">在 SQL 命令传递到解析器的时候会被解析器验证和解析，以便 MySQL 优化器可以识别的数据结构或返回 SQL 语句的错误。</td>
</tr>
<tr>
<td align="center">Optimizer（查询优化器）</td>
<td align="center">SQL 语句在查询之前会使用查询优化器对查询进行优化，同时验证用户是否有权限进行查询，缓存中是否有可用的最新数据。它使用“选取-投影-连接”策略进行查询。  例如 <code>SELECT id, name FROM student WHERE gender = &quot;女&quot;;</code>语句中，SELECT 查询先根据 WHERE 语句进行选取，而不是将表全部查询出来以后再进行 gender 过滤。SELECT 查询先根据 id 和 name 进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</td>
</tr>
<tr>
<td align="center">Caches &amp; Buffers</td>
<td align="center">如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的，比如表缓存、记录缓存、key 缓存、权限缓存等。</td>
</tr>
</tbody></table>
<h4 id="三、存储引擎层"><a href="#三、存储引擎层" class="headerlink" title="三、存储引擎层"></a>三、存储引擎层</h4><p>即上图的<strong>Pluggable Storage Engines</strong></p>
<p>本层主要负责数据的<strong>存储和读取</strong></p>
<h4 id="四、文件系统层"><a href="#四、文件系统层" class="headerlink" title="四、文件系统层"></a>四、文件系统层</h4><p>功能：</p>
<ul>
<li><p>将数据存储到操作系统的文件系统内</p>
</li>
<li><p>并负责完成与存储引擎的交互</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>环形链表</title>
    <url>/2021/12/13/LeetCode/9_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">题目请看这里</a></p>
<p>给定链表，判断是否有环</p>
<h2 id="二、思路及代码"><a href="#二、思路及代码" class="headerlink" title="二、思路及代码"></a>二、思路及代码</h2><ul>
<li>思路1</li>
</ul>
<p>可以用set把遍历过的节点存起来，如果遇到重复的，即有环</p>
<p>缺点：使用了额外的空间</p>
<ul>
<li>思路2</li>
</ul>
<p>用快慢指针的方式，当两个指针再次重合时，说明有环存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ListNode fast = head.next;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针 - 链表</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/2021/12/13/LeetCode/8_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">题目请看这里</a></p>
<p>给定股票价格的数组，选择一天买入，之后某一天卖出，求最大利润</p>
<h2 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h2><p>用贪心的思想，尽量让每次都取到最大利润</p>
<p>记录最小值和最大利润，每次遍历时，求出<code>最小值买入，当前价格卖出</code>的利润，并与最大利润比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; ++ i) &#123;</span><br><span class="line">        ans = Math.max(ans, prices[i] - min);</span><br><span class="line">        min = Math.min(min, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2021/12/13/LeetCode/7_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定数组<code>nums</code>， 找出所有<strong>不重复</strong>的三元组$(a,b,c)$，满足$a+b+c=0$</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接硬找肯定不行，可以先对他进行排序，这样至少看起来好了很多</p>
<p>然后再想想，题目要求找三个数之和等于0的，那么如果遍历到大于0的数字，是不是之后就不用再看了，这样范围又缩小了</p>
<p>然后我们考虑从头开始遍历的话，每次遍历到元素<code>a</code>，只要再从后面找到<code>b</code>和<code>c</code>满足条件即可</p>
<p>找<code>b</code>和<code>c</code>我们可以使用双指针来进行移动</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>逻辑</strong></p>
<ul>
<li>对数组排序</li>
<li>从头开始遍历<ul>
<li>通过判断<code>i</code>与<code>i-1</code>来进行去重</li>
<li>定义双指针，令指针向中间移动，直到<code>left</code>越过<code>right</code><ul>
<li>求和并判断</li>
<li>如果大于0，$right-1$</li>
<li>如果小于0，$left+1$</li>
<li>如果等于0，则记录答案，去重，更新指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len &amp;&amp; nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len &amp;&amp; i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] ) ++i;<span class="comment">//注意点1 与前一个进行比较</span></span><br><span class="line">        <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 求和</span></span><br><span class="line">            <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) --right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) ++left;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                tmp.add(nums[i]);</span><br><span class="line">                tmp.add(nums[left]);</span><br><span class="line">                tmp.add(nums[right]);</span><br><span class="line">                ans.add(tmp);</span><br><span class="line">                <span class="comment">//注意点2 先去重，再更新</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) --right;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) ++left;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>去重注意点</strong></p>
<ul>
<li><strong>去重应该等元素判断过后，再去重，否则该元素就被忽视了</strong></li>
<li><strong><code>i</code>的去重可以是与前一个进行比较，以保证<code>i</code>一定被处理过</strong></li>
<li><strong><code>left</code>和<code>right</code>应该在找到目标后，再进行去重，然后更新下标</strong></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>最大字序和</title>
    <url>/2021/12/13/LeetCode/6_%E6%9C%80%E5%A4%A7%E5%AD%97%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h1 id="最大字序和"><a href="#最大字序和" class="headerlink" title="最大字序和"></a>最大字序和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定数组<code>nums</code>，找到具有<strong>最大和</strong>的<strong>连续</strong>子数组，并返回最大和</p>
<p>这道题我们很容易就想到动态规划，然后一般状态定义有两种方式，$dp[i]$可以表示为</p>
<ul>
<li>长度为 $i+1$ 的数组中连续子数组的最大和</li>
<li>以 $nums[i]$ 结尾的连续子数组的最大和</li>
</ul>
<p>我们可以发现，第二种定义更适合状态转移</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        ans = Math.max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>注意，因为数组中可能存在负数</p>
<p>所以如果想要从下标0开始遍历，就要让 <code>cur</code> 和 <code>ans</code> 的初始值为<code>Integer.MIN_VALUE</code>，这样会出现越界！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span> cur = nums[<span class="number">0</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> ans = cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">        cur = Math.max(cur + nums[i], nums[i]);</span><br><span class="line">        ans = Math.max(ans, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>K个一组翻转链表</title>
    <url>/2021/12/13/LeetCode/5_K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">题目请看这里</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定K值，然后依次对链表的k个元素进行翻转</p>
<p>如果剩余不满K个，则不进行翻转</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据翻转链表的思路，再进行计数，每遇到k个元素，就翻转一次</p>
<p>思路并不算复杂，主要是编码较困难</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>封装翻转链表的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode tail = dummyHead;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">                ListNode next = cur.next;</span><br><span class="line">                cur.next = <span class="keyword">null</span>;</span><br><span class="line">                tail = reverseList(tail.next, tail, next);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                cur = next;           </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 举例：如果链表为 1-&gt; 2-&gt;3 -&gt;4 ，要翻转 2-&gt;3</span></span><br><span class="line"><span class="comment">    * @description    返回翻转后的尾部，或者说翻转前的头部	2    </span></span><br><span class="line"><span class="comment">    * @param head     要翻转部分的头节点	2</span></span><br><span class="line"><span class="comment">    * @param preHead  翻转链表外的头部	1</span></span><br><span class="line"><span class="comment">    * @param preTail  翻转链表外的尾部	4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head, ListNode preHead, ListNode preTail)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode tmp = cur.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            tmp = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            cur.next = preTail;</span><br><span class="line">            preTail = cur;</span><br><span class="line">            cur = tmp;    </span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = preTail;</span><br><span class="line">        preHead.next = cur;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>数组中的逆序对</title>
    <url>/2021/12/13/LeetCode/4_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>逆序</code>即前面的元素大于后面的元素</p>
<p><strong>求给定数组中逆序对的个数</strong>，注意，可以是不连续的</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>归并排序在合并的过程中，利用两个指针，依次比较得到较小值，插入到数组中</p>
<p>这一过程正好比较了所有逆序对</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果不熟悉归并排序，建议先了解下归并排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, temp, ans);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> ans[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp, <span class="keyword">int</span>[] ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        mergeSort(nums, left, mid, temp, ans);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, right, temp, ans);</span><br><span class="line"></span><br><span class="line">        merge(nums, left, right, mid, temp, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] temp, <span class="keyword">int</span>[] ans)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(nums, left, temp, left, right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; ++ k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span> || temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">                ans[<span class="number">0</span>] += j - mid - <span class="number">1</span>;</span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// temp[i] &gt; temp[j]</span></span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序数组</title>
    <url>/2021/12/13/LeetCode/3_%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h1><p><a href="https://leetcode-cn.com/problems/sort-an-array/">题目请看这里</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>对给定数组进行排序</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用排序算法</p>
<p>如<strong>归并排序、快速排序、堆排序</strong>等</p>
<h2 id="代码1：归并排序"><a href="#代码1：归并排序" class="headerlink" title="代码1：归并排序"></a>代码1：归并排序</h2><p>主要过程</p>
<ol>
<li>对数组进行划分</li>
<li>划分到长度小于等于7时，用插入排序</li>
<li>然后对两个排序好的数组，进行合并</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            insertSort(nums, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        mergeSort(nums, left, mid, temp);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">// 判断划分完毕的数组是否已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        merge(nums, left, right, mid, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; left &amp;&amp; tmp &lt; nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(nums, left, temp, left, right - left + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; ++ k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span> || temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">                nums[k] = temp[i];</span><br><span class="line">                i ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = temp[j];</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码2：快速排序"><a href="#代码2：快速排序" class="headerlink" title="代码2：快速排序"></a>代码2：快速排序</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2021/12/13/LeetCode/2_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">题目请看这里</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长<strong>公共子序列</strong>的长度。</p>
<p>如果不存在公共子序列，返回 0 。</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划，因为存在两个字符串，所以定义二维数组$dp[i][j]$</p>
<ul>
<li><strong>当i、j所在位置的字符相等时</strong></li>
</ul>
<p>$dp[i][j] = dp[i-1][j-1] + 1$</p>
<ul>
<li><strong>不相等时</strong></li>
</ul>
<p>$dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])$</p>
<p><strong>为了方便状态转移，我们定义数组为$dp[n+1][m+1]$，这样$dp[0][j]和dp[i][0]$都是表示空字符串和其他字符串的公共子序列，必定为0</strong></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示下标从[0:i-1]和[0:j-1]的最长公共子序列</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>每次状态转移只和<strong>当前行</strong>、<strong>前一行</strong>相关，所以可以用<strong>两个一维数组</strong>代替二维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = text1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = text2.length();</span><br><span class="line">        <span class="comment">// dp[i][j] 表示下标从[0:i-1]和[0:j-1]的最长公共子序列</span></span><br><span class="line">        <span class="comment">// 空间优化</span></span><br><span class="line">        <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[len2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++ j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">                    cur[j] = pre[j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur[j] = Math.max(pre[j], cur[j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[len2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>摆动序列</title>
    <url>/2021/12/13/LeetCode/1_%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">题目请看这里</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote>
<p>连续数字的差在正数和负数之间交替，则数字序列就称为<strong>摆动序列</strong></p>
</blockquote>
<p>给定整数序列，返回其摆动序列的最长长度。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>[1,7,4,9,2,5]是长度为6的摆动序列</p>
<h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>定义两种状态，分别为up[i]和down[i]</p>
<p>遍历时分别进行状态转移，最后返回两者中的较大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = nums.length;</span><br><span class="line">	<span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	<span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">	<span class="comment">// init</span></span><br><span class="line">	up[<span class="number">0</span>] = <span class="number">1</span>; down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">            down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">            up[i] = Math.max(down[i-<span class="number">1</span>] + <span class="number">1</span>, up[i-<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">            down[i] = Math.max(up[i-<span class="number">1</span>] + <span class="number">1</span>, down[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(up[len-<span class="number">1</span>], down[len-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong></p>
<p>因为每次状态转移只和上一次相关，所以可以用变量代替数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> down = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++ i) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (nums[i] &gt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">	        up = down + <span class="number">1</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">	        down = up + <span class="number">1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解法二：贪心"><a href="#解法二：贪心" class="headerlink" title="解法二：贪心"></a>解法二：贪心</h2><p>忽略谷和峰之间的数字，每次发生摆动时，才进行加一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len = nums.length;</span><br><span class="line">      <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line"><span class="comment">// 从头开始，找到前后不相同的元素</span></span><br><span class="line">      <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; len &amp;&amp; nums[index] == nums[index-<span class="number">1</span>]) index ++;</span><br><span class="line">      <span class="keyword">if</span> (index == len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">      <span class="keyword">boolean</span> isUp = nums[index] - nums[index-<span class="number">1</span>] &gt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 开始计数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((nums[i] &gt; nums[i-<span class="number">1</span>] &amp;&amp; !isUp) || (nums[i] &lt; nums[i-<span class="number">1</span>] &amp;&amp; isUp)) &#123;</span><br><span class="line">              count ++;</span><br><span class="line">              isUp = !isUp;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2021/12/13/LeetCode/17_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>链接直达<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>给定一个字符串，找出其中的最长的回文子串</p>
<p>回文示例：aba，a，abba等</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>观察<code>abcba</code>回文字符串，我们发现以下特征：</p>
<ol>
<li><code>下标0</code>和<code>下标4</code>处字符相等</li>
<li>它的子结构<code>bcb</code>是回文字符串</li>
<li>单个字符<code>c</code>也是回文的</li>
</ol>
<p><strong>1.状态定义</strong></p>
<p><code>dp[i][j]</code>表示下标从<code>i</code>到<code>j</code>的字符串是否回文（true或false）。</p>
<p><strong>2.状态初始化</strong></p>
<p>$当i == j 时，dp[i][j] = true$，即（1，1）、（2，2）、（3，3）等位置均是<code>true</code>。</p>
<p><strong>3.状态转移</strong></p>
<p>$dp[i][j] = true$：字符串<code>i</code>位置与<code>j</code>位置字符相等，且掐头去尾后，仍是回文字符串，即满足  $dp[i+1][j-1] = true$</p>
<p>$dp[i][j] = false$：除上述情况以外。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//记录变量</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化dp</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">        dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (i == j-<span class="number">1</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>])) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//比较回文串长度</span></span><br><span class="line">                <span class="keyword">if</span> (end - start &lt; j - i) &#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    end = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序链表中的重复元素</title>
    <url>/2021/12/13/LeetCode/16_%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h1><p>链接直达：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>维持一个<code>cur</code>指针，表示当前节点</li>
<li>循环结束条件：<code>cur</code>或<code>cur.next</code>指向空，表示遍历到链表尾部</li>
<li>$cur.val == cur.next.val$<ul>
<li>跳过<code>next</code>节点</li>
</ul>
</li>
<li>$cur.val != cur.next.val$<ul>
<li>更新<code>cur</code>指针，指向下一个节点</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表Ⅱ</title>
    <url>/2021/12/13/LeetCode/15_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/</url>
    <content><![CDATA[<h1 id="环形链表Ⅱ"><a href="#环形链表Ⅱ" class="headerlink" title="环形链表Ⅱ"></a>环形链表Ⅱ</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定链表，返回链表中第一个环节点，如果无环，返回null</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题是环形链表的变形题，在原先基础上，还要找到环节点。</p>
<p>思路依旧是快慢指针，第一次相遇后，让快指针从头开始，一步一步走，慢指针保持不变；然后它们再次相遇时，就在环节点处。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="comment">// 第一次相交</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是空</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 第二次相交</span></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2021/12/13/LeetCode/14_%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一串括号序列，判断它是否可以正确闭合。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>利用栈先入后出的特点来存储左括号，遇到右括号就取出来比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i ++) &#123;</span><br><span class="line">        j = handler(s.charAt(i));</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            stack.push(j);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.poll() + j != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">handler</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span> :</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span> :</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序数组</title>
    <url>/2021/12/13/LeetCode/13_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定两个<code>有序数组</code>nums1和nums2，把两个数组合并成nums1数组。</p>
<p>假定nums1数组容量够大</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从nums1数组的最后开始填充，并用双指针来标记取元素的位置。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从有序数组末尾开始向前遍历</span></span><br><span class="line">        <span class="keyword">int</span> p = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> q = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> end = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q != -<span class="number">1</span>  &amp;&amp; p != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[p] &lt; nums2[q]) &#123;</span><br><span class="line">                nums1[end] = nums2[q];</span><br><span class="line">                q --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[end] = nums1[p];</span><br><span class="line">                p --;</span><br><span class="line">            &#125;</span><br><span class="line">            end --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p != -<span class="number">1</span>) &#123;</span><br><span class="line">            nums1[end] = nums1[p];</span><br><span class="line">            end --;</span><br><span class="line">            p --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != -<span class="number">1</span>) &#123;</span><br><span class="line">            nums1[end] = nums2[q];</span><br><span class="line">            end --;</span><br><span class="line">            q --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树最近公共祖先</title>
    <url>/2021/12/13/LeetCode/12_%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h1><p>题目请看这里：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p>
<p>思路参考了大佬的题解：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/">后序遍历 DFS ，清晰图解</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定两个节点p，q，在它们的公共祖先中找出最近的一个（包含自己）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img data-src="https://gitee.com/aurora1004/pictures/raw/master/Snipaste_2021-04-27_11-23-17.png"></p>
<p>这类题可以用递归方式求解，那么具体怎么递归呢？</p>
<p>我们可以先处理左右子节点，然后根据左右子节点的情况，递推到父节点，这就是<code>后序遍历</code>的思想</p>
<p><strong>现在假设root是当前节点，left是子节点，right是右节点</strong></p>
<p><strong>递归终止条件：</strong></p>
<ul>
<li>遍历到叶子节点</li>
<li>遇到目标节点</li>
</ul>
<p><strong>递归过程：</strong></p>
<p>对<code>left</code>和<code>right</code>采取递归，得到返回值</p>
<p><strong>递归返回值（核心）：</strong></p>
<ul>
<li><code>left</code>为空且<code>right</code>为空，说明当前节点的子树不存在目标节点，返回<code>null</code></li>
<li><code>left</code>不为空且<code>right</code>不为空，说明目标节点分布在子树两侧，返回<code>root</code></li>
<li><code>left</code>和<code>right</code>只有一个不为空，返回不为空的那个</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树锯齿形遍历</title>
    <url>/2021/12/13/LeetCode/11_%E4%BA%8C%E5%8F%89%E6%A0%91%E9%94%AF%E9%BD%BF%E5%BD%A2%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="二叉树锯齿形遍历"><a href="#二叉树锯齿形遍历" class="headerlink" title="二叉树锯齿形遍历"></a>二叉树锯齿形遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一颗二叉树，按照从左到右，再从右到左的层序进行遍历。</p>
<p>在层序遍历基础上，需要更改遍历的方向，因此一个普通的队列满足不了，需要双端队列来存储。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; dQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 初始化一些数据</span></span><br><span class="line">        dQueue.addFirst(root);</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        List&lt;Integer&gt; tmp;</span><br><span class="line">        <span class="keyword">boolean</span> isCurLeft = <span class="keyword">true</span>;<span class="comment">// 表示当前一层是否是从左到右遍历的</span></span><br><span class="line">		<span class="comment">// 队列为空时，完成遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!dQueue.isEmpty()) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 按照size来对这一层完成遍历</span></span><br><span class="line">            size = dQueue.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 从左往右遍历时，操作与层序遍历的一致</span></span><br><span class="line">                <span class="keyword">if</span> (isCurLeft) &#123;</span><br><span class="line">                    root = dQueue.removeFirst();</span><br><span class="line">                    tmp.add(root.val);</span><br><span class="line">                    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        dQueue.addLast(root.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        dQueue.addLast(root.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 从右往左时，需要从后面开始读元素，并且按先右后左的顺序添加到队列头部</span></span><br><span class="line">                    root = dQueue.removeLast();</span><br><span class="line">                    tmp.add(root.val);</span><br><span class="line">                    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        dQueue.addFirst(root.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        dQueue.addFirst(root.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                size --;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 把这一层遍历的结果添加到最终数组里</span></span><br><span class="line">            result.add(tmp);</span><br><span class="line">            isCurLeft = !isCurLeft;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树层序遍历</title>
    <url>/2021/12/13/LeetCode/10_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个二叉树，返回按<strong>层序遍历</strong>得到的值</p>
<p>我们可以使用一个队列来存储每次遍历到的元素</p>
<p>因为队列先进先出的性质，它就维持了按层遍历的特点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">      Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">// 如果根节点为空，直接返回空数组</span></span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 做一些初始化的准备</span></span><br><span class="line">      queue.offer(root);</span><br><span class="line">      List&lt;Integer&gt; tmp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="comment">// 通过size来确认一层一层遍历</span></span><br><span class="line">          <span class="keyword">int</span> size = queue.size();</span><br><span class="line">          <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              root = queue.poll();</span><br><span class="line">              tmp.add(root.val);</span><br><span class="line">              <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  queue.offer(root.left);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  queue.offer(root.right);</span><br><span class="line">              &#125;</span><br><span class="line">              size --;</span><br><span class="line">          &#125;</span><br><span class="line">          result.add(tmp);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>(四).阻塞队列介绍</title>
    <url>/2021/12/13/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h3><p>从上一篇笔记中，我们了解了线程池对线程的复用机制，就让我们再好好回顾下吧。</p>
<blockquote>
<p>Executor中的线程在执行完自己的任务后，还会通过getTask()方法主动向阻塞队列获取任务</p>
<p>对于核心线程来说，它是用take()来阻塞地获取任务</p>
<p>而非核心线程是通过poll()来获取任务，如果超时，则放弃获取</p>
</blockquote>
<p>正是这样的机制，才使得核心线程一直存在于线程池中，而非核心线程空闲到了存活时间就会被销毁。</p>
<h3 id="二、架构分析"><a href="#二、架构分析" class="headerlink" title="二、架构分析"></a>二、架构分析</h3><p>上面还涉及到了一个很重要的问题，就是从阻塞队列获取任务。</p>
<p><strong>那么阻塞队列是怎样设计的呢？就让我们来看看它的结构吧</strong></p>
<h4 id="1-BlockingQueue"><a href="#1-BlockingQueue" class="headerlink" title="1.BlockingQueue"></a>1.BlockingQueue</h4><p>可以看到，它继承了Queue接口，那肯定少不了队列的一些常规方法</p>
<p>但我们要看的是阻塞队列提供的一些其他方法，下面一一介绍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//省略队列的一些常规方法，如add()、offer()等</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放入元素，会阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// 放入元素，超时后放弃</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取元素,会阻塞</span></span><br><span class="line">	<span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;   </span><br><span class="line">    <span class="comment">// 获取元素，超时后放弃</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回队列剩余大小 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 删除队列中的所有元素，并移动到指定集合</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">类型</th>
<th align="center">策略</th>
</tr>
</thead>
<tbody><tr>
<td align="center">put</td>
<td align="center">+</td>
<td align="center">阻塞</td>
</tr>
<tr>
<td align="center">offer</td>
<td align="center">+</td>
<td align="center">超时机制</td>
</tr>
<tr>
<td align="center">take</td>
<td align="center">-</td>
<td align="center">阻塞</td>
</tr>
<tr>
<td align="center">poll</td>
<td align="center">-</td>
<td align="center">超时机制</td>
</tr>
</tbody></table>
<p>上面的<strong>BlockingQueue</strong>只是定义了接口，那么我们看看它是具体怎么实现的吧</p>
<p>从下图中我们发现有许多队列实现了<strong>BlockingQueue</strong>，下面我们挑几个讲讲</p>
<p><img data-src="/images/blocking_queue_1.PNG"></p>
<hr>
<h4 id="2-ArrayBlockingQueue"><a href="#2-ArrayBlockingQueue" class="headerlink" title="2.ArrayBlockingQueue"></a>2.ArrayBlockingQueue</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);		<span class="comment">// 默认创建的锁是非公平的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123; <span class="comment">// fair表示锁是否公平</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;                 <span class="comment">// 把给定集合中的元素添加到数组中</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">                checkNotNull(e);</span><br><span class="line">                items[i++] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;</span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a><strong>成员变量</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用数组来存放元素</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示队列头部的下标，每次取元素时用。</span></span><br><span class="line"><span class="comment">// take, poll, peek or remove</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示插入新元素所在的下标</span></span><br><span class="line"><span class="comment">// put, offer, or add</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 使用经典的教科书式的 two-condition 算法 | 但我不会啊，我又没看过  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">// 取元素时的条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">// 放元素时的条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前迭代器的共享状态</span></span><br><span class="line"><span class="keyword">transient</span> Itrs itrs = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p><strong>首先，对外的添加元素方法有</strong></p>
<ol>
<li>add(E) </li>
<li>offer(E) </li>
<li>put(E)</li>
<li>offer(E, long, TimeUnit)</li>
</ol>
<p><strong>而这些方法内部实际都用调用enqueue(E)</strong></p>
<p>那么就先来看看enqueue方法，大致思路还是很简单的，如下：</p>
<blockquote>
<p>在指定位置放入元素，然后<strong>putIndex</strong>加一</p>
<p>当<strong>putIndex</strong>等于数组长度时，令它为0，从头开始添加元素</p>
<p>最后唤醒一个在<strong>notEmpty</strong>的等待队列中的线程（删除元素的线程，因为阻塞队列为空，所以等在notEmpty的队列中）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接下来看看put(E)和offer(E, long, TimeUnit)</strong></p>
<p>put()的思路也很清晰：</p>
<ol>
<li>进行非空判断后，加锁</li>
<li>然后判断队列是否满，如果满了就让当前线程进入notFull的等待队列中</li>
<li>如果没有满，则添加元素</li>
<li>解锁</li>
</ol>
<p>和put()相比，offer()在循环体中加入了是否超时的判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await(); </span><br><span class="line">        enqueue(e); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout); <span class="comment">// 根据超时的时间长度和单位，换算成纳秒级别</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)             <span class="comment">// 判断是否超时</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p>老规矩，先介绍下对外方法</p>
<ol>
<li>peek()</li>
<li>remove(Object)</li>
<li>poll()</li>
<li>poll(long, TimeUnit)</li>
<li>take()</li>
</ol>
<p>peek()返回<strong>takeIndex</strong>所在位置的元素，不作删除</p>
<p>remove(Object)从<strong>takeIndex</strong>开始向<strong>putIndex</strong>遍历，找到第一个匹配的元素，删除掉，然后更新元素位置</p>
<p>后面三个方法都用到了<strong>dequeue()</strong></p>
<p><strong>那来看看这个方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E x = (E) items[takeIndex]; </span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接下来看看poll(), take(), poll(long, TimeUnit)方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果阻塞队列为空，就把当前线程加入到notEmpty的等待队列中，等待唤醒</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在take()的基础上添加了超时判断</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-DelayQueue"><a href="#3-DelayQueue" class="headerlink" title="3.DelayQueue"></a>3.DelayQueue</h4><h5 id="构造方法及属性"><a href="#构造方法及属性" class="headerlink" title="构造方法及属性"></a>构造方法及属性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br></pre></td></tr></table></figure>

<p>可以发现，<strong>DelayQueue</strong>的一些特点</p>
<ul>
<li>使用Java的<strong>优先级队列</strong>来存储元素</li>
<li>使用<strong>Leader-Follower</strong>模式处理任务</li>
</ul>
]]></content>
      <categories>
        <category>线程和线程池</category>
      </categories>
  </entry>
  <entry>
    <title>(二).线程的返回结果</title>
    <url>/2021/12/13/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<p><strong>严肃脸.jpg</strong>: Java实现线程三种方式是哪三种？</p>
<p><strong>答</strong>: Thread、Runnable、Callable</p>
<p>其中Runnable接口定义的run方法是没有返回参数的，那么这样看来：</p>
<p><strong>Java的线程想要返回结果，就需要用到实现Callable接口的对象。</strong></p>
<p>那我们来看看这个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面只定义了一个call()方法，返回的是泛型。</p>
<p>注释里提到，既可以是<strong>返回结果</strong>，也可以是<strong>抛出异常</strong></p>
<hr>
<p><img data-src="/images/executor_1.PNG"></p>
<p><strong>上面这张图能够方便我们了解线程池各类的关系。</strong></p>
<p>另外，我们一般是用线程池的方式来创建线程执行任务。</p>
<p><strong>所以再来看看线程池提供的方法吧</strong></p>
<p>如果看过上一篇笔记，我们就可以知道：线程池提供了submit()方法</p>
<ul>
<li>它是由<strong>ExecutorService</strong>接口定义的具有返回值的方法</li>
<li>并且返回值是<strong>Future</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>如上所示，该接口定义了三个submit()方法</p>
<p>有没有发现特别的地方，就是它居然能传进来<strong>Runnable</strong>对象！而我们之前所了解到的是Runnable对象是无法返回结果的。</p>
<p><strong>那么它是怎么做到的呢？</strong></p>
<p>那就要来到<strong>ExecutorService</strong>的实现类了，即<strong>AbstractExecutorService</strong></p>
<p>我们就随便挑一个传Runnable对象的方法<del>（总共不是有两个嘛）</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，里面创建了一个<strong>RunnableFuture</strong>对象，接下来让我<strong>无脑推理一波：</strong></p>
<p>$RunnableFuture = Runnable + Future$</p>
<p>所以这个类就是实现了两个接口，那么它既能被当作<strong>Runnable</strong>对象去执行，又能当作<strong>Future</strong>对象来返回</p>
<p>这样子就说得通了。</p>
<p><strong>既然Future是返回结果类型，那么我们再去看看它是咋样的吧</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，里面就只有5个方法，这可太简单了是不是</p>
<p>而且这些方法看方法名就知道它是干啥了，就不用我多说了吧</p>
<p><strong>这里就讲一点：</strong></p>
<p>无参数的get()会一直阻塞地等待返回结果</p>
<p>有参数的，则会在超时时间后放弃等待</p>
]]></content>
      <categories>
        <category>线程和线程池</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>并发(待完善)</title>
    <url>/2021/12/13/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B9%B6%E5%8F%91%EF%BC%88%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h4 id="一、多线程的优缺点"><a href="#一、多线程的优缺点" class="headerlink" title="一、多线程的优缺点"></a>一、多线程的优缺点</h4><ul>
<li><strong>优点</strong></li>
</ul>
<p>和进程相比，线程的调度和切换成本更小。</p>
<p>多核CPU能够让多个线程同时运行，还能减少线程上下文切换的开销，提高CPU利用率</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p>可能会遇到<strong>内存泄漏、死锁、线程不安全</strong>的情况</p>
<ul>
<li><strong>补充</strong></li>
</ul>
<p>Java内存泄漏：主要是由于长生命周期的对象持有短生命周期的引用，如集合里存放类对象</p>
<h4 id="二、死锁"><a href="#二、死锁" class="headerlink" title="二、死锁"></a>二、死锁</h4><ul>
<li>互斥性</li>
</ul>
<blockquote>
<p>同一时间只能有一个线程持有某个对象的锁</p>
</blockquote>
<ul>
<li>可见性</li>
</ul>
<blockquote>
<p>锁释放之前，共享变量的修改要对其他线程可见</p>
</blockquote>
<hr>
<p><strong>Java内存模型：</strong></p>
<p>内存分为<code>主内存</code>和<code>工作内存</code></p>
<p><code>主内存</code>是所有线程共享的，如<strong>堆、方法区</strong></p>
<p><code>工作内存</code>是线程私有的区域，如<strong>虚拟机栈、程序计数器</strong>等</p>
<hr>
<p><strong>volatile</strong>关键字的作用：</p>
<ol>
<li><strong>保证线程间变量的可见性</strong></li>
</ol>
<p>一个变量如果用<strong>volatile</strong>修饰，那么：</p>
<p>①某个线程修改变量后，要写回主内存中</p>
<p>②某个线程要读取该变量时，要从主内存中读，而不是缓存</p>
<ol start="2">
<li><strong>禁止指令重排序</strong></li>
</ol>
<p>注意：volatile不保证原子性</p>
<h4 id="三、锁"><a href="#三、锁" class="headerlink" title="三、锁"></a>三、锁</h4><ol>
<li><strong>互斥锁</strong></li>
<li><strong>偏向锁</strong></li>
</ol>
<p>背景：在多数情况下，锁不仅不存在多线程竞争，而且还总是由同一线程多次获得</p>
<p>目的：让线程获得锁的代价更低</p>
<p>实现：</p>
<p>一个线程想要获取对象锁时，先查看对象头的锁记录里是否有线程ID</p>
<p>如果有，直接获取锁</p>
<p>如果设置了，说明是其他线程获得了锁，就发起竞争，由<strong>偏向锁</strong>变为<strong>轻量级锁</strong></p>
]]></content>
      <categories>
        <category>线程和线程池</category>
      </categories>
  </entry>
  <entry>
    <title>(一).Java线程的简单介绍</title>
    <url>/2021/12/13/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/Java%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="1-Java实现线程的三种方式"><a href="#1-Java实现线程的三种方式" class="headerlink" title="1. Java实现线程的三种方式"></a>1. Java实现线程的三种方式</h4><ul>
<li>继承Thread类</li>
</ul>
<p>查看Thread的源码，可以发现，它是实现了 <code>Runnable</code> 接口</p>
<p>因此也是通过调用 <code>run</code> 方法来运行的</p>
<ul>
<li>实现Runnable接口</li>
</ul>
<p>是一个接口，定义了run方法。</p>
<ul>
<li>实现Callable接口</li>
</ul>
<p>第三种比较特殊，是用于需要线程返回信息的情况。</p>
<h4 id="2-线程的生命周期"><a href="#2-线程的生命周期" class="headerlink" title="2. 线程的生命周期"></a>2. 线程的生命周期</h4><p>线程池管理着多个线程的创建与销毁</p>
<p>那么线程的生命周期是怎样的呢，让我们来一探究竟！</p>
<ul>
<li>新建（new）</li>
</ul>
<p>使用 <code>new</code> 关键字创建线程后，就处于 <code>新建</code> 状态，JVM为线程分配内存空间，并初始化成员变量</p>
<ul>
<li><p>就绪（runnable）</p>
<p>调用 <code>start</code> 方法后，处于 <code>就绪</code> 状态，JVM为它创建方法栈和程序计数器</p>
</li>
<li><p>运行（running）</p>
</li>
</ul>
<p>得到CPU时间片后，开始执行 <code>run</code> 方法体</p>
<ul>
<li>阻塞（blocked）</li>
</ul>
<p>线程因某种原因放弃了CPU，进入阻塞</p>
<table>
<thead>
<tr>
<th align="center">阻塞类型</th>
<th align="center">描述</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">等待阻塞</td>
<td align="center">执行wait方法</td>
<td align="center">进入等待队列中（waiting queue）</td>
</tr>
<tr>
<td align="center">同步阻塞</td>
<td align="center">获取锁失败</td>
<td align="center">进入锁池（lock pool）</td>
</tr>
<tr>
<td align="center">其他阻塞</td>
<td align="center">执行sleep或join或IO请求</td>
<td align="center">状态置为阻塞</td>
</tr>
</tbody></table>
<ul>
<li>死亡（dead）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">正常死亡</td>
<td align="center">执行完方法体</td>
</tr>
<tr>
<td align="center">异常结束</td>
<td align="center">抛出异常</td>
</tr>
<tr>
<td align="center">调用stop</td>
<td align="center">直接调用stop来结束该线程（可能会出问题）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>线程和线程池</category>
      </categories>
  </entry>
  <entry>
    <title>类加载过程</title>
    <url>/2021/12/13/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一、类加载过程"><a href="#一、类加载过程" class="headerlink" title="一、类加载过程"></a>一、类加载过程</h2><p>要把一个类的Class文件加载到Java虚拟机中，大致分为三个步骤：<strong>加载、连接和初始化</strong></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>把字节流中的静态数据结构，加载到JVM中，形成运行时的数据结构</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接又可以细分成：验证、准备和解析。</p>
<h4 id="1-验证"><a href="#1-验证" class="headerlink" title="1.验证"></a>1.验证</h4><p>即验证Class文件是否符合规范，同时对语义进行确认</p>
<h4 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h4><p>为类级变量分配内存空间，并设置初始值。</p>
<p>PS：实例变量并不分配，因为它是和对象实例绑定在一起的，要在实例化对象的时候才会进行内存分配。</p>
<h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3.解析"></a>3.解析</h4><p>把常量池中符号引用解析成指针或者偏移量。</p>
<p>PS：不然光靠一个名称去找它，多累啊；还是知道准确地址好点。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>遇到四个关键字时，对类进行初始化操作。</p>
<h2 id="二、加载机制"><a href="#二、加载机制" class="headerlink" title="二、加载机制"></a>二、加载机制</h2><p>类的加载是通过<strong>加载器</strong>来完成的，具体的加载机制是<strong>双亲委派机制</strong></p>
<h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><p>Java自带的有3种，<strong>引导类加载器、扩展类加载器</strong>和<strong>应用程序类加载器</strong></p>
<p>这三者的关系是祖孙三代的关系，来张图表示下吧</p>
<img data-src="https://gitee.com/aurora1004/pictures/raw/master/classloader.png" alt="classloader_WPS图片" style="zoom:67%;" />

<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>双亲委派机制，就是指要加载某个类时，向上传递请求，一直到启动类加载器</p>
<p>然后依次判断能不能加载，不能的话再往下传。</p>
<h3 id="为什么要这样做呢？"><a href="#为什么要这样做呢？" class="headerlink" title="为什么要这样做呢？"></a>为什么要这样做呢？</h3>]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java锁机制</title>
    <url>/2021/12/13/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="一、同步方式"><a href="#一、同步方式" class="headerlink" title="一、同步方式"></a>一、同步方式</h1><p>涉及到线程安全的问题时，往往有两种方式进行数据的同步，即<code>互斥同步</code>和<code>非阻塞同步</code>。</p>
<ul>
<li><p>互斥同步</p>
<p>悲观的思想，认为<code>加锁</code>才能保证数据的线程安全性</p>
<p>线程挂起、唤醒的操作需要由操作系统来进行，因此互斥同步需要在用户态和内核态切换，开销较大</p>
</li>
<li><p>非阻塞访问</p>
<p>乐观思想，当获取不到锁时，重复地去获取</p>
<p>这是基于硬件指令集的发展而来的，因为有了<code>Compare-and-Swap</code>指令</p>
</li>
</ul>
<h1 id="二、锁优化"><a href="#二、锁优化" class="headerlink" title="二、锁优化"></a>二、锁优化</h1><p>在这里，锁不仅仅指互斥同步的锁，还包含了一些不用互斥、阻塞的锁。</p>
<h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>当一个线程获取不到锁时，会在处理器中自旋一段时间，避免频繁地挂起、阻塞。</p>
<p><strong>优化版：根据上次情况，适当改变自旋次数</strong></p>
<p>如果上次获取过这个对象的锁，那么这次获取的机会也大，自旋次数可以增加一些</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>检测到持有锁的对象没有发生逃逸，不会存在竞争关系，可以消除当前对象的锁</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>多个锁变为一个锁</p>
<hr>
<p>后面的锁会提到底层实现，所以先需要了解一些前缀知识。</p>
<h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>对象头包含<code>mark word</code>和标记，其中<code>mark word</code>包含了对象的哈希码、回收年龄等。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>前面提到互斥锁需要切换到内核态，开销较大。所以我们思考，能不能用非阻塞的方式来实现锁机制。</p>
<p>而轻量级锁就是一种基于<code>CAS</code>的锁机制。</p>
<p><strong>加锁过程</strong></p>
<ol>
<li><p>在线程的栈帧中开辟<code>Lock Record</code>空间，记录对象头中<code>mark word</code>内容</p>
</li>
<li><p>用<code>CAS</code>操作把指向<code>Lock Record</code>的指针替换对象头中的<code>mark word</code></p>
<p>如果成功，则表示获取到锁，可以执行同步代码块</p>
<p>如果失败，检验一下指针是不是指向自己栈帧的，来判断锁是不是自己的        </p>
</li>
</ol>
<p><strong>释放锁过程</strong></p>
<ol>
<li><p>用<code>CAS</code>操作尝试把<code>Lock Record</code>的内容覆盖到<code>对象头</code>中</p>
<p>如果成功，释放成功</p>
<p>如果失败，释放并唤醒其他线程???</p>
</li>
</ol>
<p>如果有两个以上线程竞争，就会进行<code>锁膨胀</code>，变为重量级锁</p>
<p>轻量级锁在有竞争时，既有互斥的开销，还要进行CAS，所以存在竞争时性能较差</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>思想：绝大多数情况下，资源都不存在竞争。</p>
<p>偏向锁使用了更加轻量级的方式，它连CAS都不用进行，直接令当前线程获取锁。</p>
<p>但是一旦发生了竞争，就要根据是否加锁，来变为<code>无锁</code>或<code>轻量级锁</code>状态</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>多个线程竞争时，轻量级锁会膨胀为重量级锁，它就表示以前的互斥锁。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2021/12/13/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>在介绍Java内存模型之前，我们先了解下计算机的内存模型，这对Java的内存模型有着很大的参考作用。</p>
<h2 id="1-1计算机—多任务处理"><a href="#1-1计算机—多任务处理" class="headerlink" title="1.1计算机—多任务处理"></a>1.1计算机—多任务处理</h2><blockquote>
<p>当前计算机大部分是支持多任务处理；在许多场景下，计算机可以同时处理多个任务。</p>
</blockquote>
<p>为什么这样做</p>
<ol>
<li><p>压榨CPU资源</p>
<p>如果只有一个任务，它进行I/O操作时，CPU会空闲</p>
<p>因此安排多任务执行，避免资源浪费</p>
</li>
<li><p>多请求的客观事实</p>
<p>一个服务器端往往会同时收到几个客户端的请求</p>
</li>
</ol>
<h2 id="1-2计算机—内存模型"><a href="#1-2计算机—内存模型" class="headerlink" title="1.2计算机—内存模型"></a>1.2计算机—内存模型</h2><h3 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h3><p>根据冯诺依曼提出的计算机体系结构，我们令处理器和主存进行通信：</p>
<img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504152643.png" alt="image-20210504152623819" style="zoom: 67%;" />

<p><strong>缺陷：</strong></p>
<p>处理器访问寄存器的速度远快于访问主存的速度，而每次都要从主存读数据，要等待很久</p>
<h3 id="版本2-1"><a href="#版本2-1" class="headerlink" title="版本2.1"></a>版本2.1</h3><p>添加高速缓存，把常用的数据放在缓存中，供处理器直接访问。它的访问速度仅次于寄存器，但是比主存快很多。</p>
<img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504153055.png" alt="image-20210504153047767" style="zoom:67%;" />

<p><strong>缺陷：</strong></p>
<ul>
<li><p>缓存一致性：多个高速缓存如何保证数据的一致（或者说，同步）</p>
</li>
<li><p>指令重排序问题：</p>
<p>处理器内部会优化指令的顺序，以保证CPU资源的高效利用；</p>
<p>指令重排序保证当前任务内排序后的结果是和原先保持一致的，但不保证多任务间数据的协调。</p>
</li>
</ul>
<h3 id="版本2-2"><a href="#版本2-2" class="headerlink" title="版本2.2"></a>版本2.2</h3><p>添加缓存一致性协议，来确保缓存间数据的可见性</p>
<p><strong>可见性</strong>就是指当一个高速缓存内的数据发生变化时，其他拥有该数据的高速缓存应该能察觉到它的变化。</p>
<img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504154702.png" alt="image-20210504154658533" style="zoom:67%;" />

<h1 id="二、Java内存模型"><a href="#二、Java内存模型" class="headerlink" title="二、Java内存模型"></a>二、Java内存模型</h1><p>Java内存模型设计如下：</p>
<p>可以看到，它和计算机的内存模型基本一致。</p>
<ul>
<li><p>Java线程用来执行任务，每个线程都拥有工作内存；</p>
</li>
<li><p>所有的任务都必须在工作内存中执行。</p>
</li>
<li><p>所有的数据都存放在主内存中，通过<code>save</code>和<code>load</code>等操作加载到工作内存中</p>
</li>
</ul>
<img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504155538.png" alt="image-20210504155535163" style="zoom:67%;" />

<h2 id="2-1原子操作"><a href="#2-1原子操作" class="headerlink" title="2.1原子操作"></a>2.1原子操作</h2><p>Java提供了一些原子的、不可再分的操作，如下。</p>
<h3 id="作用于主内存中的变量"><a href="#作用于主内存中的变量" class="headerlink" title="作用于主内存中的变量"></a>作用于主内存中的变量</h3><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">lock</td>
<td align="center">加锁，标志一个变量为线程独占状态</td>
</tr>
<tr>
<td align="center">unlock</td>
<td align="center">解锁，把一个处于线程独占状态的变量释放出来</td>
</tr>
<tr>
<td align="center">read</td>
<td align="center">把变量传输到工作内存中，配合load使用</td>
</tr>
<tr>
<td align="center">write</td>
<td align="center">把工作内存传来的变量写入到主内存中，配合store使用</td>
</tr>
</tbody></table>
<h3 id="作用于工作内存中的变量"><a href="#作用于工作内存中的变量" class="headerlink" title="作用于工作内存中的变量"></a>作用于工作内存中的变量</h3><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">load</td>
<td align="center">把主内存传来的变量放入工作内存的变量副本中</td>
</tr>
<tr>
<td align="center">use</td>
<td align="center">把变量传递给执行引擎</td>
</tr>
<tr>
<td align="center">assign</td>
<td align="center">把执行引擎传过来的变量赋值给工作内存</td>
</tr>
<tr>
<td align="center">store</td>
<td align="center">把变量传给主内存</td>
</tr>
</tbody></table>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>使用<code>read</code>和<code>load</code>组合把变量从<code>主内存</code>传递到<code>工作内存</code>，并保存在工作内存的变量副本中。</p>
<p>使用<code>store</code>和<code>write</code>组合把变量从<code>工作内存</code>传递到<code>主内存</code>，并写入。</p>
<h1 id="三、内存模型三大特征"><a href="#三、内存模型三大特征" class="headerlink" title="三、内存模型三大特征"></a>三、内存模型三大特征</h1><blockquote>
<p>Java内存模型以及相关指令主要是围绕<strong>如何处理并发过程中的原子性、可见性和有序性</strong>进行的。</p>
</blockquote>
<p>下面我们就来谈谈这三大特征。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><blockquote>
<p>原子性，指某个操作不可再分。</p>
</blockquote>
<p>上面提到的8个指令都支持原子性：</p>
<ul>
<li><p>8个指令本身都是原子性的</p>
<p>单个操作是原子性的，一起使用就不一定了</p>
</li>
<li><p>lock和unlock可以保证更大维度的原子性</p>
<p><code>synchronized</code>关键字是用字节码指令<code>monitorenter</code>和<code>monitorexit</code>实现的，这两个指令隐式的表达了<code>lock</code>和<code>unlock</code>的意思。</p>
</li>
</ul>
<p>所以我们可以认为：</p>
<ol>
<li><p><strong>基本数据类型的访问、读写都是具有原子性的</strong></p>
</li>
<li><p><strong><code>synchronized</code>关键字修饰的代码块是具有原子性的</strong></p>
</li>
<li><p><strong><code>volatile</code>关键字修饰的变量是不具备原子性的</strong></p>
<p>这个如何理解呢？</p>
<p>volatile修饰，只是保证了读取变量时，是最新的正确的</p>
<p>但是后续的更新、赋值过程，别的线程是可以修改变量，从而使当前值失效的。</p>
</li>
</ol>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><blockquote>
<p>可见性指<strong>volatile</strong>修饰的变量，一旦被某个线程修改，其他线程可以立刻察觉到变化。</p>
</blockquote>
<p>Java有3个关键字能实现可见性，分别是<code>volatile</code>、<code>synchronized</code>和<code>final</code></p>
<ul>
<li><p><strong>volatile</strong>，后面会介绍</p>
</li>
<li><p><strong>synchronized</strong></p>
<p><code>unlock</code>后必须写回到主内存，从而保证了可见性</p>
</li>
<li><p><strong>final</strong></p>
<p>该关键字修饰的变量，一旦完成初始化，其他线程都可见。</p>
</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><blockquote>
<p>如果在本线程内观察，所有操作都是有序的；如果在其他线程中观察，那么观察到的都是无序的操作。</p>
</blockquote>
<p>两种方式实现有序性：</p>
<ul>
<li><p>volatile，后面介绍</p>
</li>
<li><p>synchronized</p>
<p>因为变量在同一时间只能被一个线程<code>lock</code>，所以代码块只能串行进入。</p>
</li>
</ul>
<h1 id="四、Volatile关键字"><a href="#四、Volatile关键字" class="headerlink" title="四、Volatile关键字"></a>四、Volatile关键字</h1><p><code>volatile</code>关键字用来修饰变量，它有两个作用：</p>
<ul>
<li>保证可见性</li>
<li>禁止指令重排序</li>
</ul>
<p>接下来我们从内存模型的角度理解一下它的实现。</p>
<h2 id="3-1保证可见性"><a href="#3-1保证可见性" class="headerlink" title="3.1保证可见性"></a>3.1保证可见性</h2><blockquote>
<p>可见性指<strong>volatile</strong>修饰的变量，一旦被某个线程修改，其他线程可以立刻察觉到变化。</p>
</blockquote>
<p>Java虚拟机通过原子操作实现了这一点</p>
<p>现在假设变量<code>a</code>是被volatile修饰的，那么</p>
<ol>
<li><p><code>read</code>、<code>load</code>和<code>use</code>组合使用</p>
<p><code>a</code>在使用时必须从主内存中读取到工作内存中，然后再传递给执行引擎</p>
</li>
<li><p><code>asign</code>、<code>store</code>和<code>write</code>组合使用</p>
<p><code>a</code>修改后，由执行引擎传递给工作空间，然后必须再写回主内存中。</p>
</li>
</ol>
<h2 id="3-2禁止指令重排序"><a href="#3-2禁止指令重排序" class="headerlink" title="3.2禁止指令重排序"></a>3.2禁止指令重排序</h2><blockquote>
<p>指令重排序是处理器为了高效利用资源而进行的操作</p>
<p>该操作不影响当前线程的最终结果</p>
</blockquote>
<p>在多线程环境下，指令重排序可能会造成访问数据错误。</p>
<p>虚拟机通过设置<code>内存屏障</code>的方式来禁止指令重排，具体地说，是禁止让屏障之后的指令，重排序到内存屏障的前面。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>三、垃圾回收机制</title>
    <url>/2021/12/13/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/3.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><h2 id="一、垃圾"><a href="#一、垃圾" class="headerlink" title="一、垃圾"></a>一、垃圾</h2><h3 id="1-1-什么是垃圾"><a href="#1-1-什么是垃圾" class="headerlink" title="1.1 什么是垃圾"></a>1.1 什么是垃圾</h3><p>在Java中，没有被任何一个对象引用的实例，就会被当作垃圾来回收</p>
<h3 id="1-2-怎样判断垃圾"><a href="#1-2-怎样判断垃圾" class="headerlink" title="1.2 怎样判断垃圾"></a>1.2 怎样判断垃圾</h3><p>有两种方式来判断</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><blockquote>
<p>每有一个对象引用该实例，它的值就加1</p>
<p>当值为0时，说明没有对象引用它，就可以确认为垃圾。</p>
</blockquote>
<p>但是它存在一个缺陷，即无法判断<strong>循环引用</strong>的垃圾</p>
<p>因此，往往需要考虑许多额外的情况，才能让这个算法正确运行。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote>
<p>从GC Roots的根对象开始向下搜索，如果某个实例没有和GC Roots相连，就表明它是垃圾</p>
</blockquote>
<p>在这种算法中，如何选择<code>GC Roots</code>就是很关键的一点。</p>
<p>Java中固定可作为GC Roots的有以下几项：</p>
<ol>
<li>虚拟机栈中引用的对象</li>
<li>方法区中常量、静态变量引用的对象</li>
<li>本地方法栈中<code>native</code>方法引用的对象</li>
<li>虚拟机内部的引用，包括基本数据类型的Class对象，常驻的异常对象等</li>
<li>被同步锁持有的对象</li>
</ol>
<p>除了固定的<code>GC Roots</code>集合外，可以根据用户所选择的垃圾回收器及当前回收的区域不同，而”临时性”地加入一些其他对象。</p>
<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK1.2以前，引用是非常传统的定义，即</p>
<blockquote>
<p>reference类型的数据中存储的数值代表是另一块内存的地址，就称该reference是代表某块内存、某个对象的引用</p>
</blockquote>
<p>而这样简单的定义，又无法来表示那些<code>食之无味，弃之可惜</code>的对象</p>
<p>因此，JDK1.2以后，Java的引用扩充成了4种，主要有：</p>
<ul>
<li>强引用</li>
<li>软引用</li>
<li>弱引用</li>
<li>虚引用</li>
</ul>
<p>它们各自的表现如下</p>
<table>
<thead>
<tr>
<th align="center">引用名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">强引用</td>
<td align="center">符合传统定义</td>
</tr>
<tr>
<td align="center">软引用</td>
<td align="center">内存快溢出时，进行回收</td>
</tr>
<tr>
<td align="center">弱引用</td>
<td align="center">下一次垃圾回收时必定回收</td>
</tr>
<tr>
<td align="center">虚引用</td>
<td align="center">最弱，目的只是为了让这个对象在被回收时，能收到一个系统通知</td>
</tr>
</tbody></table>
<h4 id="只有一次的复活甲"><a href="#只有一次的复活甲" class="headerlink" title="只有一次的复活甲"></a>只有一次的复活甲</h4><p>当一个对象被发现时没有与<code>GC Roots</code>相连，它就会被认定为是垃圾</p>
<p>但是它还有一次复活的机会，那这个机会在哪里呢？让我们慢慢道来</p>
<pre class="mermaid">graph LR
  A[垃圾] --> B{执行过finalize};
  B -->|Y| C[等死];
  B -->|N| D[丢到队列中执行finalize];
  D --> E{还没执行就被引用};
  E -->|Y| F[直接复活];
  E -->|N| G[继续等死];</pre>

<h2 id="二、基本回收算法"><a href="#二、基本回收算法" class="headerlink" title="二、基本回收算法"></a>二、基本回收算法</h2><p>最基础的回收算法有三种，它们各有特色。</p>
<h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记-清除"></a>1. 标记-清除</h3><p>描述：标记垃圾，然后统一清除</p>
<p>缺点：</p>
<ol>
<li>产生碎片</li>
<li>标记清除的过程效率低</li>
</ol>
<h3 id="2-标记-复制"><a href="#2-标记-复制" class="headerlink" title="2. 标记-复制"></a>2. 标记-复制</h3><p>描述：内存分半，标记时把所有存活对象复制到另一半，然后直接清空当前这一半</p>
<p>缺点：空间浪费</p>
<p>特点：</p>
<ol>
<li><p>存活对象较少时，复制消耗少，运行高效</p>
</li>
<li><p>避免碎片化</p>
</li>
</ol>
<p><strong>因为新生代存活对象较少，所以适合标记-复制算法。</strong></p>
<h3 id="3-标记-整理"><a href="#3-标记-整理" class="headerlink" title="3. 标记-整理"></a>3. 标记-整理</h3><p>描述：标记时把存活对象移动到一起，然后统一清除剩余部分</p>
<p>特点：</p>
<ol>
<li>性能较差</li>
<li>避免碎片化</li>
</ol>
<h2 id="三、分代"><a href="#三、分代" class="headerlink" title="三、分代"></a>三、分代</h2><p><strong>为什么要分代？</strong></p>
<p>因为对象有两类，有的存活时间长，有的存活时间短</p>
<p>把他们分开来，用不同的回收算法来处理，就可以做到时间和空间的高效利用。</p>
<p><strong>怎么分代呢？</strong></p>
<p>首先把<code>堆空间</code>按1：2分为新生代和老年代</p>
<p>新生代又基于<code>大部分对象都活的不久</code>的事实，按8：1：1分为伊甸区、两个存活区。</p>
<p>其中新生代大部分都是要回收的垃圾</p>
<h2 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h2><p>在分代时期，新生代和老年代各有3种垃圾收集器</p>
<p>如果没有具体介绍回收算法，那么新生代统一使用<code>标记-复制</code>算法，老年代统一使用<code>标记-整理</code>算法。</p>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>用单一线程来执行垃圾回收，且回收时用户线程必须暂停</p>
<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p><code>Serial</code>的多线程版本，一般用来和<code>CMS</code>合作进行</p>
<h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>也是多线程进行回收，但是它的关注点不同。</p>
<p>其他的垃圾收集器关注用户线程的停顿时间，以保证用户交互的质量；</p>
<p>而<code>Parallel Scavenge</code>更加关注吞吐量，即用户线程运行时间与总时间的比值，适合后台运算而非交互，</p>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>老年代版的单线程回收方式。</p>
<h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>老年代版的多线程回收。</p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>CMS全称为concurrent mark sweep，即并发标记清除，所以它是一种基于标记清除的算法，只不过实现得更加复杂。</p>
<p>主要分为四个过程：</p>
<ol>
<li><p><strong>初始标记</strong></p>
<p>暂停用户线程，由GC线程记录与GC Root相连的对象</p>
</li>
<li><p><strong>并发标记</strong></p>
<p>用户线程和GC线程一起运行，GC线程从第一步发现的对象开始，往下搜索，记录可达对象</p>
</li>
<li><p><strong>重新标记</strong></p>
<p>暂停用户线程，GC查看上一步标记过程中标记发生变化的区域，进行修正</p>
</li>
<li><p><strong>并发清除</strong></p>
<p>开启用户线程，同时GC线程对未标记的区域进行清扫</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>因为是基于标记清除算法的，所以会有碎片</li>
<li>并发操作时占用CPU资源</li>
<li>清除时用户线程也在执行，所以需要预留空间，即提前进行回收。</li>
</ol>
<h2 id="五、G1收集器"><a href="#五、G1收集器" class="headerlink" title="五、G1收集器"></a>五、G1收集器</h2><p>自G1收集器开始，分代的概念越来越淡。</p>
<p>它的主要思想是<strong>局部收集</strong>和<strong>独立分区</strong>。</p>
<ul>
<li><p><strong>局部收集</strong></p>
<p>指进行垃圾回收时，选择性价比最高的一些区域进行回收</p>
</li>
<li><p><strong>独立分区</strong></p>
<p>新生代和老年代不再是固定的了，它将堆内存分为多个大小相等的区域，然后每个区域根据需要，可以扮演原先分代中各区的角色。</p>
</li>
</ul>
<p><strong>过程：</strong></p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/3.1%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h2><h3 id="1-1-对象构成是怎样的？"><a href="#1-1-对象构成是怎样的？" class="headerlink" title="1.1 对象构成是怎样的？"></a>1.1 对象构成是怎样的？</h3><p>在JVM中，堆中的对象可以由三部分组成：</p>
<ol>
<li><strong>对象头</strong></li>
<li><strong>实例数据</strong></li>
<li><strong>对齐填充</strong>（满足8字节的整数倍）</li>
</ol>
<p>其中对象头又可以分为<code>markword</code>和<code>类型指针</code>，前者包含对象自身运行时的数据，如哈希码、锁标志、分代年龄等；后者是指向方法区对象类型信息的指针。</p>
<h3 id="1-2-如何分配对象？"><a href="#1-2-如何分配对象？" class="headerlink" title="1.2 如何分配对象？"></a>1.2 如何分配对象？</h3><p>创建对象意味着要给对象分配一块内存空间，有两种常见的分配方式：<strong>指针碰撞</strong>和<strong>空闲列表</strong></p>
<p><strong>指针碰撞</strong></p>
<ul>
<li>由<code>已分配 | 未分配</code>的格式构成，分配时只需移动中间的指针即可。</li>
</ul>
<p><strong>空闲列表</strong></p>
<ul>
<li>通过链表记录可用的内存块，然后进行分配。</li>
</ul>
<h3 id="1-3-如何访问对象实例？"><a href="#1-3-如何访问对象实例？" class="headerlink" title="1.3 如何访问对象实例？"></a>1.3 如何访问对象实例？</h3><p><strong>Java的引用存在于栈中，我们需要有一种方式来通过引用访问堆上的对象实例。</strong></p>
<p>主流的方式有<strong>句柄</strong>和<strong>直接地址</strong>。</p>
<p><strong>句柄</strong></p>
<ul>
<li>描述：在堆中维护句柄池，引用先指向句柄池，再由句柄池指向对象</li>
<li>特点：解决了移动对象需要修改引用的问题，但增加了句柄池的开销</li>
</ul>
<p><strong>直接地址</strong></p>
<ul>
<li>描述：引用直接指向对象实例</li>
<li>特点：对象移动时需要修改引用</li>
</ul>
<h2 id="二、对象与垃圾回收的常见问题"><a href="#二、对象与垃圾回收的常见问题" class="headerlink" title="二、对象与垃圾回收的常见问题"></a>二、对象与垃圾回收的常见问题</h2><h3 id="2-1-对象的跨代、跨区域引用"><a href="#2-1-对象的跨代、跨区域引用" class="headerlink" title="2.1 对象的跨代、跨区域引用"></a>2.1 对象的跨代、跨区域引用</h3><p><strong>产生原因</strong></p>
<p>使用根可达算法遍历对象图时，如果对象存在跨代引用，则我们可能需要把其他代的对象也全部遍历一次，<strong>来保证根可达算法的准确性</strong></p>
<p><strong>解决方案</strong></p>
<p>通过分代假说理论，可以得知产生跨代引用的对象并不多。可以使用<code>记忆集</code>的思想来记录发生跨代引用的区域。</p>
<p>具体方式为：将另一代分成若干个区域，只需在<code>记忆集</code>中记录发生跨代引用的区域，然后扫描那些区域即可。</p>
<p><strong>记忆集的具体实现方式为：卡表。</strong>可以把它看作是一个数组，它的每个元素代表一块内存区域，如果存在跨代引用的对象，则置1，不存在则置0。</p>
<p><strong>卡表存在的两个问题：写屏障和伪共享</strong></p>
<ul>
<li><strong>写屏障</strong><ul>
<li>问题由来：跨代引用产生在对象引用赋值时，如果采用编译执行的方式，如何在执行机器码时维护卡表。</li>
<li>简单理解：代码已经写死了，你要怎样动态地插入代码</li>
<li><strong>解决：使用类似于AOP的写屏障，在引用赋值的前后，维护卡表</strong></li>
</ul>
</li>
<li><strong>伪共享</strong><ul>
<li>问题由来：现代CPU的缓存使用缓存行，即一行为单位进行存储。如果多个卡表元素位于同一个缓存行时，可能会出现并发情况下的数据失效。</li>
<li>解决：修改卡表前增加一次判断操作，确认卡表元素未标记（表示没有跨代引用）时，才进行标记操作。</li>
</ul>
</li>
</ul>
<h3 id="2-2并发扫描时可能产生的对象错误"><a href="#2-2并发扫描时可能产生的对象错误" class="headerlink" title="2.2并发扫描时可能产生的对象错误"></a>2.2并发扫描时可能产生的对象错误</h3><p><strong>三色指针</strong>：通过三种颜色来标志对象在扫描过程中的状态。</p>
<ul>
<li>黑：对象已被扫描过，且它的所有引用也扫描过</li>
<li>灰：对象被扫描，但它的引用还没扫描完</li>
<li>白：垃圾收集器还没访问，或访问不到</li>
</ul>
<p>并发扫描时，因为用户线程也在运行着，所以有可能出现对象被判定为垃圾的致命情况，当且仅当以下两个条件<strong>同时满足</strong>：</p>
<ol>
<li><strong>删除所有从灰色节点到目标白色节点的引用</strong><ul>
<li>如果没有其他引用，那么这个对象已经是垃圾了</li>
</ul>
</li>
<li><strong>新增从黑色节点到目标白色节点的引用</strong><ul>
<li>这个操作保证目标节点是对象</li>
</ul>
</li>
</ol>
<p>解释：上面两个条件满足后，对象仍然是活的，但是它却是白色的，且再也无法被扫描到，就会被当作垃圾回收掉。</p>
<p>为了避免这种致命情况发生，我们必须破坏上述的至少一个条件，因此产生了两种解决方案：<strong>增量更新</strong>和<strong>原始快照</strong></p>
<ul>
<li><strong>增量更新</strong><ul>
<li>新增<code>黑色</code>节点到<code>白色</code>节点的引用时，记录下<code>黑色</code>节点；然后到最后再以黑色节点为根开始扫描一次。</li>
<li>理解：黑色节点新增引用后，就视为灰色节点了</li>
</ul>
</li>
<li><strong>原始快照</strong><ul>
<li>删除<code>灰色</code>节点到<code>白色</code>节点的引用时，记录下<code>灰色</code>节点；然后最后再以灰色节点为根扫描一次</li>
<li>理解：无论是否删除，都以删除前一刻的快照进行扫描</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JVM内存结构</title>
    <url>/2021/12/13/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/2.JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="JVM——内存结构"><a href="#JVM——内存结构" class="headerlink" title="JVM——内存结构"></a>JVM——内存结构</h1><p>JVM把它内部分成了好几块内存区域，每个区域存放不同的东西</p>
<p><strong>总体的结构如下：</strong></p>
<p>可以看到，运行时数据区主要分为两类，一类是<strong>线程私有</strong>的，另一类是<strong>线程共享</strong>的</p>
<img data-src="https://gitee.com/aurora1004/pictures/raw/master/jvm_str.jpg" alt="jvm_str" style="zoom: 67%;" />

<hr>
<h2 id="一、线程私有"><a href="#一、线程私有" class="headerlink" title="一、线程私有"></a>一、线程私有</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>是当前线程所执行的字节码的<strong>行号指示器</strong></p>
<blockquote>
<p>因为Java是多线程的，它的多线程是通过线程轮流切换、分配处理器执行时间来实现的。<br>那么每次切换完线程后，如果想回到之前的一个线程，就需要一个行号指示器，指向上个线程所执行的地方。<br>所以程序计数器就实现了这个功能，另外，这也说明了程序计数器是每个线程私有的，只有这样才能满足线程之间的切换。</p>
</blockquote>
<p>有两个注意点</p>
<ol>
<li>是唯一一个不会产生内存溢出的区域</li>
<li>正在执行java方法的话，计数器记录的是当前指令的地址；如果是Native方法，则为null。</li>
</ol>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈和线程的生命周期相同</p>
<p>每个方法在执行的同时，会创建一个栈帧，用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息</p>
<blockquote>
<ul>
<li><strong>局部变量表存放了编译器可知的基本数据类型、对象引用类型和returnAddress类型。</strong></li>
</ul>
</blockquote>
<ul>
<li>这些数据类型在表中是以变量槽（slot）的形式表示的，long和double占两个槽，其他都占一个槽。</li>
</ul>
<p>方法从调用到执行完成，对应了栈帧在虚拟机栈中的入栈与出栈</p>
<p>注意，虚拟机栈会报StackOverflowError和OutOfMemoryError这两种<em><strong>异常</strong></em></p>
<ol>
<li>前者是因为线程请求的栈的深度大于虚拟机所允许的深度<code>@递归或循环调用</code></li>
<li>后者是因为栈动态扩展的时候申请不到足够的内存<code>@创建大数组</code></li>
</ol>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>为本地方法服务，在HotSpot中，本地方法栈和虚拟机栈<strong>合二为一</strong>了</p>
<hr>
<h2 id="二、线程共享"><a href="#二、线程共享" class="headerlink" title="二、线程共享"></a>二、线程共享</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote>
<p>堆是JVM内存中最大的一块区域。笼统来说，堆唯一的目的就是存放对象<strong>实例</strong>，所以垃圾回收也主要在这里进行。</p>
</blockquote>
<p>堆中可以划分出多个TLAB（线程私有的分配缓冲区），以提升对象分配时的效率。</p>
<p>当堆没有内存可供分配，且也无法请求更多的内存来扩展，就会报OutOfMemoryError异常</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>方法区存储的是被JVM加载的<strong>类型信息、常量、静态变量</strong>、即时编译器编译后的代码缓存等数据。</p>
<p>类型信息：访问修饰符、类名、方法和字段的描述。。。</p>
</blockquote>
<p>方法区的实现很有意思</p>
<ol>
<li>在jdk8之前，它是用堆中永久代来实现的</li>
<li>jdk8及以后，采用元空间</li>
<li>另外，在jdk7时，HotSpot就已经将原本放在方法区的<strong>字符串常量池</strong>和<strong>静态变量</strong>移到了堆中。</li>
</ol>
<p>方法区也是要进行垃圾回收的，不过它回收目标主要是针对常量池的回收和对类型的卸载。</p>
<p><strong>运行时常量池</strong></p>
<p>如果看过之前那篇Class文件结构的博客，可能还记得Class文件中有一个叫做<code>常量池</code>的表</p>
<p>里面主要存放了<code>字面量</code>和<code>符号引用</code>（可以理解成一些类信息的字符串，如类名、方法名等）</p>
<p>这些是在<strong>类加载后</strong>存放到方法区的<strong>运行时常量池</strong>的</p>
<p><strong>特征</strong></p>
<p><code>运行时常量池</code>和字节码文件中的常量池相比，有一个很大的特征，即<code>动态性</code></p>
<p>因为常量并不是只在编译时产生，程序运行时也可能产生新的常量，这时候就会动态添加到常量池中。</p>
<hr>
<h2 id="三、直接内存"><a href="#三、直接内存" class="headerlink" title="三、直接内存"></a>三、直接内存</h2><blockquote>
<p>不是JVM运行时数据区的一部分，但也会频繁地调用</p>
</blockquote>
<p><a href="https://imgchr.com/i/DmDHbQ"><img data-src="https://s3.ax1x.com/2020/11/18/DmDHbQ.png" alt="DmDHbQ.png"></a>
    </p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>一、JVM总览</title>
    <url>/2021/12/13/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/1.JVM%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h3><p>JVM全称是<em><strong>Java Virtual Machine</strong></em>，即<strong>java虚拟机</strong>。</p>
<p>那么虚拟机又是什么呢</p>
<blockquote>
<p>虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
</blockquote>
<p>在学习Java之初，老师就强调了Java是门跨平台的语言，那么，它究竟是怎么跨平台的呢？</p>
<p>首先，我们运行Java程序，就是把Java文件编译成class字节码文件<br>然后JVM上的解释器获取字节码文件，把它解释成机器码<br>而机器码就可以跑在计算机上了</p>
<p>简而言之，JVM就是运行在操作系统上的一个进程，它通过解释器把class文件（即字节码）解释成<strong>特定机器</strong>上的机器码，以此来执行程序。这也正是Java可以<strong>跨平台运行</strong>的原因。</p>
<h3 id="二、JVM为什么好"><a href="#二、JVM为什么好" class="headerlink" title="二、JVM为什么好"></a>二、JVM为什么好</h3><p>了解了JVM大概是什么之后，我们来看下JVM的优点。</p>
<ul>
<li>跨平台<ul>
<li>上面提到了Java程序可以运行在虚拟机上，以此做到跨平台</li>
</ul>
</li>
<li>垃圾回收机制<ul>
<li>自动进行垃圾回收，实现对象内存的管理和释放</li>
</ul>
</li>
</ul>
<p><del>实在编不出来了</del></p>
<h3 id="三、怎么学JVM"><a href="#三、怎么学JVM" class="headerlink" title="三、怎么学JVM"></a>三、怎么学JVM</h3><p>既然JVM有这么多好处，那怎么学习？</p>
<p>那肯定要总揽全局，先看看JVM有哪些内容，然后分模块地学习，最后把所有模块联系在一起。</p>
<p>首先来看下JVM里主要的几个部分：</p>
<ol>
<li><em>JVM内存结构</em></li>
<li><em>Java类加载机制</em></li>
<li><em>JVM垃圾回收机制</em>（GC）</li>
<li><em>调优常用命令</em>（偏应用向）</li>
</ol>
<h3 id="四、大致流程"><a href="#四、大致流程" class="headerlink" title="四、大致流程"></a>四、大致流程</h3><p>先了解JVM内部的结构，分成哪几个部分啥的；<br>然后一个Java类要执行，它是怎么加入到内存结构中的，即JVM是怎样分配内存的；<br>如果这个类一直在运行，Java是怎么回收那些没被使用的对象的<br>怎样使用命令去查看JVM-GC的具体细节</p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p><del>白嫖一下别人的总结</del></p>
<ol>
<li><p>虚拟机并不神秘，在操作系统的角度看来，它只是一个普通<strong>进程</strong>。</p>
</li>
<li><p>这个叫做虚拟机的进程比较特殊，它能够加载我们编写的class文件。如果把JVM比作一个人，那么class文件就是我们吃的食物。</p>
</li>
<li><p>加载class文件的是一个叫做类加载器的子系统。就好比我们的嘴巴，把食物吃到肚子里。</p>
</li>
<li><p>虚拟机中的执行引擎用来执行class文件中的字节码指令。就好比我们的肠胃，对吃进去的食物进行消化。</p>
</li>
<li><p>虚拟机在执行过程中，要分配内存创建对象。当这些对象过时无用了，必须要自动清理这些无用的对象。清理对象回收内存的任务由垃圾收集器负责。就好比人吃进去的食物，在消化之后，必须把废物排出体外，腾出空间可以在下次饿的时候吃饭并消化食物。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>并发学习笔记</title>
    <url>/2021/12/13/Java/Java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1/</url>
    <content><![CDATA[<h1 id="一、理解"><a href="#一、理解" class="headerlink" title="一、理解"></a>一、理解</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>最早接触<code>原子性</code>是在事务的四大特性中，当时理解的是事务要么全部完成，要么就失败回滚。</p>
<p>看了<code>并发编程实战后</code>，看到了对<code>原子性</code>的全新理解</p>
<blockquote>
<p>假设有两个操作A和B，从执行A的线程来看，另一个线程执行B时，要么把B全部执行完，要么就完全不执行，那么A和B对彼此来说，都是原子的。</p>
</blockquote>
<h2 id="this逃逸"><a href="#this逃逸" class="headerlink" title="this逃逸"></a>this逃逸</h2><blockquote>
<p>在类的构造方法中，把<strong>this引用</strong>传递出去，就会造成<strong>this逃逸</strong>。</p>
<p>哪怕逃逸的语句是写在构造方法的最后一行，但因为JVM指令重排序，可能会让它先执行。</p>
</blockquote>
<p>一种<strong>常见的情况</strong>就是在构造方法中启动了一个新线程，我们可以使用<strong>工厂方法</strong>来避免。</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/Java/Java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/AQS%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="了解AQS"><a href="#了解AQS" class="headerlink" title="了解AQS"></a>了解AQS</h2><h3 id="AQS是什么？它是用来做什么的？"><a href="#AQS是什么？它是用来做什么的？" class="headerlink" title="AQS是什么？它是用来做什么的？"></a>AQS是什么？它是用来做什么的？</h3><p>AbstractQueuedSynchronizer（AQS）翻译为<strong>抽象的队列式的同步器</strong>，它是一个用于实现锁和同步器的框架。</p>
<p>它提供了基本的框架结构<code>@如等待队列的维护</code>，保留了一些细节交由开发者实现<code>@如尝试获取和释放锁</code>。</p>
<p>因此借助AQS，我们可以较为容易地开发自己的同步器</p>
<h3 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h3><p>将阻塞的线程放入到队列中进行等待，</p>
<h3 id="AQS如何使用？"><a href="#AQS如何使用？" class="headerlink" title="AQS如何使用？"></a>AQS如何使用？</h3><p>编写类继承它，并实现必要的方法。</p>
<h3 id="AQS的组成"><a href="#AQS的组成" class="headerlink" title="AQS的组成"></a>AQS的组成</h3><p>两个内部类</p>
<ul>
<li>Node：双向队列的节点</li>
<li>ConditionObject：未知</li>
</ul>
<p>AQS的</p>
<h2 id="深入AQS"><a href="#深入AQS" class="headerlink" title="深入AQS"></a>深入AQS</h2><p>AQS加锁</p>
]]></content>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2021/12/13/Java/Java%E5%AE%B9%E5%99%A8/HashMap/</url>
    <content><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>从<code>加入元素</code>过程开始思考：</p>
<ul>
<li>如何计算hash</li>
<li>定位数组下标的方式，及冲突的解决方式</li>
<li>树化（变为红黑树）或扩容的条件</li>
</ul>
<h2 id="1-计算hash"><a href="#1-计算hash" class="headerlink" title="1. 计算hash"></a>1. 计算hash</h2><p>计算hash主要使用的是Object对象提供的<code>hashCode()</code>方法</p>
<p>但是，它经过了一次扰动才返回真正的hash值。</p>
<p><strong>key</strong>的哈希码的高16位与低16位进行<strong>异或</strong>，增加低十六位的<strong>随机性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-计算数组下标"><a href="#2-计算数组下标" class="headerlink" title="2. 计算数组下标"></a>2. 计算数组下标</h2><p><strong>代码</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">tab[i = (n - <span class="number">1</span>) <span class="meta">&amp; hash]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，计算下标的方式是<strong>与运算</strong></p>
<p>简单地说，下标就是扰动后的hash对数组容量求余，得到的<strong>余数</strong></p>
</blockquote>
<p><strong>解释</strong></p>
<p>首先，hashmap通过<code>tableSizeFor</code>方法保证数组大小是2的整数次幂</p>
<blockquote>
<p>PS：如果初始化时传入的不是2的整数次幂，会通过该方法调整为大于该数的最小的2的整数次幂。例如传入13，该方法返回16</p>
</blockquote>
<p>其次，在n是2的整数次幂的情况下，对n求余可以通过上述<code>与运算</code>进行</p>
<p>但是，由于<code>n-1</code>的二进制低位全是1，高位全是0。这样它们进行<code>与运算</code>时，可能就只用到了hash的低位（具体用到几位和n-1位数有关）</p>
<blockquote>
<p>PS：16 - 1 的二进制有个特点，即<strong>低位全是1，高位全是0</strong></p>
</blockquote>
<p><strong>这样出现哈希冲突的可能就会增大，所以就需要扰动函数，来增加低位hash值的随机性</strong></p>
<h2 id="3-哈希冲突"><a href="#3-哈希冲突" class="headerlink" title="3. 哈希冲突"></a>3. 哈希冲突</h2><p>计算完数组下标后，如果数组上的该位置为空，则直接把节点放入即可。</p>
<p>如果已经有节点，就意味着发生了<code>哈希冲突</code>。</p>
<p><strong>解决方式：拉链法或树化</strong></p>
<p><strong>先直接尾插，然后判断，</strong></p>
<ol>
<li>链表长度小于等于8：什么都不做</li>
<li>链表长度超过8，<strong>尝试</strong>树化，变为红黑树</li>
</ol>
<p><strong>为什么说是尝试树化呢？</strong></p>
<p>因为树化时有一个判断：<strong>如果数组长度小于64，则不会树化，而是先扩容数组然后重新计算哈希</strong></p>
<h2 id="4-数组扩容机制"><a href="#4-数组扩容机制" class="headerlink" title="4. 数组扩容机制"></a>4. 数组扩容机制</h2><ul>
<li><strong>capacity：</strong>数组长度，默认为16</li>
<li><strong>load factor：</strong>负载因子，默认为0.75</li>
<li><strong>threshold：</strong>数组中存放元素的上限，默认12</li>
</ul>
<p><strong>计算公式：</strong>$\quad threshold = capacity * load factor$</p>
<p>当HashMap中的元素个数**大于临界值(threshold)**时，就会进行扩容：</p>
<ol>
<li>把数组容量变为原来的两倍</li>
<li>重新计算hash(这里是指元素在散列表中的位置，即索引，与数组大小有关，所以发生了变化)</li>
</ol>
<h2 id="5-插入过程"><a href="#5-插入过程" class="headerlink" title="5. 插入过程"></a>5. 插入过程</h2><p>插入元素时：</p>
<ol>
<li>如果数组索引处节点是空的，就新建一个节点</li>
<li>如果索引处节点不为空，则插入到链表中（1.7头插法，1.8尾插法）</li>
<li>如果是树节点，则调用插入树节点的方法</li>
</ol>
<p>插入完毕后：</p>
<p>如果链表长度大于8，则判断数组容量，小于64就进行<strong>resize</strong>，大于64就<strong>由链表</strong>优化成<strong>红黑树</strong></p>
<h3 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h3><p><strong>方法介绍</strong></p>
<p>传入用户指定的初始容量，然后返回大于该数值的最近的2的幂次</p>
<p>例如输入11，返回16</p>
<p><strong>分析</strong></p>
<ol>
<li>n = cap - 1</li>
<li>不考虑边界情况时，n的最高位是1；然后把最高位后的所有位都置为1<ul>
<li>做法<ul>
<li>n右移1位，和原数n进行与，使第二位为1</li>
<li>n右移2位，和原数与，使第三四位为1</li>
<li>以此类推，将n除去最高位的其他位都设置为1</li>
</ul>
</li>
<li><strong>目的：得到$2^n-1$，最后把1加回来即可得到2的幂次</strong></li>
</ul>
</li>
<li>n + 1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// 判断数组是否为空或长度为0，然后进行扩容</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 数组该下标位置为空，无哈希冲突，则直接插入到数组中</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 数组索引处存在节点，发生碰撞</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;  <span class="comment">// 判断是不是重复元素，如果是的话，会在下面覆盖。</span></span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 尾插后链表长度大于8，尝试树化</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// 覆盖重复元素</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue; <span class="comment">// 返回旧的value，覆盖相同key的时候才会从这里返回</span></span><br><span class="line">            &#125;					 <span class="comment">// 这里还可以让HashSet的add方法返回false</span></span><br><span class="line">        &#125;						 <span class="comment">// 因为add方法调用了putVal方法，具体返回为 putVal(...) == null</span></span><br><span class="line">        ++modCount;				 <span class="comment">// false则说明在HashMap中遇到并覆盖了重复的元素</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HashSet的add方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-补充"><a href="#6-补充" class="headerlink" title="6.补充"></a>6.补充</h2><p><strong>1.判断是否为重复的key</strong></p>
<p>必须满足两个条件</p>
<ol>
<li>两个key的hash值相同</li>
<li>key的引用地址相同或者equals相等</li>
</ol>
<h1 id="其他Hash容器"><a href="#其他Hash容器" class="headerlink" title="其他Hash容器"></a>其他Hash容器</h1><h2 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1.HashSet"></a>1.HashSet</h2><p><strong>结构？</strong></p>
<p>内部就是使用的HasMap</p>
<p><strong>如何去重？</strong></p>
<p>利用了HashMap的put方法的返回值。</p>
<p>put方法返回的值有两种情况</p>
<ol>
<li><strong>null</strong>：key为null或者不存在</li>
<li><strong>非空</strong>：覆盖了已存在key，返回旧key</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.<span class="built_in">put</span>(e, PRESENT) == null;</span><br><span class="line">    <span class="comment">// 这里可以看到，HashSet添加元素，是把元素作为map的key,而map的value则是一个常量Object，在最上方定义。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-Hashtable"><a href="#2-Hashtable" class="headerlink" title="2.Hashtable"></a>2.Hashtable</h2>]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList</title>
    <url>/2021/12/13/Java/Java%E5%AE%B9%E5%99%A8/ArrayList/</url>
    <content><![CDATA[<p>谈谈arraylist</p>
<p>1.底层实现    是对象数组</p>
<p>2.构造方法   3种</p>
<p>3.扩容机制</p>
<p>默认大小是10</p>
<p>如果不指定大小，会先创建空数组，在添加元素的时候把数组扩容成10，然后放满都不会扩容，直到添加第11个元素</p>
<p>如果指定大小，比如5，那么放入第六个元素时才会进行扩容</p>
<p>扩容是每次容量*1.5倍，用了位运算</p>
<p>4.最大容量</p>
<p>整型最大值 - 8</p>
<p>大于这个值，就调用hugeCapacity方法，把容量变成整型的最大值</p>
<p>如果溢出，就抛出错误。</p>
<p>5.添加大量元素</p>
<p>添加大量元素时，arraylist会经过多次扩容，性能较低，这时候可以调用ensureCapacity方法，提前让数组扩容一次，以满足需求</p>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>基础概念</title>
    <url>/2021/12/13/Java/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><p><strong>面向过程</strong>是以过程为中心，把问题分解成一个个步骤，然后按步骤来执行。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>面向对象</strong>是一种基于现实世界的概念，以万物皆为对象的思想来解决问题。</p>
<h3 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h3><p><strong>封装：</strong></p>
<ul>
<li>描述：提取出事物的特征和行为，封装成对象</li>
<li>作用：隐藏细节，代码模块化</li>
</ul>
<p><strong>继承：</strong></p>
<ul>
<li>描述：子类继承父类，从而拥有父类的属性和方法</li>
<li>作用：在不修改原来类的基础上，可以进行扩展或修改</li>
<li><strong>补充：一般想要扩展或修改某个类的原有方法，可以使用继承或组合的方式</strong></li>
</ul>
<p><strong>多态：</strong></p>
<ul>
<li>描述：声明为父类的引用，但是创建为子类的对象实例</li>
<li>作用：可以用父类的形象去执行，从而屏蔽了不同子类的细节</li>
</ul>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/Java/Java%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>String、StringBuffer</title>
    <url>/2021/12/13/Java/Java%E5%9F%BA%E7%A1%80/String%E4%B8%8EStringBuffer/</url>
    <content><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>最近在做算法题时用到了StringBuffer的一些方法</p>
<p>所以特地来了解一下String类与StringBuffer类的一些原理及操作</p>
<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>在学Java之初，我们就已经知道String是不可变的</p>
<blockquote>
<p>什么是不可变呢？</p>
<p>例如对一个String类型的对象进行修改时，每次得到的都是新的String对象</p>
<p>而原来的String对象是是一直不变的</p>
</blockquote>
<p>但它究竟是怎么实现的呢</p>
<p>我们先来看下String的源码，可以看到</p>
<ul>
<li><strong>final关键字修饰了类和字符数组</strong><ul>
<li>禁止继承，避免子类继承后，修改内容</li>
</ul>
</li>
<li><strong>字符数组还是private的</strong><ul>
<li>一定程度上防止外界访问到字符数组</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>但是只靠这样，就能保证String的不可变性吗</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><strong>首先，我们可以知道一点，用final关键字修饰的变量，一旦被创建就无法再修改</strong></p>
<p>所以下面将<code>tmp</code>的引用赋值给<code>arr</code>，会提示错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">arr = tmp;</span><br></pre></td></tr></table></figure>

<p>但是arr数组在内存中其实是分为两部分的，即<strong>引用</strong>和<strong>数组本体</strong></p>
<p><strong>引用放在Stack中，而数组本体在Heap中</strong></p>
<p>如果我们直接去修改堆中的数组，是否会造成改变呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 输出 10，2，3</span></span><br><span class="line"><span class="comment">// 可以final数组改变了</span></span><br></pre></td></tr></table></figure>

<p>由此我们知道用<code>final</code>关键字修饰，还是无法避免数组内容的修改</p>
<h2 id="replace-源码分析"><a href="#replace-源码分析" class="headerlink" title="replace()源码分析"></a>replace()源码分析</h2><p>那么该怎样避免这种情况呢，我们很容易就能想到，当然是依赖于具体方法的实现。</p>
<p>就以<code>replace(oldChar, newChar)</code>为例，我们先来分析下大致逻辑</p>
<ul>
<li>在$oldChar != newChar$时</li>
<li>然后在原数组中找到第一个oldChar</li>
<li>如果存在oldChar<ul>
<li>创建新数组</li>
<li>oldChar之前的字符直接复制到新数组</li>
<li>oldChar及以后的字符，边复制边判断</li>
<li>如果等于oldChar，就替换成newChar</li>
</ul>
</li>
<li>如果$oldChar==newChar$或者原数组中没有oldChar，就直接返回原数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                buf[j] = val[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完逻辑之后，我们发现当存在oldChar时，他会创建一个新的数组，替换oldChar并返回</p>
<p>也许在这之前，我们会好奇它为什么要创建新的数组</p>
<p><strong>但今天我们很容易就联想到，它的这个操作正是为了防止原数组被修改，从而保证了String的不可变性</strong></p>
<h2 id="不可变的作用"><a href="#不可变的作用" class="headerlink" title="不可变的作用"></a>不可变的作用</h2><p>从上面我们大概可以推断出，String类的设计者在类的方法中尽力避免原数组的修改，来保证其不可变性</p>
<p>那不可变究竟有什么用呢？</p>
<ul>
<li>最重要的一点，就是安全<ul>
<li>String不可变，可以避免将String对象作为传参时，被用户不小心修改的情况</li>
<li>在并发场景下，因为String的不可写（写了之后变成新对象，没有意义），所以是线程安全的</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>String的各种方法都避免对原数组进行修改，这才是String不可变性的主要实现方式</p>
<p>String类用final关键字修饰</p>
<ul>
<li>防止子类继承，去破坏它的不可变性</li>
<li>String类本身已经很完美了，无需其他类继承它</li>
</ul>
<h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><p>当需要修改字符串内容时，我们一般采用<code>StringBuffer</code>类</p>
<p>既然如此，就来看下StringBuffer的实现吧</p>
<h2 id="StringBuffer结构"><a href="#StringBuffer结构" class="headerlink" title="StringBuffer结构"></a>StringBuffer结构</h2><p><strong>类结构如下</strong></p>
<p><img data-src="/images/sb_1.PNG"></p>
<p>可以看到，StringBuffer类中有一个字符数组<code>toStringCache</code>，注释表明</p>
<blockquote>
<p>该数组存放的是由最近一次toString()方法返回的值</p>
<p>并且当StringBuffer发生变化时，它会被清空</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">   <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span> </span>&#123; </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment">     * whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="append-String"><a href="#append-String" class="headerlink" title="append(String)"></a>append(String)</h2><p><strong>再来看看常用的append方法</strong></p>
<p><strong>正如上面所说，在StringBuffer添加字符串时，会把toStringCache清空。</strong>清空的原因在看到toString()时再讲</p>
<p>而且它调用了父类的append方法进行添加字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是<code>AbstractStringBuilder</code>这个抽象类提供的append方法</p>
<p>主要逻辑如下：</p>
<ul>
<li>判断传入的String是否为空<ul>
<li>为空，调用<code>appendNull()</code></li>
<li>非空，确保数组容量</li>
<li>再把字符串添加到字符数组中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>

<p>上面主要用到了三个方法<code>appendNull()</code>、<code>ensureCapacityInternal()</code>和<code>getChars()</code></p>
<p>下面依次分析</p>
<h2 id="ensureCapacityInternal-int"><a href="#ensureCapacityInternal-int" class="headerlink" title="ensureCapacityInternal(int)"></a>ensureCapacityInternal(int)</h2><p>为什么要先分析这个方法呢，因为appendNull()里面也用到了。。</p>
<p>如果我们之前看过<code>ArrayList</code>相关的源码，对这类方法应该不陌生了吧</p>
<ul>
<li>方法形参为<strong>minimumCapacity</strong><ul>
<li>从上面append中，可以发现实参是$count+len$</li>
<li>即插入<code>str</code>后的数组长度，暂时把它叫做<strong>最小容量</strong>吧</li>
</ul>
</li>
<li>方法内部就是把最小容量与数组当前的长度进行比较<ul>
<li>如果$minimumCapacity &gt; value.length$</li>
<li>则要进行扩容，调用Arrays.copyOf()，这个方法可太熟了，就不再赘述</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不会以为到这儿就结束了吧，我们还有一点没讲，就是扩容的大小选择</p>
<p>那就来看看**newCapacity(int)**方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回顾下参数：</span></span><br><span class="line"><span class="comment">// minCapacity: 插入元素后的数组长度，即最小容量</span></span><br><span class="line"><span class="comment">// newCapacity: 原数组长度 * 2 + 2，即新容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 如果新容量小于最小容量，就把新容量设置成最小容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过上述判断后的新容量</span></span><br><span class="line">    <span class="comment">// 如果小于0（整型溢出） 或 大于最大数组容量（定义的Integer.MAX_VALUE - 8）</span></span><br><span class="line">    <span class="comment">// 就让新容量为最大数组容量</span></span><br><span class="line">    <span class="comment">// 否则就不变，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? minCapacity : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="appendNull"><a href="#appendNull" class="headerlink" title="appendNull()"></a>appendNull()</h2><p>如果append(String)传入null，就会进入这个方法</p>
<p>方法内只做了两件事</p>
<ol>
<li>判断要不要扩容</li>
<li>在数组中添加“null”字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractStringBuilder <span class="title">appendNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = count;</span><br><span class="line">    ensureCapacityInternal(c + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">    value[c++] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">    value[c++] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">    value[c++] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    value[c++] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    count = c;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getChars"><a href="#getChars" class="headerlink" title="getChars()"></a>getChars()</h2><p>该方法是由<strong>String类</strong>提供的</p>
<p>忽略那些判断，主要是调用<strong>System.arraycopy()把调用方法的String对象的部分字符拷贝到目的数组中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>分析完StringBuffer的append()后，我们再来看下它如何返回得到字符串</p>
<p>主要是把<code>Arrays.copyOfRange</code>返回的字符数组，赋值给toStringCache</p>
<p>然后再通过String类构造器创建一个String对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>copyOfRange()</strong></p>
<p>我们发现内部是创建了新数组来存放元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] copyOfRange(<span class="keyword">char</span>[] original, <span class="keyword">int</span> from, <span class="keyword">int</span> to) &#123;</span><br><span class="line">    <span class="keyword">int</span> newLength = to - from;</span><br><span class="line">    <span class="keyword">if</span> (newLength &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(from + <span class="string">&quot; &gt; &quot;</span> + to);</span><br><span class="line">    <span class="keyword">char</span>[] copy = <span class="keyword">new</span> <span class="keyword">char</span>[newLength];</span><br><span class="line">    System.arraycopy(original, from, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length - from, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们解释下append方法中为什么要把toStringCache设置为null</p>
<blockquote>
<p>1.当StringBuffer对象发生变化时，通过调用toString会得到一个新的toStringCache，保证了旧的一个不会再发生变化</p>
<p>2.当StringBuffer对象没有发生变化时，多次调用toString不会产生重复的字符串</p>
</blockquote>
]]></content>
      <categories>
        <category>基础</category>
      </categories>
  </entry>
  <entry>
    <title>代码总结</title>
    <url>/2021/12/13/Go/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>记录完成需求时，需要注意的一些编码习惯</p>
<h3 id="1-使用cast包进行类型转换"><a href="#1-使用cast包进行类型转换" class="headerlink" title="1.使用cast包进行类型转换"></a>1.使用cast包进行类型转换</h3><p>涉及<code>string</code>转<code>uint64</code>或其他类型时，多用<code>cast.ToUint64</code>、<code>cast.ToString</code>等函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;github.com/spf13/cast&quot;</span></span><br><span class="line">feedIDSet.Add(cast.ToUint64(v.ContentID))</span><br></pre></td></tr></table></figure>

<p>用cast包时遇到一个问题</p>
<p><strong>描述：</strong></p>
<blockquote>
<p>类型OrderPostStatus等价于类型int32。</p>
<p>现在拿到一个OrderPostStatus类型的变量，想要转换成int32，于是我很自然地就想到用cast.ToInt32()，之后发现这个值一直是0，没有转换成功</p>
</blockquote>
<p><strong>分析：</strong></p>
<p>查看ToInt32()的代码，发现它是先用类型断言来判断类型，然后再根据判断得到的类型，进行值的转换。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">switch</span> s := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">int32</span>(s), <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">int64</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">int32</span>(s), <span class="literal">nil</span></span><br><span class="line">	<span class="comment">// 此处省略一堆类型...</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;unable to cast %#v of type %T to int32&quot;</span>, i, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这些类型断言都只是判断了基本的类型，对于自定义的类型，它会走到default代码块里返回0</p>
<p><strong>解决：</strong></p>
<p>直接用<code>int32(value)</code>进行强转</p>
<h3 id="2-使用WaitGroup"><a href="#2-使用WaitGroup" class="headerlink" title="2.使用WaitGroup"></a>2.使用WaitGroup</h3><p><code>ao</code>层涉及到对举报信息进行组装，需要调用3个微服务分别来获取<code>用户名</code>、<code>动态内容图片</code>和<code>评论内容</code>。</p>
<p>原先的写法是都写在主线程中，这样耗时比较大；正确的做法应该是<code>开启3个协程</code>去调用三个微服务</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	s.getReportUserID(ctx, reports)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	s.getFeedDetail(ctx, reports)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	s.getCommentDetail(ctx, reports)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>



<h3 id="3-使用set"><a href="#3-使用set" class="headerlink" title="3.使用set"></a>3.使用set</h3><p>golang没有提供set集合，在添加id到集合中时，可以使用自建的<code>set.NewUint64Set()</code>来获取set，以进行去重。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;git.code.oa.com/demeter/groupshop/group-shop-comm/set&quot;</span></span><br><span class="line">reportUserIDSet := set.NewUint64Set()</span><br></pre></td></tr></table></figure>



<h3 id="4-pb文件"><a href="#4-pb文件" class="headerlink" title="4.pb文件"></a>4.pb文件</h3><p>对于协议中定义的枚举类型。pb文件中会提供map方便进行转换，就不用自己去做实现了</p>
<p>例如<code>product_post.proto</code>文件中定义如下枚举</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OrderPostStatus</span> </span>&#123;</span><br><span class="line">    PostOrderNotExist = <span class="number">0</span>; <span class="comment">//未进入待评价状态</span></span><br><span class="line">    PostOrderWaitPublish = <span class="number">1</span>; <span class="comment">//待评价</span></span><br><span class="line">    PostOrderPublished = <span class="number">2</span>; <span class="comment">//已评价</span></span><br><span class="line">    PostOrderClosed = <span class="number">3</span>; <span class="comment">//订单已完成，不予评价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的<code>product_post.pb.go</code>文件会带有map</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum value maps for OrderPostStatus.</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	OrderPostStatus_name = <span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="number">0</span>: <span class="string">&quot;PostOrderNotExist&quot;</span>,</span><br><span class="line">		<span class="number">1</span>: <span class="string">&quot;PostOrderWaitPublish&quot;</span>,</span><br><span class="line">		<span class="number">2</span>: <span class="string">&quot;PostOrderPublished&quot;</span>,</span><br><span class="line">		<span class="number">3</span>: <span class="string">&quot;PostOrderClosed&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	OrderPostStatus_value = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int32</span>&#123;</span><br><span class="line">		<span class="string">&quot;PostOrderNotExist&quot;</span>:    <span class="number">0</span>,</span><br><span class="line">		<span class="string">&quot;PostOrderWaitPublish&quot;</span>: <span class="number">1</span>,</span><br><span class="line">		<span class="string">&quot;PostOrderPublished&quot;</span>:   <span class="number">2</span>,</span><br><span class="line">		<span class="string">&quot;PostOrderClosed&quot;</span>:      <span class="number">3</span>,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>补充：更方便的是直接强转，不要用cast包（参照第一点中的问题）</p>
<h3 id="5-输出日志"><a href="#5-输出日志" class="headerlink" title="5.输出日志"></a>5.输出日志</h3><p>调试时多打一些日志来看数据，方便定位问题</p>
<h3 id="6-优化代码逻辑"><a href="#6-优化代码逻辑" class="headerlink" title="6.优化代码逻辑"></a>6.优化代码逻辑</h3><p>遇到复杂的需求，一开始单纯为了完成需求，写完后发现for循环内写了一堆逻辑，就要多想想怎么优化它。</p>
<h3 id="7-格式化输出记录"><a href="#7-格式化输出记录" class="headerlink" title="7.格式化输出记录"></a>7.格式化输出记录</h3><ol>
<li><p><strong>通用的占位符</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">%v    <span class="comment">//根据值的类型，输出它该有的样子</span></span><br><span class="line">%+v   <span class="comment">//带上包和结构体名</span></span><br><span class="line">%#v   <span class="comment">//输出时带上结构体的每个字段名</span></span><br><span class="line">%T    <span class="comment">//输出类型</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>常用类型</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">%b    <span class="comment">//布尔</span></span><br><span class="line">%d    <span class="comment">//整数</span></span><br><span class="line">%s    <span class="comment">//字符串</span></span><br><span class="line">%p    <span class="comment">//指针</span></span><br><span class="line">%q    <span class="comment">//带双引号的字符串，自动转义</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="8-初始化二维数组"><a href="#8-初始化二维数组" class="headerlink" title="8.初始化二维数组"></a>8.初始化二维数组</h3><p>在家刷leetcode时遇到题目需要一个二维切片<code>visited</code>来表示是否访问过当前位置。</p>
<p><strong>错误做法</strong></p>
<p>因为之前创建一维切片用的是make函数，所以我以为创建二维切片只要在函数里多传一个参数就可以了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 想创建一个3行5列的二维数组</span></span><br><span class="line">visited := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>上面创建的<code>visited</code>，确实是3行，但是每行的长度都为0，说明第二个长度参数<code>5</code>并没有生效</p>
<p>于是我去仔细地看了下make函数的注释说明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	Slice: The size specifies the length. The capacity of the slice is</span></span><br><span class="line"><span class="comment">//	equal to its length. A second integer argument may be provided to</span></span><br><span class="line"><span class="comment">//	specify a different capacity; it must be no smaller than the</span></span><br><span class="line"><span class="comment">//	length. For example, make([]int, 0, 10) allocates an underlying array</span></span><br><span class="line"><span class="comment">//	of size 10 and returns a slice of length 0 and capacity 10 that is</span></span><br><span class="line"><span class="comment">//	backed by this underlying array.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>

<p>这才发现：</p>
<ul>
<li>传入一个<code>size</code>时，它就表示切片的长度和容量，即两者相等</li>
<li>传入两个<code>size</code>时，第一个参数表示长度，第二个参数表示切片容量（容量不小于长度）</li>
</ul>
<p>所以刚才make函数创建的实际上是一个长度3，容量5的二维切片，但是每个一维切片是空的，如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[[] [] []]</span><br></pre></td></tr></table></figure>



<p><strong>正确做法</strong></p>
<p>从上面可以看出，创建的每个一维切片还是空的，所以需要对每个一维切片做一次初始化操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">visited := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> visited &#123;</span><br><span class="line">    visited[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-遍历map"><a href="#9-遍历map" class="headerlink" title="9.遍历map"></a>9.遍历map</h3><p><strong>问题描述：</strong></p>
<p>在返回的已买商品列表中，相同的商品带有相同的订单号，我们期待的是不同的订单号。</p>
<p>因为在实现中订单和商品是一对一的关系，所以就算是购买相同商品，每次购买的订单号一定是不同的。</p>
<p><strong>问题定位：</strong></p>
<p>遍历订单时，把从map中得到的<code>商品信息</code>重复添加到切片中</p>
<p>然后切片中两个元素的指针是相同的，导致修改一个的订单号，就会修改其他相同指针的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, order := <span class="keyword">range</span> orders &#123;</span><br><span class="line">	<span class="keyword">if</span> spuInfo, ok := spuIDMap[order.SpuId]; ok &#123;</span><br><span class="line">		spuInfo.OrderID = cast.ToString(order.OrderId)</span><br><span class="line">		spuInfosRsp = <span class="built_in">append</span>(spuInfosRsp, spuInfo)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>正确做法：</strong></p>
<p>得到商品信息<code>spuInfo</code>后，深拷贝一份新的，这样它们的地址就不相同，修改一个也不会影响到其他。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, order := <span class="keyword">range</span> orders &#123;</span><br><span class="line">	<span class="keyword">if</span> spuInfo, ok := spuIDMap[order.SpuId]; ok &#123;</span><br><span class="line">		newSpu := deepCopy(spuInfo)</span><br><span class="line">		newSpu.OrderID = cast.ToString(order.OrderId)</span><br><span class="line">		spuInfosRsp = <span class="built_in">append</span>(spuInfosRsp, newSpu)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-使用多个逻辑运算符时注意优先级！！！"><a href="#10-使用多个逻辑运算符时注意优先级！！！" class="headerlink" title="10.使用多个逻辑运算符时注意优先级！！！"></a>10.使用多个逻辑运算符时注意优先级！！！</h3><p>如在下面这段代码中，第三个判断想表达的意思是：</p>
<p>当查询类型为<code>订单支付数</code>或<code>订单成交额</code>，且数组指定位置元素的订单<code>指标为空</code>时，对它进行赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> topResults[<span class="number">0</span>][i] == <span class="literal">nil</span> &#123;</span><br><span class="line">	topResults[<span class="number">0</span>][i] = indicator</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> queryType == cgi.TopIndicateType_UserPayCnt &amp;&amp; topResults[<span class="number">0</span>][i].UserIndicator == <span class="literal">nil</span> &#123;</span><br><span class="line">	topResults[<span class="number">0</span>][i].UserIndicator = userIndicator</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> queryType == cgi.TopIndicateType_OrderPayCnt || queryType == cgi.TopIndicateType_Turnover &amp;&amp;</span><br><span class="line">	topResults[<span class="number">0</span>][i].OrderIndicator == <span class="literal">nil</span> &#123;</span><br><span class="line">	topResults[<span class="number">0</span>][i].OrderIndicator = orderIndicator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是因为<code>与运算</code>优先级更高，所以得不到想要的逻辑，应该在<code>或运算</code>时加上括号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (queryType == cgi.TopIndicateType_OrderPayCnt || queryType == cgi.TopIndicateType_Turnover) &amp;&amp;</span><br><span class="line">			topResults[<span class="number">0</span>][i].OrderIndicator == <span class="literal">nil</span> &#123;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/12/13/Go/gee/</url>
    <content><![CDATA[<h3 id="一、基本封装"><a href="#一、基本封装" class="headerlink" title="一、基本封装"></a>一、基本封装</h3><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>封装路由结构，可以由路径获取到对应的handler，进行请求处理</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><p>定义<code>Engine</code>结构体，嵌入路由表</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	*router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Handler接口的<code>ServeHttp</code>方法，这是所有请求的入口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP 处理不同路由的请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Engine)</span> <span class="title">ServeHTTP</span><span class="params">(write http.ResponseWriter, req *http.Request)</span></span>  &#123;</span><br><span class="line">	key := combineToRouteKey(req.Method, req.URL.Path)</span><br><span class="line">	<span class="keyword">if</span> handler, ok := e.route[key]; ok &#123;</span><br><span class="line">		handler(write, req)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		write.WriteHeader(http.StatusNotFound)</span><br><span class="line">		fmt.Fprintf(write, <span class="string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完善其他方法，用于启动服务、添加路由等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Engine)</span> <span class="title">Run</span><span class="params">(addr <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(addr, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span> *<span class="title">Engine</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Engine&#123;</span><br><span class="line">		newRouter(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Engine)</span> <span class="title">GET</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span>  &#123;</span><br><span class="line">	e.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Engine)</span> <span class="title">POST</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc)</span></span>  &#123;</span><br><span class="line">	e.addRoute(<span class="string">&quot;GET&quot;</span>, pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>定义<code>Context</code>结构体，封装请求信息。这样每次处理请求时，只需传递一个Context参数即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// base objects</span></span><br><span class="line">	Writer http.ResponseWriter</span><br><span class="line">	Req    *http.Request</span><br><span class="line"></span><br><span class="line">	<span class="comment">// request info</span></span><br><span class="line">	Path       <span class="keyword">string</span></span><br><span class="line">	Method     <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// response info</span></span><br><span class="line">	StatusCode <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后为Context添加一些封装好的方法，方便用户调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">String</span><span class="params">(code <span class="keyword">int</span>, format <span class="keyword">string</span>, values ...<span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">JSON</span><span class="params">(code <span class="keyword">int</span>, obj <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、动态路由"><a href="#二、动态路由" class="headerlink" title="二、动态路由"></a>二、动态路由</h3><p>静态路由用map来维护所有路由与处理方法的映射，这样不方便对路由进行管理，同时又不支持路由中携带参数</p>
<p>因此提出了动态路由的设计：利用一颗前缀路由树来存储路由</p>
<p>首先，定义<code>Node</code>节点</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	pattern      <span class="keyword">string</span>  <span class="comment">// 路径，除叶子节点外其他节点的pattern均为空</span></span><br><span class="line">	curPart      <span class="keyword">string</span>  <span class="comment">// 路径的一部分，用来表示当前匹配的值</span></span><br><span class="line">	children     []*Node <span class="comment">// 子节点</span></span><br><span class="line">	isFuzzyMatch <span class="keyword">bool</span>    <span class="comment">// 当前匹配的部分是否采用模糊匹配(即动态路由)的方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现节点的插入、查找</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert 从根节点到叶子，构造出一条路径</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">insert</span><span class="params">(pattern <span class="keyword">string</span>, parts []<span class="keyword">string</span>, height <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 设置叶子节点的pattern，用于查询时确认是否匹配</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(parts) == height &#123;</span><br><span class="line">      n.pattern = pattern</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   part := parts[height]</span><br><span class="line">   child := n.matchChild(part)</span><br><span class="line">   <span class="keyword">if</span> child == <span class="literal">nil</span> &#123; <span class="comment">// 如果不存在，则插入一个子节点</span></span><br><span class="line">      child = &amp;Node&#123;</span><br><span class="line">         curPart:      part,</span><br><span class="line">         isFuzzyMatch: part[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> || part[<span class="number">0</span>] == <span class="string">&#x27;:&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">      n.children = <span class="built_in">append</span>(n.children, child)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 向下递归</span></span><br><span class="line">   child.insert(pattern, parts, height+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search DFS遍历路由树，查找匹配到的最终节点。如果没有节点匹配，则返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">search</span><span class="params">(parts []<span class="keyword">string</span>, height <span class="keyword">int</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">	<span class="comment">// 递归终止条件：来到叶子节点或遇到*号</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(parts) == height || strings.HasPrefix(n.curPart, <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> n.pattern == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	part := parts[height]</span><br><span class="line">	children := n.matchChildren(part)</span><br><span class="line">	<span class="keyword">for</span> _, child := <span class="keyword">range</span> children &#123;</span><br><span class="line">		result := child.search(parts, height+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> result != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> result</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后修改<code>router</code>结构体，添加路由树</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> router <span class="keyword">struct</span> &#123;</span><br><span class="line">	roots <span class="keyword">map</span>[<span class="keyword">string</span>]*Node <span class="comment">// http请求方法与前缀路由树的映射；例如 GET -&gt; a tree，POST -&gt; another tree</span></span><br><span class="line"></span><br><span class="line">	handlers <span class="keyword">map</span>[<span class="keyword">string</span>]HandlerFunc <span class="comment">// 请求路径与处理方法的映射，key由方法与路径拼接而成；例如 GET-/user/login -&gt; Login method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、分组管理"><a href="#三、分组管理" class="headerlink" title="三、分组管理"></a>三、分组管理</h3><p>当多个路由拥有相同的前缀时，我们可以把他们看成一组路由，而一组路由往往有相同的功能</p>
<p>例如路由组<code>&quot;/test&quot;</code>下的所有路由都需要进行接口耗时的计算，那么就可以对该路由组添加对应的中间件。中间件将在下一节介绍。</p>
<p>定义<code>RouterGroup</code>结构，并嵌入到<code>Engine</code>中。这样原先<code>Engine</code>的一些方法都可以放在路由组中实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RouterGroup 路由组，方便对一组路由进行管理和配置。所有路由组拥有一个共同的 Engine</span></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	handler []HandlerFunc <span class="comment">//</span></span><br><span class="line">	parent  *RouterGroup  <span class="comment">// 父路由组</span></span><br><span class="line">	baseURL <span class="keyword">string</span>        <span class="comment">// 本组路由的 path</span></span><br><span class="line">	engine  *Engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">	*RouterGroup                <span class="comment">// 根路由组</span></span><br><span class="line">	router       *router        <span class="comment">// 路由表</span></span><br><span class="line">	groups       []*RouterGroup <span class="comment">// 持有所有路由组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明路由组的方法，以及ServeHTTP逻辑的改动，这里就不再介绍。</p>
<h3 id="四、中间件"><a href="#四、中间件" class="headerlink" title="四、中间件"></a>四、中间件</h3><p><code>Context</code>维护handlers切片，这个切片在两种情况下会添加元素：</p>
<ol>
<li>添加中间件</li>
<li>添加路由的处理方法</li>
</ol>
<p>一般都是先添加中间件，再添加路由，这样当请求到来时，就可以先处理中间件，然后再调用路由handler，最后再从后往前返回</p>
<p>上面的过程，涉及到的主要函数如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Next</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c.index++</span><br><span class="line"></span><br><span class="line">	length := <span class="built_in">len</span>(c.handlers)</span><br><span class="line">	<span class="keyword">for</span> ; c.index &lt; length; c.index++ &#123;</span><br><span class="line">		c.handlers[c.index](c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
