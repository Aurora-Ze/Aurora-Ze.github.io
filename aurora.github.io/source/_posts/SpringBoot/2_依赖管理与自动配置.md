---
title: 入门——自动装配
categories: SpringBoot
---

# 一、依赖管理

## 关于父工程的依赖

当我们创建了Spring Boot项目后，我们会发现`pom.xml`文件中，默认有个父工程

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.3.RELEASE</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>
```

进入之后发现他还有个父工程

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.3.3.RELEASE</version>
</parent>
```

最后我们来到了名为**spring-boot-dependencies**的工程

发现他里面添加了开发中常用依赖的版本，配置在**properties**标签中

```xml
<properties>
  <activemq.version>5.15.13</activemq.version>
  <antlr2.version>2.7.7</antlr2.version>
  <appengine-sdk.version>1.9.81</appengine-sdk.version>
  <artemis.version>2.12.0</artemis.version>
  <aspectj.version>1.9.6</aspectj.version>
  <assertj.version>3.16.1</assertj.version>
  <atomikos.version>4.0.6</atomikos.version>
  <awaitility.version>4.0.3</awaitility.version>
  <-! ......省略->
  <webjars-locator-core.version>0.45</webjars-locator-core.version>
    <wsdl4j.version>1.6.3</wsdl4j.version>
    <xml-maven-plugin.version>1.0.2</xml-maven-plugin.version>
    <xmlunit2.version>2.7.0</xmlunit2.version>
</properties>
```

**而如果我们想要自己来选择版本的话，就可以在pom.xml中的properties标签中添加对应依赖的版本**

## starter场景启动器

关于`spring-boot-starter-web`的依赖如下：

```xml
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

**我们进入它（或者是其他starter）的内部，发现所有类似的starter都有这样一段依赖**

```xml
<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
      <version>2.3.3.RELEASE</version>
      <scope>compile</scope>
</dependency>
```

这说明了只要引用了`spring-boot-starter-xxx`，就会自动引入该场景（例子中是web）的所有常规依赖

# 二、自动配置

**Spring Boot的自动配置如下**

1. 配置Tomcat
2. 配置SpringMVC
3. 配置Web常用功能，如字符编码等
4. 默认包结构

**主启动类路径下的文件都会被扫描到**

**如果想要改变扫描路径，可以通过**

- @SpringBootApplication(scanBasePackages="com.edu.neu")

- 或者@ComponentScan(“com.edu.neu”)

特点：按需加载配置项

# 三、组件注册

## 1.Spring

spring是采用在xml配置文件中写标签的方式来注册组件，~~但不知为啥没注册成功。。~~原来还要@ImportResource才行

```xml
<bean id="cola" class="com.edu.neu.learning.entity.Cola">
    <property name="price" value="123"></property>
</bean>
```

## 2.SpringBoot @Configuration

spring boot可以不用再通过`xml`文件来注册组件了，而是使用`@Configuration`注解，来表示这是**配置类**

然后在**配置类**中通过`@Bean`的方式把组件注册到容器中。

```java
@Configuration
public class ColaConfig {

    @Bean
    public Cola myCola(){
        return new Cola();
    }
}
```

**我们进入到@Configuration注解中，可以发现它定义了一个布尔型的变量，默认是true**

```java 
boolean proxyBeanMethods() default true;
```

**proxyBeanMethods直译过来就是是否要代理组件方法**，那么我们可以理解成

- true，由容器来代理组件方法
- false，容器不进行代理

**那这有什么用呢？**就写一段代码试试看吧

```Java
		ColaConfig bean = run.getBean(ColaConfig.class); // 得到配置类的实例对象
		// 通过配置类的方法来获取Cola对象
        Cola cola1 = bean.myCola();
        Cola cola2 = bean.myCola();
		// 如果是代理，则    cola1 == cola2
		// 如果不采用代理，则 cola1 != cola2
```

**这说明当配置类采取代理组件方法时，它会先从容器中获得对象。容器没有的话，再调用真正的方法去创建对象并注册到容器中。**

之后如果还想要获取对象，就会直接返回容器中存在的对象，不用重复创建。

**这样看来代理是不是还挺好的，但是存在一个问题，如果每次都要从容器中寻找对象，就会造成不必要的开销，特别是本来就不用组件依赖的时候，直接创建对象也可以用，就不用再去容器中寻找，所以选择不代理的情况也是存在的**

**所以基于他们耗时、开销的多少，我们常常把采用代理称为Full模式，不用代理形容成Light（轻量级）模式**

总结一下，如下

- 配置类的组件之间无依赖关系，就用轻量级模式加速容器的启动过程，减少判断
- 配置类的组件之间存在依赖，就要用Full模式，让被调用方法返回之前存在的容器

## 3.@Import

### **描述**

用来在容器中注册全类名的组件

### **用法**

```Java
@Import({Person.class, DBHelper.class})
@Configuration(proxyBeanMethods = false)
public class ColaConfig {
}
```

## 4.@Conditional

### **描述**

表示在条件满足时再注册组件

它有很多子类，例如ConditionalOnBean、ConditionalOnProperty、ConditionalOnMissingBean等

### **用法**

如下，当容器中存在myPerson组件时，myCola组件才会注册到容器中

**注意，这两个方法的先后顺序是有影响的！下面这样子的结果是myCola被注册到容器了，如果这俩方法换个顺序，myCola就不会被注册进容器！**

```Java
    @Bean
    public Person myPerson() {
        return new Person();
    }

    @Bean
    @ConditionalOnBean(name = "myPerson")
    public Cola myCola(){
        return new Cola();
    }
```

另外，如果@Conditional注解加在类上，那么会决定整个类中的组件是否会被注册进容器。

## 5.@ImportResource

用来注册`xml`文件中配置的组件

例如，下面的`beans.xml`是上文提到的，在这里引入后，就能注册在容器中

```Java
@Configuration(proxyBeanMethods = true)
@ImportResource("classpath:beans.xml")
public class ColaConfig {
    //...
```

## 6.@ConfigurationProperties

通过`application.properties`文件来配置组件的一些信息

**注意，组件类必须在容器中才能进行属性绑定**

**所以要么在组件类中添加@Component注册它，要么就用配置类去注册它。**

**然后在组件类上方添加@ConfigurationProperties，完成属性绑定**

```java
@ConfigurationProperties(prefix = "person")
@Component
public class Person {
 // ...		
```

在`application.properties`中设置组件类的属性

```properties
person.id=123
person.name=whz
```

## 7.@EnableConfigurationProperties

和⑥相比，把该注解用在注册组件的配置类中，组件类就不用再使用@Component注解了

**这是防止引用第三方的包时，其组件类没有@Component而产生无法进行属性绑定的问题**

```java
@Configuration(proxyBeanMethods = true)
@EnableConfigurationProperties(Person.class)
public class ColaConfig { // ... }

@ConfigurationProperties(prefix = "person")
public class Person { // ... }
    
```

# 四、按需进行自动配置

上面我们提到了许多用来注册组件的注解

那么SpringBoot究竟是怎么把这些东西注册进容器的呢，SpringBoot程序的运行离不开主启动类，这个启动类也许包含了更多的信息。

让我们来研究下主启动类的注解吧。

首先，`@SpringBootApplication`内部涉及三个注解，如下

```java
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
```

- SpringBootConfiguration
  - 内部就是Configuration
  - 说明主启动类也注册到容器中
- ComponentScan
  - 用于包扫描
  - 更多信息可上网查找
- EnableAutoConfiguration
  - 其中有两个注解比较重要，分别是用来自动配置组件和批量导入组件
  - @AutoConfigurationPackage
  - @Import({ AutoConfigurationImportSelector.class })

## **Registrar**

类中的注册组件方法如下：

通过`metadate`得到`packageNames`，然后对一群组件进行注册

```Java
public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
    AutoConfigurationPackages.register(registry, (String[])(new AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0]));
}
```

## **AutoConfigurationImportSelector**

可以看到，该类中使用`getAutoConfigurationEntry()`来返回批量的组件信息

方法内部又调用了`getCandidateConfigurations()`，而这个方法是通过`SpringFactoriesLoader`来获得配置

```java
protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
    	// 1.判断SpringBoot的自动装配是否打开
        if (!this.isEnabled(annotationMetadata)) {
            return EMPTY_ENTRY;
        } else {
            // 2.读取EnableAutoConfiguration注解中的exclude和excludeName
            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
            // 3.读取所有需要自动装配的配置类，在META-INF/spring.factories中
            List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
            // 4.删去不满足条件的
            configurations = this.removeDuplicates(configurations);		                
            Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
            this.checkExcludedClasses(configurations, exclusions);
            configurations.removeAll(exclusions);
            configurations = this.getConfigurationClassFilter().filter(configurations);
            this.fireAutoConfigurationImportEvents(configurations, exclusions);
            return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);
        }
}

// 调用Spring的工厂加载器来获取配置
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
        List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
        Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");
        return configurations;
}
```

**我们来到SpringFactoriesLoader类中，可以看到它的核心方法loadSpringFactories()**

分析一下该方法

1. 判断cache是否是null
2. 如果cache存在，就直接返回，因为配置项已经加载过
3. 如果不存在，就从`META-INF/spring.factories`文件中**读取并加载所有的配置**

```java
private static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {
    MultiValueMap<String, String> result = (MultiValueMap)cache.get(classLoader);
    if (result != null) {
        return result;
    } else {
        try {
            Enumeration<URL> urls = classLoader != null ? classLoader.getResources("META-INF/spring.factories") : ClassLoader.getSystemResources("META-INF/spring.factories");
            LinkedMultiValueMap result = new LinkedMultiValueMap();

            while(urls.hasMoreElements()) {
                URL url = (URL)urls.nextElement();
                UrlResource resource = new UrlResource(url);
                Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                Iterator var6 = properties.entrySet().iterator();

                while(var6.hasNext()) {
                    Entry<?, ?> entry = (Entry)var6.next();
                    String factoryTypeName = ((String)entry.getKey()).trim();
                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());
                    int var10 = var9.length;

                    for(int var11 = 0; var11 < var10; ++var11) {
                        String factoryImplementationName = var9[var11];
                        result.add(factoryTypeName, factoryImplementationName.trim());
                    }
                }
            }

            cache.put(classLoader, result);
            return result;
        } catch (IOException var13) {
            throw new IllegalArgumentException("Unable to load factories from location [META-INF/spring.factories]", var13);
        }
    }
```

但我们可能会有疑问，如果一次性把所有组件都注册进容器中，会不会多余？并且影响启动的性能

这时候我们就要用到前面提过的**条件注解**了

**只要我们在组件类中添加相应的条件配置，如`@ConditionalOnClass`，这样只有引入某个包时，对应的组件才会真正被注册到容器中。**

## 定制化配置

如果我们对SpringBoot的默认配置不满意呢，该怎样做到修改它的默认配置

以下提供了两种方法

1. 注册自己的Bean，取代默认组件
2. 通过配置文件`application.properties`来设置

## 定制化配置的实现方式

我们查看Spring Boot默认加载的组件，会发现以下注解

就以`HttpEncodingAutoConfiguration`为例

```java
@EnableConfigurationProperties({ServerProperties.class})
```

这个注解我们之前了解过

即：该组件把`ServerProperties`类注册到容器中，同时读取`application.properties`中对应的属性来赋值。

所以我们只要直接修改配置文件，就能够使用自己的配置

## 查看自动配置

在`application.properties`中设置`debug=true`来开启调试

这样运行项目后会打印出配置项(`positive matches `或`negative matches`)

