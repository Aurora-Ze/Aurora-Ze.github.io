---
title: JVM内存结构
categories: JVM
cover: https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg
top_img: https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg
---

# JVM——内存结构

JVM把它内部分成了好几块内存区域，每个区域存放不同的*东西*（~~emmm，想不出叫啥，就姑且叫做东西吧~~）

总体的结构如下：

可以看到，运行时数据区主要分为两类，一类是**线程私有**的，另一类是**线程共享**的

下面我们也会按类别来进行介绍。

<img src="https://gitee.com/aurora1004/pictures/raw/master/jvm_str.jpg" alt="jvm_str" style="zoom: 67%;" />

***
## 一、线程私有

### 程序计数器

是当前线程所执行的字节码的**行号指示器**

看了书之后，介绍下它的作用
>因为Java是多线程的，它的多线程是通过线程轮流切换、分配处理器执行时间来实现的。
那么每次切换完线程后，如果想回到之前的一个线程，就需要一个行号指示器，指向上个线程所执行的地方。
所以程序计数器就实现了这个功能，另外，这也说明了程序计数器是每个线程私有的，只有这样才能满足线程之间的切换。

有两个注意点

1. 是唯一一个不会产生内存溢出的区域
2. 正在执行java方法的话，计数器记录的是当前指令的地址；如果是Native方法，则为null。

### 虚拟机栈

虚拟机栈和线程的生命周期相同

每个方法在执行的同时，会创建一个栈帧，用于存储**局部变量表、操作数栈、动态连接、方法出口**等信息


>其中局部变量表比较重要，里面存放了编译器可知的基本数据类型、对象引用和返回地址。
这些数据类型在表中是以变量槽（slot）的形式表示的，long和double占两个槽，其他都占一个槽。

方法从调用到执行完成，对应了栈帧在虚拟机栈中的入栈与出栈

注意，虚拟机栈会报StackOverflowError和OutOfMemoryError这两种***异常***

1. 前者是因为线程请求的栈的深度大于虚拟机所允许的深度
2. 后者是因为栈动态扩展的时候申请不到足够的内存

### 本地方法栈

为本地方法服务，在HotSpot中，本地方法栈和虚拟机栈**合二为一**了
***
## 二、线程共享

### 堆

>堆是JVM内存中最大的一块区域。笼统来说，堆唯一的目的就是存放对象**实例**，所以垃圾回收也主要在这里进行。

堆中可以划分出多个TLAB（线程私有的分配缓冲区），以提升对象分配时的效率。

当堆没有内存可供分配，且也无法请求更多的内存来扩展，就会报OutOfMemoryError异常

### 方法区

>方法区存储的是被JVM加载的**类型信息、常量、静态变量**、即时编译器编译后的代码缓存等数据。

方法区的实现很有意思

1. 在jdk8之前，它是用堆中永久代来实现的
2. jdk8及以后，采用元空间
3. 另外，在jdk7时，HotSpot就已经将原本放在方法区的**字符串常量池**和**静态变量**移到了堆中。

方法区也是要进行垃圾回收的，不过它回收目标主要是针对常量池的回收和对类型的卸载。

**运行时常量池**

如果看过之前那篇Class文件结构的博客，可能还记得Class文件中有一个叫做`常量池`的表

里面主要存放了`字面量`和`符号引用`（可以理解成一些类信息的字符串，如类名、方法名等）

这些是在**类加载后**存放到方法区的**运行时常量池**的

**特征**

`运行时常量池`和字节码文件中的常量池相比，有一个很大的特征，即`动态性`

因为常量并不是只在编译时产生，程序运行时也可能产生新的常量，这时候就会动态添加到常量池中。

***
## 三、直接内存

> 不是JVM运行时数据区的一部分，但也会频繁地调用

[![DmDHbQ.png](https://s3.ax1x.com/2020/11/18/DmDHbQ.png)](https://imgchr.com/i/DmDHbQ)
	