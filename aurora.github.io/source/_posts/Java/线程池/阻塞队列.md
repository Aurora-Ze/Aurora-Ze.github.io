---
title: (四).阻塞队列介绍
categories: 线程和线程池
---

### 一、回顾

从上一篇笔记中，我们了解了线程池对线程的复用机制，就让我们再好好回顾下吧。

>Executor中的线程在执行完自己的任务后，还会通过getTask()方法主动向阻塞队列获取任务
>
>对于核心线程来说，它是用take()来阻塞地获取任务
>
>而非核心线程是通过poll()来获取任务，如果超时，则放弃获取

正是这样的机制，才使得核心线程一直存在于线程池中，而非核心线程空闲到了存活时间就会被销毁。



### 二、架构分析

上面还涉及到了一个很重要的问题，就是从阻塞队列获取任务。

**那么阻塞队列是怎样设计的呢？就让我们来看看它的结构吧**

#### 1.BlockingQueue

可以看到，它继承了Queue接口，那肯定少不了队列的一些常规方法

但我们要看的是阻塞队列提供的一些其他方法，下面一一介绍

```java
public interface BlockingQueue<E> extends Queue<E> {
    //省略队列的一些常规方法，如add()、offer()等
    
    // 放入元素，会阻塞
    void put(E e) throws InterruptedException;
    // 放入元素，超时后放弃
    boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;
    
    // 获取元素,会阻塞
	E take() throws InterruptedException;   
    // 获取元素，超时后放弃
    E poll(long timeout, TimeUnit unit) throws InterruptedException;
    
    // 返回队列剩余大小 
    int remainingCapacity();
    // 删除队列中的所有元素，并移动到指定集合
    int drainTo(Collection<? super E> c);
}
```

| 方法  | 类型 |   策略   |
| :---: | :--: | :------: |
|  put  |  +   |   阻塞   |
| offer |  +   | 超时机制 |
| take  |  -   |   阻塞   |
| poll  |  -   | 超时机制 |

上面的**BlockingQueue**只是定义了接口，那么我们看看它是具体怎么实现的吧

从下图中我们发现有许多队列实现了**BlockingQueue**，下面我们挑几个讲讲

![](/images/blocking_queue_1.PNG)

---



#### 2.ArrayBlockingQueue

##### **构造方法**

```Java
public ArrayBlockingQueue(int capacity) {
    this(capacity, false);		// 默认创建的锁是非公平的
}

public ArrayBlockingQueue(int capacity, boolean fair) { // fair表示锁是否公平
    if (capacity <= 0)
        throw new IllegalArgumentException();
    this.items = new Object[capacity];
    lock = new ReentrantLock(fair);
    notEmpty = lock.newCondition();
    notFull =  lock.newCondition();
}

public ArrayBlockingQueue(int capacity, boolean fair,
                          Collection<? extends E> c) {
    this(capacity, fair);

    final ReentrantLock lock = this.lock;
    lock.lock();
    try {                 // 把给定集合中的元素添加到数组中
        int i = 0;
        try {
            for (E e : c) {
                checkNotNull(e);
                items[i++] = e;
            }
        } catch (ArrayIndexOutOfBoundsException ex) {
            throw new IllegalArgumentException();
        }
        count = i;
        putIndex = (i == capacity) ? 0 : i;
    } finally {
        lock.unlock();
    }
}
```

##### **成员变量**

```Java
// 用数组来存放元素
final Object[] items;

// 表示队列头部的下标，每次取元素时用。
// take, poll, peek or remove
int takeIndex;

// 表示插入新元素所在的下标
// put, offer, or add
int putIndex;

int count;


/** 使用经典的教科书式的 two-condition 算法 | 但我不会啊，我又没看过  */

final ReentrantLock lock;
// 取元素时的条件
private final Condition notEmpty;
// 放元素时的条件
private final Condition notFull;

// 当前迭代器的共享状态
transient Itrs itrs = null;
```

##### 添加元素

**首先，对外的添加元素方法有**

1. add(E) 
2. offer(E) 
3. put(E)
4. offer(E, long, TimeUnit)

**而这些方法内部实际都用调用enqueue(E)**

那么就先来看看enqueue方法，大致思路还是很简单的，如下：

> 在指定位置放入元素，然后**putIndex**加一
>
> 当**putIndex**等于数组长度时，令它为0，从头开始添加元素
>
> 最后唤醒一个在**notEmpty**的等待队列中的线程（删除元素的线程，因为阻塞队列为空，所以等在notEmpty的队列中）

```Java
private void enqueue(E x) {
    final Object[] items = this.items;
    items[putIndex] = x;
    if (++putIndex == items.length)
        putIndex = 0;
    count++;
    notEmpty.signal();
}
```

**接下来看看put(E)和offer(E, long, TimeUnit)**

put()的思路也很清晰：

1. 进行非空判断后，加锁
2. 然后判断队列是否满，如果满了就让当前线程进入notFull的等待队列中
3. 如果没有满，则添加元素
4. 解锁

和put()相比，offer()在循环体中加入了是否超时的判断

```java
public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == items.length)
            notFull.await(); 
        enqueue(e); 
    } finally {
        lock.unlock();
    }
}

public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException {
    checkNotNull(e);
    long nanos = unit.toNanos(timeout); // 根据超时的时间长度和单位，换算成纳秒级别
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == items.length) {
            if (nanos <= 0)             // 判断是否超时
                return false;
            nanos = notFull.awaitNanos(nanos);
        }
        enqueue(e);
        return true;
    } finally {
        lock.unlock();
    }
}
```

##### 删除元素

老规矩，先介绍下对外方法

1. peek()
2. remove(Object)
3. poll()
4. poll(long, TimeUnit)
5. take()

peek()返回**takeIndex**所在位置的元素，不作删除

remove(Object)从**takeIndex**开始向**putIndex**遍历，找到第一个匹配的元素，删除掉，然后更新元素位置

后面三个方法都用到了**dequeue()**





**那来看看这个方法**

```Java
private E dequeue() {
  
    final Object[] items = this.items;
    @SuppressWarnings("unchecked")
    E x = (E) items[takeIndex]; 
    items[takeIndex] = null;
    if (++takeIndex == items.length)
        takeIndex = 0;
    count--;
    if (itrs != null)
        itrs.elementDequeued();
    notFull.signal();
    return x;
}
```

**接下来看看poll(), take(), poll(long, TimeUnit)方法**

```Java
public E poll() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        return (count == 0) ? null : dequeue();
    } finally {
        lock.unlock();
    }
}
```

**如果阻塞队列为空，就把当前线程加入到notEmpty的等待队列中，等待唤醒**

```Java
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == 0)
            notEmpty.await();
        return dequeue();
    } finally {
        lock.unlock();
    }
}
```

**在take()的基础上添加了超时判断**

```Java
public E poll(long timeout, TimeUnit unit) throws InterruptedException {
    long nanos = unit.toNanos(timeout);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == 0) {
            if (nanos <= 0)
                return null;
            nanos = notEmpty.awaitNanos(nanos);
        }
        return dequeue();
    } finally {
        lock.unlock();
    }
}
```

---



#### 3.DelayQueue

##### 构造方法及属性

```Java
public DelayQueue() {}
public DelayQueue(Collection<? extends E> c) {
        this.addAll(c);
}
private Thread leader = null;
private final transient ReentrantLock lock = new ReentrantLock();
private final PriorityQueue<E> q = new PriorityQueue<E>();
```

可以发现，**DelayQueue**的一些特点

- 使用Java的**优先级队列**来存储元素
- 使用**Leader-Follower**模式处理任务



