---
title: 面试题记录
categories: 计算机网络
tags:
	- 面试
---

# 计网

#### 一、TCP三次握手的过程

###### 1.符号说明

- ACK：确认标志，请求连接时为0，连接建立后所有发送的报文的ACK必须为1
- SYN：同步序列号，只在三次握手建立连接时有效，值为1
- ISN ：初始序列号，由生成器生成一个32位的ISN，生成器用32位长的时钟，每隔一段时间增长一次，大约**5小时**会重新循环。而数据包的默认最大寿命**MSL**为**2分钟**，所以可以认为初始序列号是唯一的

###### 2.过程

假设客户端和服务器的初始序列号分别为X，Y

1. 客户端发送建立连接请求，`SYN = 1，seq = X`

2. 服务器收到请求并回复，`SYN = 1，ack = X + 1，seq= Y`
3. 客户端收到回复，并告诉服务器我收到了 `SYN = 0，ack = Y + 1，seq = X + 1，`

三次握手可以理解为

1. 客户端 - > 服务器  SYN，my ISN is X
2. 服务器 - > 客户端  ACK，your ISN is X
3. 服务器 - > 客户端  SYN，my ISN is Y
4. 客户端 - > 服务器  ACK，your ISN is Y

其中2，3 可以合并

#### 二、为什么要进行三次握手，而不用两次或四次？

目的是建立可靠的通信信道，同时避免资源浪费。

如果是采用两次握手的话，只保证了客户端的发送和接受，而服务器不知道它发出的报文是否被客户端接受到。

而三次握手则保证了服务器和客户端的发送接收都没有问题。

四次握手的话会浪费更多的网络资源

#### 三、第二次握手为什么要传回SYN？

第二次握手既传了ACK，又传了SYN。

传ACK是为了告诉发送方，我收到了你发送的信息，这表明客户端到服务器的通信是正常的。

而回传SYN则是为了建立并确认服务端到客户端的通信。

#### 四、四次挥手的过程

1. 客户端向服务器发起`FIN请求`
2. 服务器收到断开连接请求后，并没有立即关闭，而是先发送`ACK应答报文`，通知客户端，它已经收到请求
3. 服务器等待资源发送完毕，再发出`FIN报文`
4. 客户端收到服务器的FIN报文后，发出`ACK确认报文`给服务器，并开始计时，在**2MSL（max segment lifetime）**后关闭连接

#### 五、为什么连接的时候是三次握手，关闭的时候却是四次挥手？

因为在三次握手的时候，服务器接收到客户端的连接请求时，可以立即发出ACK应答报文并请求建立连接

而在四次挥手过程中，服务器接收到客户端的FIN请求，它可能还有数据包还没发送完，只能先返回ACK报文来应答，等数据包发送完之后，才能返回FIN请求给客户端。

#### 六、TIME_WAIT状态为什么要定义为2MSL？

1. 尽可能能的确保最后的ACK报文顺利到达服务器

   第四次握手时，客户端向服务器发送的ACK报文可能会丢失，服务器收不到ACK报文，就会进行超时重传FIN

   **补充：**那么为什么不把时间设置成**RTT（报文从发送到接受再到确认的一次往返时间）**

   **答：**即第二点理由

2. 为了确保老的重复的报文段消失在网络中

3. 一些路由器会缓存数据包，TIME_WAIT可以有效地应对这种情况

#### 七、TCP三次握手可以传递数据吗？

前两次不可以，因为此时连接还没建立。

第三次可以，因为客户端收到服务器传来的ACK报文后，处于建立连接的状态，并且知道服务器接收和发送能力是正常的，所以可以传递数据。

#### 八、TCP如果没有完成第四次挥手会发生什么？

服务器端的重传计时器达到规定时间片，依旧没有收到来自客户端的ACK报文，就开始进行超时重传，重新发送FIN报文给客户端。

#### 九、计网五层模型和七层模型（应用层协议有哪些）

五层模型，从上到下：

- **应用层**——**DNS、HTTP**、SMTP、FTP、telnet

提供应用进程间的服务

- **传输层**——**TCP、UDP**

提供端到端的通信

即数据传输路径中最两端的两台网络设备之间的通信

- **网络层**——**IP**、ARP、ICMP、IGMP

路由、寻址，把数据包传送到目的地

- **数据链路层**——PPP、CSMA/CD



- **物理层**——电路交换、分组交换

**透明**地传输比特流，**透明**即让上层感受不到传输介质、接口光纤不同所带来的变化



七层模型：多了两层，表示层和会话层

#### 十、浏览器输入URL后发生了什么？（使用了哪些协议）

1. **DNS解析**

根据域名，在**浏览器缓存、系统缓存、路由器缓存**等依次向上查找。

另外，**DNS重定向/负载均衡**

2. **建立TCP连接**

三次握手

3. **发送HTTP请求**

因为HTTP请求是明文，存在信息泄露的风险。

所以采用HTTPS协议进行加密（HTTP + SSL）

4. **服务器处理请求并返回HTTP报文**

5. **浏览器解析渲染页面**

浏览器边解析边渲染

解析HTML和CSS文件，得到DOM树和渲染树

然后布局渲染树，并把它绘制到屏幕上



###### 协议：

1.DNS    解析域名，获得ip地址

2.TCP     与服务器建立连接

3.IP 	   使用TCP建立连接时，网络层用到了IP协议

4.OSPF  进行路由选择

5.ARP     路由器与服务器通信时，根据ip地址得到MAC地址

6.HTTP   发送网页数据的请求

#### 十一、TCP和UDP的区别

TCP：可靠、需要建立连接、消耗资源较多

UDP：不保证数据的正确，无连接，消耗资源少，程序结构简单

#### 十二、TCP的可靠传输

##### （一）如何确保可靠性传输：

使用超时重传来实现可靠传输，如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

##### （二）拥塞控制：

> 发送方维护变量**拥塞窗口（cwnd）**，出现拥塞时，控制发送方的发送速率，算法如下：

**1.慢开始** 从发送1个报文段开始，如果该报文段被接受，就把数量*2

**2.拥塞避免 **慢开始会增长地很快，当cwnd大于门限时，每次只增1

如果出现了超时，就将门限设置为cwnd / 2，然后cwnd = 1，重新执行满开始

**3.快重传与快恢复**

> 接收方收到的报文段应该是有序的，例如M1，M2收到，又来了个M4，这时候接收方发送对M2的确认

一旦发送方收到三个重复的确认，就可以判定下一个报文段丢失，立刻重传

出现快重传后，网络并没有拥塞，只是丢失了个别报文段，因此执行快恢复。

即把cwnd的值设置的大一些，具体操作为：

门限 / 2，cwnd = 门限，这表示直接进入拥塞避免状态。

##### （三）TCP传输时，客户端突然断开连接，服务器如何判定？

利用TCP协议层提供的保活探测方法来判定

##### （四）TCP的端口是为了区分什么？

区分一台设备中的不同应用进程

#### 十三、常见的HTTP状态码

200，204（没有实体内容），206（部分内容）

301（永久重定向），302（临时），303（临时，必须用GET请求），304（客户端发送附带条件，条件满足后的返回内容），307（临时）

400（请求报文错误），401（需要HTTP认证），403（没有访问服务器的权限），404（没找到资源）

500（服务器出错），503（服务器处于维护或超负载状态）

#### 十四、HTTP报文

##### （一）请求报文和响应报文的组成

请求报文由**请求行、请求首部、请求实体**组成

响应报文由**状态行、响应首部、响应实体**组成

##### （二）HTTP请求报文包含哪些方法，GET和POST的区别

**方法**有get，post，head，put，delete，options，trace，connect

**区别：**

1.GET用来获取资源，不会修改服务器的数据

而POST用来传输实体，可能会修改数据

2.GET的请求参数会附在URL之后，参数大小有限制

而POST参数是放在请求实体中

#### 十五、HTTP和HTTPS的区别

**区别：**

1. 明文，安全性
2. 需要证书，费用不同
3. 连接方式不同

**补充：**

- HTTPS使用混合加密机制

> 服务器持有公钥 A 和私钥 A'
>
> 客户端发起连接，服务器把 A 发送给客户端
>
> 客户端接收 A ，本地再生成一个对称密钥 X ，用 A 加密 X ，发送给服务器
>
> 服务器用 A‘ 解密，得到对称密钥 X
>
> 然后双方用 X 加密报文进行通信

- 数字证书

> 混合加密机制也有漏洞。
>
> 如果遇到“中间人攻击”，即中间人劫持服务器发送的公钥，换成自己的
>
> 所以需要让客户端判断它收到的公钥是否是服务器的，而不是中间人篡改后的
>
> 于是CA机构就出现了，网站向该机构申请数字证书，把公钥写入证书中，把证书传给客户端就可以了。

- 数字签名

> 证书也可能被篡改，所以就需要签名来判断证书是否为真。
>
> 签名制作：（CA持有一对非对称密钥）
>
> 1. CA对证书明文进行hash
>
> 2. hash后的值进行私钥加密，得到签名
>
> 浏览器判定：（浏览器持有CA公钥）
>
> 1. 用公钥解密签名
> 2. 根据证书说明的hash算法对明文hash
> 3. 比较前两者的值是否相等

#### 十六、HTTP1.0、1.1和2.0的区别

**1.0与1.1：**1.1默认使用长连接，支持流水线的请求

**2.0和1.x相比：**

- 支持多路复用

> 能够在一个连接中并发处理多个请求

- 头部数据压缩（开始行 + 首部。主体一般都是压缩的）

> 客户端和服务器同时维护一个缓存表，避免重复传输
>
> 此外，利用哈夫曼编码压缩首部字段

- 服务端推送

> 客户端请求资源时，会把相关资源（JS，CSS等）一起发送给客户端

- 二进制、分帧层

> 1.x是用文本协议的格式解析的，2.0采用二进制解析
>
> 把报文分成headers和data帧

- 总结

数据流共用一个连接，提高了TCP的利用率，同时也降低了延迟。

#### 十七、HTTP的缓存机制

介绍：

①Expires：过期时间

②Cache-Control：public，private，max-age，no-cache（不建议缓存，但还是有，相当于最大存活时间为0），no-store（不缓存），会覆盖①

③Last-Modified / If-Modified-Since：最后修改时间

④Etag / If-None-Match：唯一标识，如果修改了就会变化，优先级大于③

- 存储策略

> 服务器响应客户端的第一次请求时，缓存协商。
>
> 可以是1234的任意一个（甚至多个）

- 过期策略

> 客户端想要请求资源时，判断有无缓存，有缓存的话是否过期。

- 对比策略

> 如果请求头里有If-Modified-Since，就比较修改时间
>
> 如果请求头里有If-None-Match，就查找是否有Etag等于该值的数据
>
> 缓存没有过期的话，返回304；过期的话，重新进行缓存协商，并返回200和新的数据

#### 十八、什么是cookie和session，区别是什么，禁用cookie怎么办？

cookie和session都是会话跟踪的技术

cookie是保存在客户端的，在发送请求时携带cookie，服务器可以根据cookie跟踪会话

session是保存在服务端的。客户端第一次请求时，在服务器生成的一小块区域，然后服务器把session_id发给客户端，接下来的请求都带上session_id

区别：

1. 存放的位置不同
2. 请求过多时，session会影响服务器性能
3. 单个cookie保存的数据有大小限制，浏览器一般也有数量限制

#### 十九、页面加载不出来的原因



