---
title: (二).线程的返回结果
description: 介绍了Java的线程的返回结果
categories: 线程和线程池
tags:
	- 源码
---



**严肃脸.jpg**: Java实现线程三种方式是哪三种？

**答**: Thread、Runnable、Callable

其中Runnable接口定义的run方法是没有返回参数的，那么这样看来：

**Java的线程想要返回结果，就需要用到实现Callable接口的对象。**



那我们来看看这个接口

```Java
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
```

里面只定义了一个call()方法，返回的是泛型。

注释里提到，既可以是**返回结果**，也可以是**抛出异常**

----



![](/images/executor_1.PNG)

**上面这张图能够方便我们了解线程池各类的关系。**

另外，我们一般是用线程池的方式来创建线程执行任务。



**所以再来看看线程池提供的方法吧**

如果看过上一篇笔记，我们就可以知道：线程池提供了submit()方法

- 它是由**ExecutorService**接口定义的具有返回值的方法
- 并且返回值是**Future**

```Java
<T> Future<T> submit(Callable<T> task);

<T> Future<T> submit(Runnable task, T result);

Future<?> submit(Runnable task);
```

如上所示，该接口定义了三个submit()方法

有没有发现特别的地方，就是它居然能传进来**Runnable**对象！而我们之前所了解到的是Runnable对象是无法返回结果的。



**那么它是怎么做到的呢？**

那就要来到**ExecutorService**的实现类了，即**AbstractExecutorService**

我们就随便挑一个传Runnable对象的方法~~（总共不是有两个嘛）~~

```Java
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}
```

可以看到，里面创建了一个**RunnableFuture**对象，接下来让我**无脑推理一波：**

$RunnableFuture = Runnable + Future$

所以这个类就是实现了两个接口，那么它既能被当作**Runnable**对象去执行，又能当作**Future**对象来返回

这样子就说得通了。



**既然Future是返回结果类型，那么我们再去看看它是咋样的吧**

```Java
boolean cancel(boolean mayInterruptIfRunning);

boolean isCancelled();
boolean isDone();

V get() throws InterruptedException, ExecutionException;

V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
```

可以看到，里面就只有5个方法，这可太简单了是不是

而且这些方法看方法名就知道它是干啥了，就不用我多说了吧

**这里就讲一点：**

无参数的get()会一直阻塞地等待返回结果

有参数的，则会在超时时间后放弃等待

