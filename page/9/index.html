<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<!-- Referrer Policy调整致不蒜子单页面统计出错:https://senorui.top/posts/c33f.html -->
<meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aurora-ze.github.io.git","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Aurora">
<meta property="og:url" content="https://aurora-ze.github.io.git/page/9/index.html">
<meta property="og:site_name" content="Aurora">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="aurora">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aurora-ze.github.io.git/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Aurora</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?dcdb42c8e3ad5d5a7981af32b9693ef3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Aurora" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aurora</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">矢志前行，拥抱未来！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E5%B7%A5%E5%85%B7/protocol%20buffers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E5%B7%A5%E5%85%B7/protocol%20buffers/" class="post-title-link" itemprop="url">Protobuf入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-29 12:31:16" itemprop="dateModified" datetime="2021-08-29T12:31:16+08:00">2021-08-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文档链接"><a href="#文档链接" class="headerlink" title="文档链接"></a>文档链接</h1><p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers">protocol-buffers官网</a></p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3">proto3教程</a></p>
<p><a target="_blank" rel="noopener" href="https://halfrost.com/protobuf_encode/#toc-0">高效的数据压缩编码方式 Protobuf </a></p>
<h1 id="protocol-buffers"><a href="#protocol-buffers" class="headerlink" title="protocol buffers"></a>protocol buffers</h1><h3 id="什么是protocol-buffers"><a href="#什么是protocol-buffers" class="headerlink" title="什么是protocol buffers"></a>什么是protocol buffers</h3><p><strong>官方文档</strong></p>
<blockquote>
<p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p>
</blockquote>
<p><strong>翻译</strong></p>
<blockquote>
<p>protocol buffers是Google开源的一种对结构化数据进行序列化的方式。它具有语言无关、平台无关和可扩展性；和xml相比，它更小，更快并且更加简单。</p>
<p>用户只需要定义一次所需的结构化数据， 就可以利用生成的各种语言的代码从数据流中读写数据</p>
</blockquote>
<h3 id="选择语言进行安装"><a href="#选择语言进行安装" class="headerlink" title="选择语言进行安装"></a>选择语言进行安装</h3><p><a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers/protobuf (github.com)</a></p>
<h1 id="一、定义Message"><a href="#一、定义Message" class="headerlink" title="一、定义Message"></a>一、定义Message</h1><p>示例：在<code>.proto</code>文件中定义一个名叫<code>SearchRequest</code>的消息格式，用来表示搜索的请求</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./mvp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserLoginReq</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> UserName = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> Password = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserLoginRsp</span> </span>&#123;</span><br><span class="line">        <span class="built_in">bool</span> IsLogin = <span class="number">1</span>;</span><br><span class="line">        User UserInfo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一行<code>syntax = &quot;proto3&quot;</code>表示使用proto3的语法，要放在正文（非空行和非注释行）中的第一行，如果没有这一行，则表示使用proto2语法</li>
<li><code>go_package</code>指定生成目标代码的目录</li>
<li>消息体<code>UserLoginReq</code>由2个字段构成，每个字段包含类型、名称和值。</li>
</ul>
<h3 id="1-1-指定字段类型"><a href="#1-1-指定字段类型" class="headerlink" title="1.1 指定字段类型"></a>1.1 指定字段类型</h3><p>如示例中的<code>UserName</code>字段，类型为<code>string</code>；</p>
<p>类型既可以是数值类型，也可以是复合类型（枚举、其他消息体）</p>
<h3 id="1-2-设定字段值"><a href="#1-2-设定字段值" class="headerlink" title="1.2 设定字段值"></a>1.2 设定字段值</h3><p>字段值是唯一的，被用来标识该字段在消息的二进制格式</p>
<p><strong>字段值从1到15使用一个字节来编码，16到2047使用两个字节来编码，因此对于频繁出现的字段，它的值应该设成1到15之间。</strong></p>
<p>关于更多，可以先去了解下<code>protocol buffer</code>的编码</p>
<h3 id="1-3-指定字段规则"><a href="#1-3-指定字段规则" class="headerlink" title="1.3 指定字段规则"></a>1.3 指定字段规则</h3><ul>
<li><p><strong>singular</strong></p>
<p>  表示该字段出现次数不多于1（0个或者1个）</p>
<p>  proto3默认使用这种规则</p>
</li>
<li><p><strong>repeated</strong></p>
<p>  表示字段可以出现任意次，可以理解成数组</p>
</li>
</ul>
<h1 id="二、定义Service"><a href="#二、定义Service" class="headerlink" title="二、定义Service"></a>二、定义Service</h1><p>如果想要将上面定义的<code>Message</code>类型用于<code>rpc调用</code>，就要定义一个服务，服务中可以声明多个接口。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">rpc</span> Login(UserLoginReq) <span class="keyword">returns</span> (UserLoginRsp)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-完整示例"><a href="#2-1-完整示例" class="headerlink" title="2.1 完整示例"></a>2.1 完整示例</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./mvp&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">rpc</span> Login(UserLoginReq) <span class="keyword">returns</span> (UserLoginRsp)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户登陆请求</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserLoginReq</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> UserName = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> Password = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户登陆响应</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserLoginRsp</span> </span>&#123;</span><br><span class="line">        <span class="built_in">bool</span> IsLogin = <span class="number">1</span>;</span><br><span class="line">        User UserInfo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户消息格式</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        <span class="built_in">uint64</span> UserID = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> NickName = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">uint64</span> Age = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">repeated</span> <span class="built_in">string</span> ImgURL = <span class="number">4</span>;</span><br><span class="line">        UserType UserType = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义枚举类型：用户权限类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UserType</span> </span>&#123;</span><br><span class="line">        UT_Nil = <span class="number">0</span>;</span><br><span class="line">        UT_Visit = <span class="number">1</span>;</span><br><span class="line">        UT_Normal = <span class="number">2</span>;</span><br><span class="line">        UT_Admin = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、生成Go代码"><a href="#三、生成Go代码" class="headerlink" title="三、生成Go代码"></a>三、生成Go代码</h1><h3 id="3-1-下载插件"><a href="#3-1-下载插件" class="headerlink" title="3.1 下载插件"></a>3.1 下载插件</h3><p><code>protocol buffer complier</code>需要一个插件才能生成Go代码，因此先下载插件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure>

<p>下载完毕后在<code>$GOPATH/bin</code>路径下会生成<code>protoc-gen-go</code></p>
<h3 id="3-2-利用插件生成代码"><a href="#3-2-利用插件生成代码" class="headerlink" title="3.2 利用插件生成代码"></a>3.2 利用插件生成代码</h3><p>在项目的根目录下用终端（或cmd）输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. <span class="variable">$SRC_DIR</span>/addressbook.proto</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li><p><code>go_out</code>：表示生成go代码</p>
</li>
<li><p><code>$SRC_DIR/addressbook.proto</code>：表示协议所在位置</p>
</li>
<li><p>如果想要指定代码生成的位置，则在协议文件中添加</p>
  <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;yourpath&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、demo"><a href="#四、demo" class="headerlink" title="四、demo"></a>四、demo</h1><h3 id="4-1-编码并写入文件"><a href="#4-1-编码并写入文件" class="headerlink" title="4.1 编码并写入文件"></a>4.1 编码并写入文件</h3><p>主要使用<code>Marshal()</code>进行编码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestProtoWrite 测试把消息写入指定文件中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProtoWrite</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    login := &amp;mvp.UserLoginReq &#123;</span><br><span class="line">        UserName: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">        Password: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out, err := proto.Marshal(login)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Fail to encode message login:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = ioutil.WriteFile(FilePath, out, fs.FileMode(<span class="number">777</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Fail to write file:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-读取消息并解码"><a href="#4-2-读取消息并解码" class="headerlink" title="4.2 读取消息并解码"></a>4.2 读取消息并解码</h3><p>使用<code>Unmarshal()</code>进行解码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestProtoRead 测试从指定文件中读取消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestProtoRead</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    in, err := ioutil.ReadFile(FilePath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Fail to read file:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    login := &amp;mvp.UserLoginReq&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err = proto.Unmarshal(in, login); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(<span class="string">&quot;Fail to decode message login:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(login)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="五、编码详解"><a href="#五、编码详解" class="headerlink" title="五、编码详解"></a>五、编码详解</h1><h3 id="5-1-Base-128-Varints"><a href="#5-1-Base-128-Varints" class="headerlink" title="5.1 Base 128 Varints"></a>5.1 Base 128 Varints</h3><h5 id="官方文档说明"><a href="#官方文档说明" class="headerlink" title="官方文档说明"></a>官方文档说明</h5><blockquote>
<p>To understand your simple protocol buffer encoding, you first need to understand <em>varints</em>. Varints are a method of serializing integers using one or more bytes. Smaller numbers take a smaller number of bytes.</p>
<p>Each byte in a varint, except the last byte, has the <em>most significant bit</em> (msb) set – this indicates that there are further bytes to come. The lower 7 bits of each byte are used to store the two’s complement representation of the number in groups of 7 bits, <strong>least significant group first</strong>.</p>
</blockquote>
<h5 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h5><blockquote>
<p>为了帮助你理解<code>protocol buffer</code>的编码方式，你需要先了解一下<code>varints</code>。<code>varints</code>是一种将整数类型序列化成一个或多个字节的方法。越小的数字序列化后产生的字节数就越少。</p>
<p>varints中除了最后一个字节，其他字节的最高有效位都置为1，用来表示接下来还有字节；剩余的低7位则是对每7位为一组的二进制数据的补码表示。</p>
</blockquote>
<h5 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h5><p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210701200434.png"></p>
<p>解码过程就是上述编码的逆过程，这里就不再赘述。</p>
<h3 id="5-2-消息类型编码"><a href="#5-2-消息类型编码" class="headerlink" title="5.2 消息类型编码"></a>5.2 消息类型编码</h3><blockquote>
<p>从之前的消息示例中我们可以看出，消息是由一系列的键值对组成的。</p>
</blockquote>
<h5 id="键值对介绍"><a href="#键值对介绍" class="headerlink" title="键值对介绍"></a>键值对介绍</h5><p>键被称为<code>tag</code>，由<code>field number</code>和<code>wire type</code>构成，前者表示设定的字段号，后者可以查表得。</p>
<p>值就是该字段被赋予的数值。</p>
<p><code>tag</code>的计算方式为：<br>$$<br>tag = (field number &lt;&lt; 3)  | wire type<br>$$<br>表格如下，其中3，4已被废弃，就是说<code>wire type</code>取值应该只有0，1，2，5，因此用三比特即可表示<code>wire type</code>。</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">Meaning</th>
<th align="left">Used For</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">Varint</td>
<td align="left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">64-bit</td>
<td align="left">fixed64, sfixed64, double</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Length-delimited</td>
<td align="left">string, bytes, embedded messages, packed repeated fields</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Start group</td>
<td align="left">groups (deprecated)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">End group</td>
<td align="left">groups (deprecated)</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">32-bit</td>
<td align="left">fixed32, sfixed32, float</td>
</tr>
</tbody></table>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>现有以下消息，假设传入消息，a的值是150</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个消息体编码后得到的结果是<code>08 96 01</code>（16进制）</p>
<ul>
<li><p>计算tag</p>
<p>  0001 ++ 000，得到<code>0001000</code>，即<strong>08</strong></p>
</li>
<li><p>对150进行编码，采取上述<code>varints</code>方式</p>
<ul>
<li>10010110</li>
<li>1，0010110</li>
<li>00000001，10010110</li>
<li>得到编码<code>10010110，00000001</code></li>
<li>用16进制表示，即<strong>96 01</strong></li>
</ul>
</li>
</ul>
<h3 id="5-3-字符串编码"><a href="#5-3-字符串编码" class="headerlink" title="5.3 字符串编码"></a>5.3 字符串编码</h3><p>和普通的整型相比，字符串在消息体中的编码方式多了一个length，表示字符串编码后的长度。</p>
<p>形式为<code>key length content</code>。</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>b赋值为testing</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">string</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码后的结果是<code>12 07 74 65 73 74 69 6e 67</code></p>
<p>其中<strong>07</strong>表示长度，后面的7个16进制就是testing的utf8编码</p>
<p>最开始的<strong>12</strong>就是key，由0010010转换成16进制得到。</p>
<h2 id="六、"><a href="#六、" class="headerlink" title="六、"></a>六、</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E5%B7%A5%E5%85%B7/maven%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E5%B7%A5%E5%85%B7/maven%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/" class="post-title-link" itemprop="url">Maven问题和解决方案记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-16 23:26:26" itemprop="dateModified" datetime="2021-08-16T23:26:26+08:00">2021-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、无脑配镜像"><a href="#一、无脑配镜像" class="headerlink" title="一、无脑配镜像"></a>一、无脑配镜像</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tmd啥镜像都不用配</span></span><br></pre></td></tr></table></figure>

<h3 id="二、删除lastupdated文件"><a href="#二、删除lastupdated文件" class="headerlink" title="二、删除lastupdated文件"></a>二、删除lastupdated文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listDirectory</span><span class="params">(File dir)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dir.exists())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;目录：&quot;</span> + dir + <span class="string">&quot;不存在.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!dir.isDirectory()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(dir + <span class="string">&quot; 不是目录。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory())</span><br><span class="line">                <span class="comment">//递归</span></span><br><span class="line">                listDirectory(file);</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 删除以 lastUpdated 结尾的文件</span></span><br><span class="line">                String fileName = file.getName();</span><br><span class="line">                <span class="keyword">boolean</span> isLastupdated = fileName.toLowerCase().endsWith(<span class="string">&quot;lastupdated&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (isLastupdated)&#123;</span><br><span class="line">                    <span class="keyword">boolean</span> is_delete = file.delete();</span><br><span class="line">                    System.out.println(<span class="string">&quot;删除的文件名 =&gt; &quot;</span> + file.getName() + <span class="string">&quot;  || 是否删除成功？ ==&gt; &quot;</span> + is_delete);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 指定maven的本地仓库</span></span><br><span class="line">    listDirectory(<span class="keyword">new</span> File(<span class="string">&quot;E:\\programs\\mvnrepository&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h3><h5 id="描述1："><a href="#描述1：" class="headerlink" title="描述1："></a>描述1：</h5><blockquote>
<p>Could not transfer artifact xxx from/to xxx解决方案</p>
</blockquote>
<h5 id="解决方案1："><a href="#解决方案1：" class="headerlink" title="解决方案1："></a>解决方案1：</h5><ol>
<li>用上述工具类删除下载失败的文件</li>
<li>在<code>pom.xml</code>文件中，右键-&gt;Maven-&gt;reload project</li>
<li>完美运行</li>
</ol>
<h5 id="解决方案2："><a href="#解决方案2：" class="headerlink" title="解决方案2："></a>解决方案2：</h5><p>删除文件不用多说</p>
<p>然后在终端输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean &amp;&amp; mvn compile -Dmaven.wagon.http.ssl.insecure=<span class="literal">true</span> -Dmaven.wagon.http.ssl.allowall=<span class="literal">true</span> -Dmaven.wagon.http.ssl.ignore.validity.dates=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后刷新试试（注意，maven没有配置镜像，裸连）</p>
<hr>
<h5 id="描述2："><a href="#描述2：" class="headerlink" title="描述2："></a>描述2：</h5><p>出现SSL证书问题</p>
<h5 id="解决方案2：-1"><a href="#解决方案2：-1" class="headerlink" title="解决方案2："></a>解决方案2：</h5><p>最简单粗暴的，在终端输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean &amp;&amp; mvn compile -Dmaven.wagon.http.ssl.insecure=<span class="literal">true</span> -Dmaven.wagon.http.ssl.allowall=<span class="literal">true</span> -Dmaven.wagon.http.ssl.ignore.validity.dates=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如果显示<strong>无法识别mvn命令</strong>，那就是<strong>环境变量</strong>没配置对，重新去配下maven的环境变量</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22041375/article/details/103491941">剩余方法参考这里</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E5%B7%A5%E5%85%B7/Git&Github%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E5%B7%A5%E5%85%B7/Git&Github%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Git&GitHub使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-13 09:36:26" itemprop="dateModified" datetime="2021-09-13T09:36:26+08:00">2021-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、拉取某一远程分支"><a href="#一、拉取某一远程分支" class="headerlink" title="一、拉取某一远程分支"></a>一、拉取某一远程分支</h2><p>项目分支太多，只想要某一分支时，可以添加<code>--single-branch</code>参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b 分支名 --single-branch 仓库路径</span><br></pre></td></tr></table></figure>



<h2 id="二、合并分支并解决冲突"><a href="#二、合并分支并解决冲突" class="headerlink" title="二、合并分支并解决冲突"></a>二、合并分支并解决冲突</h2><p><strong>开发流程</strong></p>
<p>master -&gt; 创建特性分支 -&gt; 在特性分支上开发 -&gt; 拉取最新master，合并到特性分支 -&gt; 提交到远程仓库，并提MR</p>
<p><strong>解释</strong></p>
<ol>
<li>开发需求时，通常是从master分支中拉一个新的分支，称为特性分支，然后在特性分支上开发。</li>
</ol>
<ol start="2">
<li><p>开发完毕后，申请<code>merge request</code>到master分支上。</p>
</li>
<li><p>但是这时候master分支可能已经发生了变化，比如同事早一步开发完，合到了master分支上。</p>
</li>
<li><p>这时候就需要把master拉下来，合并到特性分支上。</p>
</li>
</ol>
<p>具体的操作方式很简单，在<code>idea</code>上先把master分支<code>pull</code>下来</p>
<p>然后点击master分支（不要切换），选择<code>merge into current</code>，如果有冲突，进行解决即可。</p>
<h2 id="三、项目中引用外部协议"><a href="#三、项目中引用外部协议" class="headerlink" title="三、项目中引用外部协议"></a>三、项目中引用外部协议</h2><h5 id="1-修改协议项目中的go-mod"><a href="#1-修改协议项目中的go-mod" class="headerlink" title="1. 修改协议项目中的go.mod"></a>1. 修改协议项目中的go.mod</h5><p>把<code>go.mod</code>的module路径改成带GitHub的，如</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module github.com<span class="regexp">/Aurora-Ze/</span>protocol</span><br></pre></td></tr></table></figure>

<h5 id="2-修改协议文件"><a href="#2-修改协议文件" class="headerlink" title="2. 修改协议文件"></a>2. 修改协议文件</h5><p><code>go_package</code>符合url路径</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user.cgi;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/Aurora-Ze/protocol/user/cgi&quot;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-引入"><a href="#3-引入" class="headerlink" title="3. 引入"></a>3. 引入</h5><p>在随便一个go文件中的<code>import</code>块里添加，然后<code>Alt + Enter</code>提示同步依赖</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;github.com/Aurora-Ze/protocol/user/cgi&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="四、添加Github-SSH-key"><a href="#四、添加Github-SSH-key" class="headerlink" title="四、添加Github SSH key"></a>四、添加Github SSH key</h2><p>如果想要通过SSH的方式克隆项目，就要先在本地生成SSH密钥对，然后把公钥添加到GitHub配置中，就可以建立起本地和远程GitHub仓库的连接。</p>
<p>通过SSH有个好处，就是不需要再输入账号和个人令牌进行登陆验证，避免信息泄露</p>
<h5 id="1-设置name和email"><a href="#1-设置name和email" class="headerlink" title="1. 设置name和email"></a>1. 设置name和email</h5><p>在项目目录下，打开cmd输入</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config <span class="keyword">user</span>.name &quot;xxx&quot;</span><br><span class="line">git cinfig <span class="keyword">user</span>.email &quot;xxx@gmail.com&quot;</span><br></pre></td></tr></table></figure>

<h5 id="2-生成密钥"><a href="#2-生成密钥" class="headerlink" title="2. 生成密钥"></a>2. 生成密钥</h5><p>密钥默认生成在用户目录下的<code>.ssh</code>文件夹中，如果已经存在，请备份或指定其他位置</p>
<p>按三次回车后生成密钥，然后把<code>.pub</code>中内容添加到GitHub的<code>SSH and GPG keys</code>中上</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">ssh</span><span class="operator">-</span><span class="variable">keygen</span> <span class="operator">-</span><span class="built_in">C</span> <span class="string">&quot;xxx@gmail.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>-t：指定密钥类型，默认rsa</li>
<li>-C：添加注释</li>
<li>-f：指定密钥保存的文件</li>
<li>-b：指定密钥长度，最小1024位，默认3072</li>
</ul>
<p>如果想要更高的安全性，密钥签名算法可以选择<code>ed25519</code>，其长度为256位，无需设置密钥尺寸</p>
<h5 id="3-指纹"><a href="#3-指纹" class="headerlink" title="3.指纹"></a>3.指纹</h5><p>生成密钥对后，命令行中会显示一串字母，称为指纹。第一次连接远程主机时，也会显示指纹。</p>
<p>指纹是公钥经过哈希和编码后生成的较短的字符串，通过它可以判断本地密钥对的公钥和远程主机配置的公钥是否一致</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Your public key has been saved <span class="keyword">in</span> C:/Users/xxx/.ssh/test_rsa/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:nCWjRmyWUj7+E8/X9UW5KRdsl9Ml4W0z1t8X5vsRmFs 87654321xxx@gmail.com</span><br></pre></td></tr></table></figure>



<h2 id="五、把多个提交合并为一个"><a href="#五、把多个提交合并为一个" class="headerlink" title="五、把多个提交合并为一个"></a>五、把多个提交合并为一个</h2><blockquote>
<p>为了让master分支更加干净一些，我们在提MR之前，最好先把自己分支上的多个提交合并成一个。</p>
<p>有两种方式可以实现</p>
</blockquote>
<p><strong>第一种：替换旧的提交</strong></p>
<p>在每次提交时，添加<code>amend</code>参数，即</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>该参数会覆盖上一次的提交，并生成新的commit</p>
<p>只要我们在第二次及以后每次提交时，都采用该命令，就可以始终保持commit记录为一个了。</p>
<p><strong>注意</strong>：之后<code>push</code>到远程分支，要带上<code>-f</code>参数，即<strong>强制推送</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f </span><br></pre></td></tr></table></figure>

<p><strong>局限性</strong>：如果我们已经有了多次提交，那么这个方式就不太适用。</p>
<p><strong>第二种：rebase命令</strong></p>
<p>用git log查看提交日志，选择最近的一次他人提交，复制id</p>
<p>git rebase -i id，然后在vim模式下把不想要的提交前缀改为d，想要合并的改为s，保持上面第一个为pick即可</p>
<p>最后rebase完毕后，<strong>记得要强制push</strong></p>
<p><code>问题</code>：在idea的终端进行rebase操作时，遇到退不出vim模式的情况（按esc后鼠标指针跳到代码中）</p>
<p><code>解决</code>：鼠标右键终端标签，选择move to editor</p>
<h2 id="六、更新远程分支列表"><a href="#六、更新远程分支列表" class="headerlink" title="六、更新远程分支列表"></a>六、更新远程分支列表</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">update</span> origin <span class="comment">--prune</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">分布式id生成</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-09 19:53:18" itemprop="dateModified" datetime="2021-05-09T19:53:18+08:00">2021-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式id生成方式"><a href="#分布式id生成方式" class="headerlink" title="分布式id生成方式"></a>分布式id生成方式</h1><h3 id="一、数据库自增ID"><a href="#一、数据库自增ID" class="headerlink" title="一、数据库自增ID"></a>一、数据库自增ID</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>创建表时设置主键为<code>auto_increment</code></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>实现简单，但是每次生成ID都要访问一次数据库，带来压力；而且多台设备下可能会重复。</p>
<h3 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-06 22:01:40" itemprop="dateModified" datetime="2021-09-06T22:01:40+08:00">2021-09-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023615225">https://segmentfault.com/a/1190000023615225</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">操作系统——内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-28 15:12:48" itemprop="dateModified" datetime="2021-09-28T15:12:48+08:00">2021-09-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-1程序的运行"><a href="#1-1程序的运行" class="headerlink" title="1.1程序的运行"></a>1.1程序的运行</h2><p>主要有三步，<strong>编译</strong>、<strong>链接</strong>和<strong>装入</strong>。</p>
<ul>
<li><strong>编译</strong>，源码编译成若干个目标模块</li>
<li><strong>链接</strong>，多个目标模块与所需库函数链接，形成完整模块</li>
<li><strong>装入</strong>，把完整模块装入到内存中</li>
</ul>
<h2 id="1-2链接方式"><a href="#1-2链接方式" class="headerlink" title="1.2链接方式"></a>1.2链接方式</h2><h3 id="1-2-1静态链接"><a href="#1-2-1静态链接" class="headerlink" title="1.2.1静态链接"></a>1.2.1静态链接</h3><p>执行前链接库函数</p>
<h3 id="1-2-2装入时动态链接"><a href="#1-2-2装入时动态链接" class="headerlink" title="1.2.2装入时动态链接"></a>1.2.2装入时动态链接</h3><p>模块放入内存时，链接上目标库函数</p>
<h3 id="1-2-3运行时动态链接"><a href="#1-2-3运行时动态链接" class="headerlink" title="1.2.3运行时动态链接"></a>1.2.3运行时动态链接</h3><p>执行时需要某个模块时，才进行链接</p>
<h2 id="1-3装入方式"><a href="#1-3装入方式" class="headerlink" title="1.3装入方式"></a>1.3装入方式</h2><p>装入过程中，要把模块放入到内存中运行，可是该放在内存的哪个位置呢？</p>
<p>因此出现了3种不同的装入方式，<strong>绝对装入</strong>、<strong>静态重定位</strong>和<strong>动态重定位</strong>。</p>
<h3 id="1-3-1绝对装入"><a href="#1-3-1绝对装入" class="headerlink" title="1.3.1绝对装入"></a>1.3.1绝对装入</h3><p>编译时程序就已经知道了它的物理（绝对）地址，所以装入时直接放在相应位置即可。</p>
<p>只适用于单道程序环境</p>
<h3 id="1-3-2静态重定位"><a href="#1-3-2静态重定位" class="headerlink" title="1.3.2静态重定位"></a>1.3.2静态重定位</h3><p>由装入程序把逻辑地址转变成物理地址</p>
<p><strong>特点：装入时必须分配所需的全部内存空间</strong></p>
<p>早期多道批处理系统使用这种方式。</p>
<h3 id="1-3-3动态重定位"><a href="#1-3-3动态重定位" class="headerlink" title="1.3.3动态重定位"></a>1.3.3动态重定位</h3><p>装入时还是使用的逻辑地址，等到指令真正运行时，才会把逻辑地址转换成物理地址</p>
<p>是通过一个<code>重定位寄存器</code>存储模块的起始位置来实现的。</p>
<h2 id="1-4编址方式"><a href="#1-4编址方式" class="headerlink" title="1.4编址方式"></a>1.4编址方式</h2><p>内存有两种编址方式，分别是<strong>按字节编址</strong>和<strong>按字编址</strong></p>
<ul>
<li><p><strong>按字节编址</strong></p>
<p>  从地址0开始，每个存储单元表示1字节</p>
</li>
<li><p><strong>按字编址</strong></p>
<p>  <code>字</code>指的是处理器的字长，例如32位计算机，字长就是32位，转化成字节就是4字节</p>
<p>  所以每个存储单元就是4字节</p>
</li>
</ul>
<h1 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h1><p>操作系统管理内存，主要做了几件事</p>
<ol>
<li>内存空间的分配与回收</li>
<li>内存空间的扩充</li>
<li>地址转换</li>
<li>内存保护</li>
</ol>
<p>下面我们打乱顺序，从最简单的开始将。</p>
<h1 id="三、内存保护"><a href="#三、内存保护" class="headerlink" title="三、内存保护"></a>三、内存保护</h1><p>内存保护指一个进程应该只能访问自己空间的数据</p>
<p>两种方法：</p>
<ul>
<li>一是设置上限、下限寄存器</li>
<li>二是采用重定位寄存器</li>
</ul>
<h1 id="四、内存空间分配与回收"><a href="#四、内存空间分配与回收" class="headerlink" title="四、内存空间分配与回收"></a>四、内存空间分配与回收</h1><p>内存分配可以采用连续分配，也可以采用非连续分配的方式。</p>
<p>下面这张图介绍了连续分配内存的相关知识。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210505160506.png" alt="连续分配管理"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%94%E3%80%81%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%94%E3%80%81%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-25 14:57:38" itemprop="dateModified" datetime="2021-10-25T14:57:38+08:00">2021-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、进程基础"><a href="#一、进程基础" class="headerlink" title="一、进程基础"></a>一、进程基础</h1><h2 id="1-1问题总览"><a href="#1-1问题总览" class="headerlink" title="1.1问题总览"></a>1.1问题总览</h2><h3 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h3><p>什么是进程？进程和程序的区别是什么？</p>
<p>进程的状态有哪些？</p>
<p>进程结构是怎样的，由哪些部分构成？</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>怎样运行进程</p>
<p>创建进程、执行进程</p>
<h2 id="1-2解答"><a href="#1-2解答" class="headerlink" title="1.2解答"></a>1.2解答</h2><h3 id="什么是进程？什么是程序？"><a href="#什么是进程？什么是程序？" class="headerlink" title="什么是进程？什么是程序？"></a>什么是进程？什么是程序？</h3><p>程序是位于磁盘上的代码。而<strong>进程</strong>则是正在执行的程序实例</p>
<h3 id="细说进程的组成？"><a href="#细说进程的组成？" class="headerlink" title="细说进程的组成？"></a>细说进程的组成？</h3><p><strong>进程的内存空间</strong></p>
<p>在32位Linux系统中，进程拥有4GB的虚拟内存，内核1G，用户3G。</p>
<p>进程的用户空间中包含<code>代码、常量数据和用户堆栈</code>等；而内核空间中包含<code>内核栈</code>。</p>
<p><strong>用户栈与内核栈</strong></p>
<p>处于用户态执行时，进程的函数调用等操作都使用<code>用户栈</code></p>
<p>进入内核态后的一些操作都使用<code>内核栈</code>来记录</p>
<h3 id="PCB是什么？"><a href="#PCB是什么？" class="headerlink" title="PCB是什么？"></a>PCB是什么？</h3><p><strong>进程控制块PCB：</strong></p>
<ul>
<li>标志信息（pid、ppid、uid）</li>
<li>处理器信息（保存上下文切换时寄存器中的内容）</li>
<li>进程控制信息（调度、通信）</li>
</ul>
<h3 id="进程状态有哪些？"><a href="#进程状态有哪些？" class="headerlink" title="进程状态有哪些？"></a>进程状态有哪些？</h3><p>创建、就绪、等待、运行、终止</p>
<h3 id="操作系统如何管理进程？"><a href="#操作系统如何管理进程？" class="headerlink" title="操作系统如何管理进程？"></a>操作系统如何管理进程？</h3><p><strong>进程表：</strong>操作系统维护一张<code>进程表</code>，每个表项都代表了一个进程。表项由<code>PID</code>和<code>指向PCB的指针</code>构成</p>
<p><strong>进程操作</strong></p>
<ul>
<li>进程创建<ul>
<li>描述：创建PCB（Linux中表示为<code>task_struct</code>结构体），分配内存空间</li>
<li>命令：<code>fork()</code>，返回子进程PID</li>
</ul>
</li>
<li>处理子进程<ul>
<li>描述：创建子进程后，如果父进程不进行显式处理，子进程就可能变成<code>孤儿</code>或<code>僵尸进程</code></li>
<li>命令：<code>wait()</code>或<code>waitpid()</code>，前者不区分子进程；后者指定子进程pid，且可以设置不阻塞等待</li>
</ul>
</li>
</ul>
<p><strong>进程切换</strong></p>
<ul>
<li>产生原因：中断、时间片到期等</li>
<li>过程：上下文切换，即保存寄存器、程序计数器等数据到进程的PCB中；然后从另一个进程PCB中加载数据到寄存器和PC中。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%8C%E3%80%81IO%E5%8F%8A%E7%A3%81%E7%9B%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%8C%E3%80%81IO%E5%8F%8A%E7%A3%81%E7%9B%98/" class="post-title-link" itemprop="url">操作系统——IO及磁盘</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-16 21:41:12" itemprop="dateModified" datetime="2021-09-16T21:41:12+08:00">2021-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、I-O和缓冲区介绍"><a href="#一、I-O和缓冲区介绍" class="headerlink" title="一、I/O和缓冲区介绍"></a>一、I/O和缓冲区介绍</h2><h3 id="1-1抛出问题"><a href="#1-1抛出问题" class="headerlink" title="1.1抛出问题"></a>1.1抛出问题</h3><ol>
<li>什么是IO，有哪些IO类型</li>
<li>进程发起IO请求的过程是怎样的</li>
<li>操作系统怎样处理IO，对IO做了哪些优化</li>
</ol>
<h3 id="1-2阅读文章"><a href="#1-2阅读文章" class="headerlink" title="1.2阅读文章"></a>1.2阅读文章</h3><p><a target="_blank" rel="noopener" href="https://houbb.github.io/2020/10/04/os-15-io-cache-buffer">磁盘高速缓存——各类缓冲区介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/406991">缓存IO与直接IO</a></p>
<h3 id="1-3理解"><a href="#1-3理解" class="headerlink" title="1.3理解"></a>1.3理解</h3><p>进程在执行时可能需要读取键盘输入、或向磁盘输出数据，这些操作都属于I/O</p>
<p>IO类型：用户（键盘鼠标交互）、磁盘等外设、网络通信</p>
<h4 id="I-O控制"><a href="#I-O控制" class="headerlink" title="I/O控制"></a>I/O控制</h4><p>最开始是由CPU直接向IO设备下达指令，并且要阻塞等待IO操作完成</p>
<p>后来：</p>
<ul>
<li><strong>IO模块</strong>封装各类IO的细节，向上层提供api。</li>
<li><strong>中断指令</strong>可以让CPU执行其他进程，IO操作结束后发送中断指令给CPU，再让其切换到发起IO操作的进行来执行。<ul>
<li><code>问题</code>中断指令是怎么发起的，是硬件提供的，还是操作系统提供的？</li>
</ul>
</li>
<li><strong>DMA模块</strong><code>直接存储访问</code>可以让内存与IO模块直接进行数据传输，CPU只需要在IO开始和结束时进行干涉。</li>
</ul>
<h4 id="I-O缓冲"><a href="#I-O缓冲" class="headerlink" title="I/O缓冲"></a>I/O缓冲</h4><p><strong>局限性</strong></p>
<p>我们都知道读写IO的速度是比CPU执行速度慢很多的</p>
<p>所以当一个进程在读取磁盘上的数据块时，它会挂起（切换其他进程执行）或一直等待</p>
<p>但是因为数据会读到进程的工作空间，所以这个进程的工作空间会被锁住，确保在等待IO期间不被换下（例如分页中的页置换）</p>
<p><strong>优化</strong></p>
<p>操作系统提供I/O缓冲区，缓冲策略可以是读完一个数据块后，立刻读后面的</p>
<h2 id="二、磁盘"><a href="#二、磁盘" class="headerlink" title="二、磁盘"></a>二、磁盘</h2><h3 id="2-1抛出问题"><a href="#2-1抛出问题" class="headerlink" title="2.1抛出问题"></a>2.1抛出问题</h3><ol>
<li>磁盘结构、常用术语</li>
<li>向磁盘读/写数据的过程</li>
<li>磁盘调度算法有哪些，什么场景下用哪个会更好，调度算法是在哪个过程用的</li>
</ol>
<h3 id="2-2阅读文章"><a href="#2-2阅读文章" class="headerlink" title="2.2阅读文章"></a>2.2阅读文章</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/iwehdio/p/13681037.html">IO控制、IO缓冲、磁盘调度</a></p>
<h3 id="2-3总结"><a href="#2-3总结" class="headerlink" title="2.3总结"></a>2.3总结</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><strong>柱面、盘面、磁臂、磁头、磁道、扇区、转速</strong></p>
<h4 id="读写过程"><a href="#读写过程" class="headerlink" title="读写过程"></a>读写过程</h4><ul>
<li><p><strong>寻道</strong></p>
<ul>
<li><code>描述</code>：磁头找到对应的柱面（C、D、E盘等等），然后在盘面上找到对应的磁道</li>
<li><code>时间计算</code>：$T_{寻道}=T_{磁头启动}+m*n(跨越n个磁道，每个磁道耗时m)$</li>
<li><code>优化思路</code>：减少跨越磁道的个数，即<strong>磁盘调度算法</strong></li>
</ul>
</li>
<li><p><strong>旋转延迟</strong></p>
<ul>
<li><code>描述</code>：磁盘要旋转一段距离，好让磁头定位到目标扇区</li>
<li><code>时间计算</code>：$T_{旋转}=\frac{1}{2r}，假设平均需要转半圈$</li>
</ul>
</li>
<li><p><strong>传输</strong></p>
<ul>
<li><code>描述</code>：接下来磁盘继续旋转，这次是进行读写了。</li>
<li><code>时间计算</code>：$T_{传输}=\frac{b}{rN}，表示读写b个字节，磁道总字节为N$</li>
<li><code>优化思路</code>：数据放一块，可以顺序读写，避免再次寻道（随机IO）</li>
</ul>
</li>
</ul>
<p><strong>所以在磁盘上的耗费时间也可以计算：寻道时间、旋转延迟、传输时间</strong></p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p><strong>使用场景</strong></p>
<p>每个IO设备应该都有一个队列，如果磁盘正在处理某次IO，那么其他IO请求就会在队列中等待。</p>
<p>如果按请求进来的顺序执行，就可能存在请求的磁盘位置过于分散，寻道时间大大增加的情况。</p>
<p><strong>调度算法大致有三种类型：队列式、最短距离、扫描</strong></p>
<ul>
<li><strong>FIFO</strong><ul>
<li><code>描述</code>：按队列顺序来处理IO请求</li>
<li><code>缺点</code>：大部分情况就是随机IO</li>
<li><code>应用</code>：访问位置比较密集时，性能还说得上去</li>
<li><code>变种</code>：<strong>LIFO</strong>后进来的先处理，充分利用了局部性</li>
</ul>
</li>
<li><strong>SSTF</strong><ul>
<li><code>描述</code>：每次选择与当前磁道最近的请求进行执行</li>
<li><code>缺点</code>：可能会出现饥饿，距离远的永远达不到；还有就是得计算距离</li>
<li><code>应用</code>：比FIFO快蛮多的</li>
</ul>
</li>
</ul>
<p>下面是扫描算法，有好几种变种</p>
<ul>
<li><p><strong>SCAN</strong></p>
<ul>
<li><code>描述</code>：磁臂沿着一个方向扫描，处理遇到的所有请求，到边界后再调头扫描</li>
<li><code>缺点</code>：对磁臂周围的局部区域不公平，因为等待时间长；多余扫描</li>
</ul>
</li>
<li><p><strong>C-SCAN</strong></p>
<ul>
<li><code>描述</code>：和SCAN类似，但它不调头，而是重复从起点到终点的扫描</li>
<li><code>应用</code>：这样对局部区域比较公平</li>
<li><code>缺点</code>：还有个缺点没解决，就是多余扫描</li>
</ul>
</li>
<li><p><strong>C-LOOK</strong></p>
<ul>
<li><code>描述</code>：前面没有请求了，就直接回到起点</li>
</ul>
</li>
<li><p>N步SCAN：把请求队列划分成多个长度为N的子队列</p>
</li>
<li><p>FSCAN：用两个子队列，新请求全放在另一个队列中</p>
</li>
</ul>
<h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>IO请求多时，一个磁盘处理不过来</p>
<p>那就用多个磁盘集成在一起，就是RAID了</p>
<h4 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h4><p>跟CPU和内存之间建立的高速缓存一样，内存中有一块地方专门做磁盘的缓存。</p>
<p>IO请求先判断能否命中磁盘高速缓存，再去决定是否进行IO</p>
<p><strong>命中缓存时，如何把数据交给进程</strong></p>
<ul>
<li>就硬传，把数据传到进程的工作空间</li>
<li>以共享内存的方式，把地址传给进程即可</li>
</ul>
<p><strong>新的磁盘IO完成后，高速缓存要存入新的数据，采取怎样的更新策略（页置换）</strong></p>
<ul>
<li><strong>LRU</strong><ul>
<li>最近最少使用</li>
<li>用栈（双端队列）维护，每次用到一个页，把它放到栈顶。置换时把栈底（最久没用过）的换出去</li>
<li>缺点：如果大量读入新的页，可能会导致热点页来到栈底，被置换出去</li>
</ul>
</li>
<li><strong>LFU</strong><ul>
<li>使用频率最低</li>
<li>对每个页计数</li>
<li>缺点：可能某个页刚放进来又被置换出去了，对局部性情况不友好。</li>
</ul>
</li>
</ul>
<h2 id="三、Linux中的IO"><a href="#三、Linux中的IO" class="headerlink" title="三、Linux中的IO"></a>三、Linux中的IO</h2><h3 id="3-1抛出问题"><a href="#3-1抛出问题" class="headerlink" title="3.1抛出问题"></a>3.1抛出问题</h3><ol>
<li>IO的读写过程，缓冲区？</li>
<li>执行IO的方式有哪些，系统调用和stdio库函数的区别？</li>
<li>关于磁盘的一些常用指令</li>
</ol>
<h3 id="3-2阅读文章"><a href="#3-2阅读文章" class="headerlink" title="3.2阅读文章"></a>3.2阅读文章</h3><p><a target="_blank" rel="noopener" href="https://www.litreily.top/2018/10/25/io-cache/">Linux中的文件I/O缓冲</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018499770">一文掌握 Linux 性能分析之 I/O 篇</a></p>
<h3 id="3-3理解"><a href="#3-3理解" class="headerlink" title="3.3理解"></a>3.3理解</h3><h4 id="执行IO的过程"><a href="#执行IO的过程" class="headerlink" title="执行IO的过程"></a>执行IO的过程</h4><p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210818012302.jpg"></p>
<p>可以看到其实有两层IO</p>
<ol>
<li><p>首先是在用户空间中，如果调用的是封装的<strong>stdio</strong>库函数的话，它会先处理库提供的缓冲</p>
</li>
<li><p>然后<strong>stdio</strong>库底层实际上也是read、write等系统调用，因此还有内核空间的文件IO缓冲<code>和磁盘高速缓存有什么区别？</code></p>
</li>
</ol>
<h4 id="磁盘IO相关指令"><a href="#磁盘IO相关指令" class="headerlink" title="磁盘IO相关指令"></a>磁盘IO相关指令</h4><p><strong>磁盘基本信息</strong></p>
<ul>
<li>fdisk -l<ul>
<li>磁盘大小、扇区个数和大小。</li>
</ul>
</li>
<li>df<ul>
<li>各个磁盘的使用情况，如剩余空间、利用率等等。</li>
</ul>
</li>
</ul>
<p><strong>磁盘性能分析</strong></p>
<ul>
<li>vmstat<ul>
<li>正在等待的IO任务数、每秒读写磁盘块数</li>
</ul>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210830123620.png" alt="image-20210830123620336"></p>
<ul>
<li>iostat <code>专业分析IO性能的工具</code><ul>
<li>安装：sudo yum install sysstat</li>
<li>使用：iostat（-c，-d）</li>
</ul>
</li>
<li>iotop<ul>
<li>进程维度的IO情况分析</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">操作系统——内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-25 14:23:09" itemprop="dateModified" datetime="2021-10-25T14:23:09+08:00">2021-10-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="一、内存基础"><a href="#一、内存基础" class="headerlink" title="一、内存基础"></a>一、内存基础</h2><h3 id="1-1问题"><a href="#1-1问题" class="headerlink" title="1.1问题"></a>1.1问题</h3><ol>
<li>什么是内存，它在计算机中的作用</li>
<li>内存的结构是怎样的，它是如何分区的</li>
<li>分区之后，应采取怎样的策略来给进程分配内存空间（放置算法或者说分配策略）</li>
</ol>
<h3 id="1-2解答"><a href="#1-2解答" class="headerlink" title="1.2解答"></a>1.2解答</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>重定位</strong>：进程被换出后再次换进到内存中，会分配到一个不同的内存区域上，因此原先的指令就要做一个映射</li>
<li><strong>保护</strong>：每个进程的内存区域不应该被其他进程所干扰，处理器的硬件层面上应该提供这个判断</li>
<li><strong>共享</strong>：多个程序执行时，可能会有共享一些数据的需求，操作系统需要管理这块共享内存</li>
<li><strong>逻辑组织与物理组织</strong>：逻辑地址连续，物理地址不连续</li>
</ul>
<h4 id="分区的方式"><a href="#分区的方式" class="headerlink" title="分区的方式"></a>分区的方式</h4><p>简单来看，有两种分区的方式，即<strong>固定分区</strong>和<strong>动态分区</strong>。</p>
<p><strong>固定分区</strong></p>
<ul>
<li>定义：内存分为固定大小的块，每块可以相同，也可以不同</li>
<li>缺点<ul>
<li>会有大量的内部碎片产生</li>
<li>限制了活动进程的最大数量</li>
</ul>
</li>
<li>优点：分配简单</li>
</ul>
<p><strong>动态分区</strong></p>
<ul>
<li>定义：根据进程大小来按需分配</li>
<li>缺点：随着进程的换进换出，会产生外部碎片</li>
<li>特点：需要考虑内存的<strong>分配策略</strong>，下面介绍</li>
</ul>
<p><strong>内存分配策略</strong></p>
<ul>
<li>首次适配：从头开始，匹配满足条件的第一块内存</li>
<li>下次适配：从上次分配的地方开始，匹配满足条件的第一块内存</li>
<li>最佳适配：全量扫描，找到最佳的内存块进行分配</li>
</ul>
<h4 id="一种特殊的分区方式：伙伴系统"><a href="#一种特殊的分区方式：伙伴系统" class="headerlink" title="一种特殊的分区方式：伙伴系统"></a>一种特殊的分区方式：伙伴系统</h4><p><strong>描述</strong></p>
<ol>
<li>最开始将内存看成一块整体</li>
<li>当请求内存大小为<code>x</code>时，将一块内存分成等大的两块，即$2^n=2^{n-1} + 2^{n-1}$</li>
<li>直到满足$2^{k-1}&lt;x&lt;=2^k$时，把大小为$2^k$的内存块分配出去。</li>
</ol>
<p><strong>思路：把大于所需内存的第一个2的整数次幂大小的内存块分配出去。</strong></p>
<h4 id="分页、分段"><a href="#分页、分段" class="headerlink" title="分页、分段"></a>分页、分段</h4><p>不管是分页还是分段，都需要将<code>逻辑地址</code>转化为<code>物理地址</code></p>
<p><strong>逻辑地址</strong>：包含了页号和页偏移</p>
<p><strong>物理地址</strong>：物理页的起始地址+页内偏移量</p>
<p>借助<code>页表</code>或<code>段表</code>，通过映射得到物理页的位置，然后再加上页内偏移量就得到最终的物理地址。</p>
<h4 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h4><p><strong>OPT</strong></p>
<ul>
<li>描述：最优策略，置换下次使用距离当前最久的那一页</li>
<li>特点：理想的算法，一般作为参考</li>
</ul>
<p><strong>FIFO</strong></p>
<ul>
<li>描述：先来的页先置换，其实就是把驻留在内存中最久的页置换出去</li>
<li>缺点：对于间隔一段时间后重复使用的页，不太友好</li>
</ul>
<p><strong>LRU</strong></p>
<ul>
<li>描述：把最久未使用的页置换出去</li>
<li>缺点：实现复杂，维护困难（需要维护一个栈）</li>
</ul>
<p><strong>LFU</strong></p>
<ul>
<li>描述：把使用频率最低的页置换出去</li>
<li>缺点：对局部性原理不友好，刚置换进来的页可能又被置换出去了</li>
</ul>
<p><strong>时钟</strong></p>
<ul>
<li>描述：对FIFO的一种优化，同时又希望性能可以逼近LRU</li>
<li>特点：实现相对简单一些</li>
<li>算法<ul>
<li>每页加入内存时，<code>使用位</code>置1</li>
<li>用到某页时：<code>使用位</code>置1</li>
<li>缺页时：从指针开始遍历，遇1置0，遇0则直接置换；然后指针指向下一页，作为下次缺页时的起点</li>
</ul>
</li>
</ul>
<h2 id="二、虚拟内存"><a href="#二、虚拟内存" class="headerlink" title="二、虚拟内存"></a>二、虚拟内存</h2><h3 id="2-1问题"><a href="#2-1问题" class="headerlink" title="2.1问题"></a>2.1问题</h3><ol>
<li>对虚拟内存的简单理解，为什么会有虚拟内存</li>
<li>虚拟内存如何实现虚拟地址到物理地址的转换，转换的过程是怎样的</li>
</ol>
<h3 id="2-2解答"><a href="#2-2解答" class="headerlink" title="2.2解答"></a>2.2解答</h3><h4 id="虚拟内存的由来"><a href="#虚拟内存的由来" class="headerlink" title="虚拟内存的由来"></a>虚拟内存的由来</h4><p>上面提到的分页分段以及内存分配是最简单粗暴的方式，即把整个进程加入到内存中。</p>
<p>事实上，我们只需把进程中<strong>要执行的部分</strong>添加到内存中即可，剩余的可以留在磁盘等辅存中。</p>
<p>通过这种方式，我们可以给进程和用户一种<strong>错觉</strong>，让它们觉得每个人都有4GB的内存空间，而实际上在进程执行时，<strong>内存中只保留了正在执行和将要执行的部分页</strong>，其余页都在磁盘中，等待置换。这就是<strong>虚拟内存</strong>的思想</p>
<h3 id="虚拟地址转化为物理地址"><a href="#虚拟地址转化为物理地址" class="headerlink" title="虚拟地址转化为物理地址"></a>虚拟地址转化为物理地址</h3><p><strong>普通页表、多级页表</strong></p>
<ul>
<li>描述：页表项和虚拟地址一一对应</li>
<li>理解：假设页号为5，那么在页表中查找5对应的页框号，因此<strong>虚拟地址越大，页表就会越大。</strong></li>
</ul>
<p><strong>倒排页表</strong></p>
<ul>
<li>描述：维护哈希表和倒排表。</li>
<li>理解：以页号为键，在哈希表中得到一个指针，指向倒排表；而倒排表中每项与物理页框一一对应，因此<strong>物理内存越大，页表越大</strong></li>
</ul>
<h3 id="转化过程"><a href="#转化过程" class="headerlink" title="转化过程"></a>转化过程</h3><p>省略了TLB缓冲区和内存高速缓存……</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210831205328.png" alt="image-20210831205328599"></p>
<h2 id="三、Linux内存管理"><a href="#三、Linux内存管理" class="headerlink" title="三、Linux内存管理"></a>三、Linux内存管理</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/149581303">linux内存管理</a></p>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><p>使用3级页表，分别是全局目录，页中间目录和页表。</p>
<p>对于某些已有两级分页的硬件，页中间目录大小会设置为1</p>
<h4 id="页面分配"><a href="#页面分配" class="headerlink" title="页面分配"></a>页面分配</h4><p>分配内存采用<code>伙伴算法</code>，维护多种不同大小的页框组</p>
<p><strong>内核内存分配</strong></p>
<ul>
<li>描述：伙伴算法分配的最小空间就是一页，但是内核所需的空间可能经常小于1页。因此在分配小块内存时，使用了<code>slab</code>分配方案。</li>
<li>大致介绍：<ul>
<li>slab是对伙伴算法的补充，维护了一个小内存的缓冲区。</li>
<li>当申请小块内存时，从缓冲区中取</li>
<li>释放时也回到缓冲区中，而不是交给伙伴算法中的链表。</li>
</ul>
</li>
</ul>
<h4 id="页置换算法"><a href="#页置换算法" class="headerlink" title="页置换算法"></a>页置换算法</h4><p><strong>1.时钟算法</strong></p>
<p>Linux2.6.28以前使用的是基于LFU的时钟算法，通过<code>使用位</code>来计数；每次访问某页时，使用位加1。</p>
<p>此外，Linux会在后台周期性的扫描页池，将扫描到的页<code>使用位减一</code>，这样<code>使用位为0</code>的页就是最适合置换的页。</p>
<p><strong>缺点：周期性的扫描会占用处理器的时间</strong></p>
<p><strong>2.两级LRU算法</strong></p>
<p>从Linux2.6.28开始，使用两级的LRU算法。</p>
<p>算法：</p>
<ul>
<li>维护两个链表，分别代表不活跃和活跃的内存页</li>
<li>在超时时间内，一个页如果被访问两次，就会从<code>不活跃链表</code>移到<code>活跃链表</code>中</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210906112000.png" alt="image-20210906111953408"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%80%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%80%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">操作系统——系统调用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-15 09:56:16" itemprop="dateModified" datetime="2021-09-15T09:56:16+08:00">2021-09-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="阅读文章"><a href="#阅读文章" class="headerlink" title="阅读文章"></a>阅读文章</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenwb89/p/operating_system_002.html">操作系统篇之一：浅谈实模式与保护模式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenwb89/p/operating_system_003.html">操作系统篇之二：分段机制与GDT|LDT</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenwb89/p/operating_system_004.html">操作系统篇之三：调用门与特权级（CPL、DPL和RPL)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiading/p/12606978.html">操作系统篇之四：中断和系统调用</a></p>
<p><strong>「操作系统」</strong>向下管理底层硬件，向上提供计算机的基础服务，如文件管理、内存管理、进程管理等等。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><blockquote>
<p>系统调用是操作系统提供给上层的功能的接口</p>
</blockquote>
<h3 id="为什么会有系统调用？"><a href="#为什么会有系统调用？" class="headerlink" title="为什么会有系统调用？"></a>为什么会有系统调用？</h3><p><strong>思考</strong></p>
<p>运行时数据都在内存中，用户为什么要通过系统调用，而不是直接去内存中取？</p>
<p><strong>解答</strong></p>
<p>是为了数据安全和操作的难易程度考虑。</p>
<p>如果用户可以直接操作内存，那么对内存地址的改动，就很有可能会造成应用程序的崩溃，早期的操作系统经常蓝屏死机就是这个原因。</p>
<h3 id="怎样隔离用户直接操作内存的情况"><a href="#怎样隔离用户直接操作内存的情况" class="headerlink" title="怎样隔离用户直接操作内存的情况"></a>怎样隔离用户直接操作内存的情况</h3><p>实模式与保护模式</p>
<p>系统刚开机或重启那会儿处于实模式，之后便处于保护模式中。</p>
<p>而在保护模式中，有一个叫做<code>特权级</code>的概念，其中，</p>
<ul>
<li>CPL：当前进程的权限级别</li>
<li>DPL：某个内存段的固定权限级别</li>
<li>RPL：进程请求某个内存段时的权限</li>
</ul>
<p><del>如果进程在内核态，它的CPL就会变成0；当它访问某块DPL为3的内存时，</del></p>
<h3 id="既然隔离了，怎样进入内核态呢"><a href="#既然隔离了，怎样进入内核态呢" class="headerlink" title="既然隔离了，怎样进入内核态呢"></a>既然隔离了，怎样进入内核态呢</h3><p>对于<code>Intel x86</code>，硬件提供了中断指令<code>int</code></p>
<p>当发生系统调用时，C语言会把代码解析成汇编指令，然后通过中断指令进入内核态（实际上是修改DPL为3，然后再改回来，从而得到权限）</p>
<h3 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h3><ol>
<li><p>保存<strong>系统调用号</strong>和<strong>输入参数</strong></p>
</li>
<li><p>模式切换，由<strong>用户态</strong>切换到<strong>内核态</strong></p>
</li>
<li><p>找到并执行对应服务<strong>例程</strong></p>
<ul>
<li><p><code>例程</code>：操作系统封装的各类服务API</p>
</li>
<li><p><code>过程</code>：通过<code>system_call</code>内核函数在<code>系统调用表</code>中找到<code>系统调用号</code>对应的服务例程</p>
</li>
</ul>
</li>
<li><p>处理完毕后返回<strong>用户态</strong></p>
</li>
</ol>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><blockquote>
<p>系统调用其实就是<strong>软中断</strong>的一种具体实现。</p>
</blockquote>
<h3 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h3><p>中断可以分为同步中断和异步中断。</p>
<ul>
<li>异步中断：硬件设备产生的中断</li>
<li>同步中断（异常）：由CPU控制单元发出的中断，且要在指令执行完毕后才会发出</li>
</ul>
<h3 id="硬中断的执行过程"><a href="#硬中断的执行过程" class="headerlink" title="硬中断的执行过程"></a>硬中断的执行过程</h3><p><strong>中断产生：</strong></p>
<ul>
<li>情况：IO中断（完成IO）、失效中断（断电）</li>
<li>传输：上述情况发生时，硬件产生<strong>电信号</strong>，通过中断线到达<strong>中断控制器</strong>中。</li>
</ul>
<p><strong>中断处理：</strong></p>
<ul>
<li>中断控制器将<strong>中断类型号</strong>发送给CPU，请求执行</li>
<li>CPU查询<strong>中断向量表</strong>，找到对应的中断服务例程并执行</li>
<li>例程调用对应的<strong>设备驱动</strong>与外部设备进行通信和处理</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aurora"
      src="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
  <p class="site-author-name" itemprop="name">aurora</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">144</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Aurora-Ze" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Aurora-Ze" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:88775682whz@gmail.com" title="E-Mail → mailto:88775682whz@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      
      
       <div>
          <iframe class="cc-license motion-element" frameborder="no" border="0" marginwidth="0" marginheight="0" width="280" height="86" src="//music.163.com/outchain/player?type=2&id=3986241&auto=1&height=32"></iframe>
       </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aurora</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <span class="post-count">| 博客共95.3k字</span>
  </div>-->


<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("04/07/2021 15:54:40");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

        








      </div>
    </footer>
  </div>

  


  <script src=""></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/darkmode-js.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>


<script>
var options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: 'transparent', // default: '#fff'
  backgroundColor: 'transparent',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: true, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}
const darkmode = new Darkmode(options);
darkmode.showWidget();
</script>
<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
