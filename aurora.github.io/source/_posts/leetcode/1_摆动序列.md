---
title: 摆动序列
categories: leetcode
tags:
	- 动态规划
	- 贪心
---

# 摆动序列

[题目请看这里](https://leetcode-cn.com/problems/wiggle-subsequence/)

## 题目

> 连续数字的差在正数和负数之间交替，则数字序列就称为**摆动序列**

给定整数序列，返回其摆动序列的最长长度。

## 示例

[1,7,4,9,2,5]是长度为6的摆动序列

## 解法一：动态规划

定义两种状态，分别为up[i]和down[i]

遍历时分别进行状态转移，最后返回两者中的较大值。

```Java
public int wiggleMaxLength(int[] nums) {
	int len = nums.length;
	int[] up = new int[len];
	int[] down = new int[len];
	// init
	up[0] = 1; down[0] = 1;

    for (int i = 1; i < len; ++ i) {
        if (nums[i] == nums[i-1]) {
            up[i] = up[i-1];
            down[i] = down[i-1];
        } else if (nums[i] > nums[i-1]) {
            down[i] = down[i-1];
            up[i] = Math.max(down[i-1] + 1, up[i-1]);
        } else {
            up[i] = up[i-1];
            down[i] = Math.max(up[i-1] + 1, down[i-1]);
        }
    }
    return Math.max(up[len-1], down[len-1]);
}

```

**空间优化**

因为每次状态转移只和上一次相关，所以可以用变量代替数组

```Java
public int wiggleMaxLength(int[] nums) {
    int up = 1;
    int down = 1;

	for (int i = 1; i < nums.length; ++ i) {
	    if (nums[i] > nums[i-1]) {
	        up = down + 1;
	    } else if (nums[i] < nums[i-1]) {
	        down = up + 1;
	    }
	}
	return Math.max(up, down);
}

```

## 解法二：贪心

忽略谷和峰之间的数字，每次发生摆动时，才进行加一

```Java
    public int wiggleMaxLength(int[] nums) {
        int len = nums.length;
        if (len < 2) return len;
		// 从头开始，找到前后不相同的元素
        int index = 1;
        while (index < len && nums[index] == nums[index-1]) index ++;
        if (index == len) return 1;
        // 初始化
        boolean isUp = nums[index] - nums[index-1] > 0 ? true : false;
        int count = 2;
        // 开始计数
        for (int i = index + 1; i < len; ++ i) {
            if ((nums[i] > nums[i-1] && !isUp) || (nums[i] < nums[i-1] && isUp)) {
                count ++;
                isUp = !isUp;
            }
        }
        return count;
    }
```

