---
title: 类文件结构
categories: JVM
cover: https://gitee.com/aurora1004/pictures/raw/master/wps.jpg
top_img: https://gitee.com/aurora1004/pictures/raw/master/%E5%8D%95%E8%AF%8D,%E6%96%87%E5%AD%97,%E6%B3%A2%E5%85%B0,%E5%A4%9A%E8%89%B2%E7%9A%84,%E5%AD%97%E6%AF%8D,%E5%AD%97%E5%85%B8,%E6%B0%B4%E5%B9%B3%E7%94%BB%E5%B9%85,%E8%BF%9B%E8%A1%8C%E4%B8%AD,%E7%94%B5%E5%AD%90%E5%9F%B9%E8%AE%AD,%E8%AF%AD%E9%9F%B3%E6%8B%BC%E5%86%99.jpg
top: 99
---

## 类文件结构

### 一、背景

我们所写的程序想要被计算机执行，有两种方式，第一种是**编译成由0和1组成的二进制格式，让计算机执行。**

而随着虚拟机的蓬勃发展，大量的程序语言建立在虚拟机的基础上，所以产生了第二种编译方式，即：

**编译成与操作系统和机器指令集无关的、平台中立的文件存储格式**

这也正是`字节码`文件的由来。

### 二、介绍

Java文件通过编译器编译，得到**Class文件(字节码文件)**，然后再通过JVM来执行。

但是为了让虚拟机知道这是字节码文件，就需要严格定义字节码文件的格式

因此在Class文件中，它的每个数据项的顺序和数量，甚至存储的字节序（统一使用Big Endian），都是被严格限定的。

下面我们将介绍字节码文件的具体结构。

### 三、文件格式

##### 数据类型

**「Class文件」**采用一种类似于C语言结构体的伪结构来存储数据。

数据类型只有两种，「无符号数」和「表」

- 无符号数

  用`u1,u2,u4,u8`分别来表示`1，2，4，8`个字节

  可以用来描述**数字、索引引用、数量值或UTF-8编码的字符串值**

- 表

  由多个无符号数或表构成的复合数据类型

  为便于区分，表名一般以`_info`结尾

因为存在同一类型但数量不确定的数据，所以一般会用一个前置的容量计数器来表示数量。

### 四、详细介绍

##### ①魔数

| 类型 | 名称  | 数量 |
| :--: | :---: | :--: |
|  u4  | magic |  1   |

Class文件的头四个字节称为**Magic Number**，用来**确认文件是否是JVM所能接收的Class文件**

使用魔数的方式来区分文件类型，这种方式在GIF和JPEG中也可以看到。

至于使用头字节而不是文件的扩展名来判断文件类型，主要还是为了安全考虑，毕竟啥文件改了后缀也能变成Class文件。

Class文件魔数的具体取值为`0xCAFEBABE`，即咖啡宝贝

##### ②主版本号和次版本号

| 类型 |     名称      | 数量 |
| :--: | :-----------: | :--: |
|  u2  | minor_version |  1   |
|  u2  | major_version |  1   |

紧跟着魔数的四个字节分别表示**Minor Version**和**Major Version**

JDK1.1以后，每个大版本都会让主版本号加一。

高版本的JDK能向下兼容低版本的Class文件，但是版本比它高的Class就不行，因为《Java虚拟机规范》要求了虚拟机必须拒绝执行超过其版本号的Class文件。

##### ③常量池

|  类型   |        名称         |          数量           |
| :-----: | :-----------------: | :---------------------: |
|   u2    | constant_pool_count |            1            |
| cp_info |    constant_pool    | constant_pool_count - 1 |

由`constant_pool_count`和`constant_pool`构成。

**constant_pool_count（u2类型）**

因为常量池的容量是不固定的，所以入口处有u2类型的数据，来表示「常量池的容量」。

注意，它是从1开始计数的，所以常量数量为$count - 1$

这样做的原因，据设计者说，是为了**能够让以后某些指向常量池的索引值的数据表达“不引用任何一个常量池项目”的含义。**

**constant_pool（cp_info类型）**

常量池中主要存放两大类常量：**字面量**和**符号引用**

- **字面量**

  文本字符串，声明为final的常量值等

- **符号引用**

  类、接口的全限定名

  字段的名称和描述符

  方法的名称和描述符等

常量池中的每个常量都是一个表，截至JDK13，共有17种不同类型的常量。

这17类表有一个共同特点，即**第一个字节都表示tag标志位，代表当前常量属于哪个常量表**，后面的字节根据不同的表而变化。

##### ④访问标志

| 类型 |     名称     | 数量 |
| :--: | :----------: | :--: |
|  u2  | access_flags |  1   |

常量池结束之后的两个字节，用来表示类或接口的访问标志

可以取的值有：public、final、super、interface等共9个

##### ⑤索引集合

| 类型 |       名称       |       数量       |
| :--: | :--------------: | :--------------: |
|  u2  |    this_class    |        1         |
|  u2  |   super_class    |        1         |
|  u2  | interfaces_count |        1         |
|  u2  |    interfaces    | interfaces_count |

类索引和父类索引都占两个字节，而接口索引是一组数据的集合。

这些索引用来确认类的全限定名、父类的全限定名以及实现的接口的名称。

**具体确认过程如下：**

![Snipaste_2021-04-25_17-01-01](https://gitee.com/aurora1004/pictures/raw/master/Snipaste_2021-04-25_17-01-01.png)

##### ⑥字段表集合

|    类型    |     名称     |     数量     |
| :--------: | :----------: | :----------: |
|     u2     | fields_count |      1       |
| field_info |    fields    | fields_count |

包含了类或接口声明的类级变量（static）和实例变量，但不包含方法内的局部变量。

我们可以先思考下，一个字段拥有什么属性？

- 修饰符，public、static、volatile等
- 名称，字段名
- 类型，是什么数据类型
- 属性，如果是集合类型，里面包含的其他属性

根据上面罗列出来的信息，我们可以总结出字段表的内部结构

|      类型      |       名称       |       数量       |    描述    |
| :------------: | :--------------: | :--------------: | :--------: |
|       u2       |   access_flags   |        1         | 字段修饰符 |
|       u2       |    name_index    |        1         |  简单名称  |
|       u2       | descriptor_index |        1         |   描述符   |
|       u2       | attributes_count |        1         |            |
| attribute_info |    attributes    | attributes_count |            |

这里解释下前面提到过的三个名词，全限定名、简单名称和描述符。

- **全限定名**

  com/edu/neu/TestApplication;

  代表类的全限定名

- **简单名称**

  sort：sort()方法的简单名称

  arr：arr字段的简单名称

- **描述符**

  描述符和上述两者相比更加复杂一些。它是用来描述**字段的数据类型**、**方法的参数列表**和**返回值**。

**描述字段时**

| 标识字符 |      含义      | 标识字符 |              含义              |
| :------: | :------------: | :------: | :----------------------------: |
|    B     |  基本类型byte  |    J     |          基本类型long          |
|    C     |  基本类型char  |    S     |         基本类型short          |
|    D     | 基本类型double |    Z     |        基本类型boolean         |
|    F     | 基本类型float  |    V     |          特殊类型void          |
|    I     |  基本类型int   |    L     | 对象类型，如Ljava/lang/Object; |

**基本数据类型和void都用大写字母来表示，对象类型则用L加上对象的全限定名来表示，数组类型在最前面加上若干个[**

对于`java.lang.String[][]`类型，它的描述符将是`[[Ljava/lang/String;`

对于`int[]`，它的描述符将是`[I`

**描述方法时**

按照**先参数列表**、**后返回值**的顺序进行描述，参数列表要放在`()`中。

对于`int indexOf(char[] source, int srcOffset, int srcCount, char[] target, int tarOffset, int tarCount, int fromIndex)`，描述符将是`([CII[CIII)I`

##### ⑦方法表集合

|    类型     |     名称      |     数量      |
| :---------: | :-----------: | :-----------: |
|     u2      | methods_count |       1       |
| method_info |    methods    | methods_count |

方法表和上述字段表集合几乎一致，所以关于表结构这部分不再介绍。

但是如果只是和字段一样的话，那么它的代码怎么保存呢？

事实上，方法体经过编译器编译成字节码指令后，存放在方法的属性表集合中一个名为`Code`的属性里，我们在将属性表时，会介绍这些。

##### ⑧属性表集合

|      类型      |       名称       |       数量       |
| :------------: | :--------------: | :--------------: |
|       u2       | attributes_count |        1         |
| attribute_info |    attributes    | attributes_count |

与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序。

在最新的《Java虚拟机规范》的JavaSE12版本中，预定义属性达到29项。可想而知，它的内容非常多。

下面我们介绍下属性表的基本结构

| 类型 |         名称         |       数量       |
| :--: | :------------------: | :--------------: |
|  u2  | attribute_name_index |        1         |
|  u4  |   attribute_length   |        1         |
|  u1  |         info         | attribute_length |

一个符合规范的属性表，它的属性名应该从常量池中引用`CONSTANT_Utf8_info`类型的常量来表示，而属性值的结构是完全自定义的，只需要通过一个`u4`长度属性去说明属性值所占用的位数即可。

至于具体的属性值结构，可参考《深入理解Java虚拟机》P233。