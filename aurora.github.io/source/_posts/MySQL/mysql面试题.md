---
title: 笔记3
categories: MySQL
---

#### 一、索引的类别

1. **主键索引**（非空、唯一）

设定为主键后，自动建的索引

> **PRIMARY KEY**（id）

2. **单列索引**（可空，不唯一）

> **CREATE** **INDEX** name **ON** table(customer_name)

3. **唯一索引**（可空）

> **CREATE** **UNIQUE INDEX** name **ON** table(customer_name)

4. **联合索引**

多个单列索引的开销要大于复合索引，所以数据量大时，用复合索引更好。

#### 二、最左前缀，最右前缀，为什么要最左前缀

最左前缀匹配一般是针对联合索引来说的

例如联合索引（a，b，c），sql语句的条件要是a、ab、abc、ac时，才会触发索引。

索引在构建时，就是按照从左到右递增的顺序来的，如果查找时不按这个顺序，就只能全表扫描了。

#### 三、mysql隔离级别，默认隔离级别，底层实现（MVCC+next-key锁）

首先，弄清楚几个**概念**（事务并发情况下）

1. **脏读**

> 读到了**其他事务**未提交的数据
>
> 未提交意味着数据可能会变化，不代表最终存储的数据

2. **可重复读**

> 在一个事务中，两次任意时刻读的数据是一致的

3. **不可重复读**

> 和可重复读相反，一次事务内，两次读到的数据不一致

4. **幻读（注意）**

> 和不可重复读类似，但是针对插入数据来说的
>
> 即前后两次查询间隔中，其他事务插入了一条符合条件的数据，导致前后查询不一致
>
> **因为插入数据是对表来说的，所以行锁不能避免幻读，表锁才行**

接下来介绍四种事务隔离级别：

|         隔离级别         |                     描述                     | 脏读 | 不可重复读 | 幻读 |
| :----------------------: | :------------------------------------------: | :--: | :--------: | :--: |
|       读未提交 RU        |         可以读到其他事务未提交的数据         |  是  |     是     |  是  |
| 读已提交（不可重复读）RC |            只能读到已经提交的数据            |  否  |     是     |  是  |
|       可重复读 RR        | 在当前事务持续时，禁止其他事务对此字段的更新 |  否  |     否     |  是  |
|          串行化          |       最**严格**，要求所有事务串行执行       |  否  |     否     |  否  |



#### 四、innodb和myisam特点和区别

| 区别\引擎  | Innodb         | myisam                       |
| ---------- | -------------- | ---------------------------- |
| 事务       | 支持           | 不支持                       |
| 数据和索引 | 在一起，聚簇   | 分离的，B+树叶子存储数据地址 |
| 支持锁     | 支持行锁和表锁 | 只支持表锁                   |



#### 五、行锁和表锁

行锁：锁一行或多行记录，行锁是基于索引加载的，加在索引匹配到的行上。

表锁 ：锁定整张表，属于全表扫描时做的。

**对比：**

行锁并发性能高，冲突率低，但会发生死锁

表锁性能低，冲突率高，锁定的范围大