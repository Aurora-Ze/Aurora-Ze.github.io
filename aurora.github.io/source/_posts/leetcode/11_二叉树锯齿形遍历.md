---
title: 二叉树锯齿形遍历
categories: leetcode
tags: [树,BFS]
---

# 二叉树锯齿形遍历

[103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

### 描述

给定一颗二叉树，按照从左到右，再从右到左的层序进行遍历。

在层序遍历基础上，需要更改遍历的方向，因此一个普通的队列满足不了，需要双端队列来存储。

### 代码

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        Deque<TreeNode> dQueue = new LinkedList<>();
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
    	// 初始化一些数据
        dQueue.addFirst(root);
        int size;
        List<Integer> tmp;
        boolean isCurLeft = true;// 表示当前一层是否是从左到右遍历的
		// 队列为空时，完成遍历
        while (!dQueue.isEmpty()) {
            tmp = new ArrayList<>();
            // 按照size来对这一层完成遍历
            size = dQueue.size();
            while (size > 0) {
                // 从左往右遍历时，操作与层序遍历的一致
                if (isCurLeft) {
                    root = dQueue.removeFirst();
                    tmp.add(root.val);
                    if (root.left != null) {
                        dQueue.addLast(root.left);
                    }
                    if (root.right != null) {
                        dQueue.addLast(root.right);
                    }
                } else {
                // 从右往左时，需要从后面开始读元素，并且按先右后左的顺序添加到队列头部
                    root = dQueue.removeLast();
                    tmp.add(root.val);
                    if (root.right != null) {
                        dQueue.addFirst(root.right);
                    }
                    if (root.left != null) {
                        dQueue.addFirst(root.left);
                    }
                }
                size --;
            } 
            // 把这一层遍历的结果添加到最终数组里
            result.add(tmp);
            isCurLeft = !isCurLeft;
        }
        return result;
    }
```

