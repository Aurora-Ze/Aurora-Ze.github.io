---
title: Java锁机制
categories: JVM
---

# 一、同步方式

涉及到线程安全的问题时，往往有两种方式进行数据的同步，即`互斥同步`和`非阻塞同步`。

- 互斥同步

  悲观的思想，认为`加锁`才能保证数据的线程安全性

  线程挂起、唤醒的操作需要由操作系统来进行，因此互斥同步需要在用户态和内核态切换，开销较大

- 非阻塞访问

  乐观思想，当获取不到锁时，重复地去获取

  这是基于硬件指令集的发展而来的，因为有了`Compare-and-Swap`指令

# 二、锁优化

在这里，锁不仅仅指互斥同步的锁，还包含了一些不用互斥、阻塞的锁。

### 自旋锁与自适应自旋

当一个线程获取不到锁时，会在处理器中自旋一段时间，避免频繁地挂起、阻塞。

**优化版：根据上次情况，适当改变自旋次数**

如果上次获取过这个对象的锁，那么这次获取的机会也大，自旋次数可以增加一些

### 锁消除

检测到持有锁的对象没有发生逃逸，不会存在竞争关系，可以消除当前对象的锁

### 锁粗化

多个锁变为一个锁

------

后面的锁会提到底层实现，所以先需要了解一些前缀知识。

### 知识

对象头包含`mark word`和标记，其中`mark word`包含了对象的哈希码、回收年龄等。

### 轻量级锁

前面提到互斥锁需要切换到内核态，开销较大。所以我们思考，能不能用非阻塞的方式来实现锁机制。

而轻量级锁就是一种基于`CAS`的锁机制。

**加锁过程**

1. 在线程的栈帧中开辟`Lock Record`空间，记录对象头中`mark word`内容

2. 用`CAS`操作把指向`Lock Record`的指针替换对象头中的`mark word`

   如果成功，则表示获取到锁，可以执行同步代码块

   如果失败，检验一下指针是不是指向自己栈帧的，来判断锁是不是自己的		

**释放锁过程**

1. 用`CAS`操作尝试把`Lock Record`的内容覆盖到`对象头`中

   如果成功，释放成功

   如果失败，释放并唤醒其他线程???

如果有两个以上线程竞争，就会进行`锁膨胀`，变为重量级锁

轻量级锁在有竞争时，既有互斥的开销，还要进行CAS，所以存在竞争时性能较差

### 偏向锁

思想：绝大多数情况下，资源都不存在竞争。

偏向锁使用了更加轻量级的方式，它连CAS都不用进行，直接令当前线程获取锁。

但是一旦发生了竞争，就要根据是否加锁，来变为`无锁`或`轻量级锁`状态

### 重量级锁

多个线程竞争时，轻量级锁会膨胀为重量级锁，它就表示以前的互斥锁。
