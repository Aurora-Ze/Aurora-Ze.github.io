---
title: 字节码指令
categories: JVM
cover: https://gitee.com/aurora1004/pictures/raw/master/92305518.jpg
top_img: https://gitee.com/aurora1004/pictures/raw/master/92305518.jpg
top: 101
---

# 字节码指令

## 一、结构

### 1.1 简单定义

> Java虚拟机的指令是由**一个字节长度**的、**代表着某种特定操作**含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。

简单来说，指令就是由一个字节的**操作码**和若干个**参数**构成。

另外， 因为Java虚拟机采用的是**面向操作数栈**的架构，所以大多数指令只有一个操作码，而操作数被放在了操作数栈中。

### 1.2 特点

从上面的定义中，我们可以发现，

- 操作码总数不能超过256

  既然操作码只占了一个字节，那么`1字节 = 8比特，2^8 = 256`，即最多能表示`256`条指令

- 编译后Class文件中代码的操作数长度不对齐

这种字节码结构有着明显的优势和劣势：

- 优势

  省略了大量的填充和间隔符号，编译代码更加精简

- 劣势

  处理超过一个字节的数据时，会因为重建而损失性能

### 1.3 执行模型

不考虑异常处理的话，可以用以下代码来表示Java虚拟机的解释器的执行过程

```java
do {
	自动计算PC寄存器的值加1
	根据PC寄存器指示的位置，从字节码流中取出操作码
	if (字节码存在操作数) {
		从字节码流中取出操作数
	}
	执行操作码所定义的操作
} while (字节码流的长度 > 0);
```

## 二、类别

在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。

前面我们知道了指令集不能超过256条，而Java的数据类型有很多，如果针对每一种类型，都划分出专门的指令去操作它，可能就会溢出。

那么Java虚拟机是怎么做的呢？

在将这些之前，我们先要了解两个概念。

### 2.1 符号扩展和零位扩展

- 符号扩展，扩展时，前面全部补上符号位

- 零位扩展，扩展时前面全部补零

我们用一个例子来表示说明一下这两个概念，假设现在有两个数`+3`和`-3`

它们用8位的原码表示分别是`00000011`和`10000011`

现在我们要把它扩展到用16位来表示，就会产生如下结果

| 数字 |     符号扩展     |     零位扩展     |
| :--: | :--------------: | :--------------: |
|  +3  | 0000000000000011 | 0000000000000011 |
|  -3  | 1111111110000011 | 0000000010000011 |

我们可以看到，对于正数而言，符号扩展和零位扩展是没有区别的；而负数的话就是扩展的数字不同。

这两个概念和我们所说的溢出又有什么关系呢？

**其实设计者为了让指令集不会溢出（或者说，复用一些指令），就让编译器在编译或运行时期，把byte和short类型的数据带符号扩展为int类型，把boolean和char类型数据零位扩展成int类型。**

这样就不必对这四个类型单独再分配一些指令来处理了。

### 2.2 加载和存储指令

加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。例如：

- 把一个局部变量加载到操作栈中：iload，fload，dload
- 把一个数值从操作数栈存储到局部变量表中：istore，lstore
- 把一个常量加载到操作数栈：bipush，sipush

### 2.3 运算指令

算术指令用于对操作数栈上的两个值进行某种特定运算，并把结果重新存入到操作栈顶。

这里有两个**注意点**，

**一是之前提过的byte，short，char，boolean是用int类型指令操作的**

**二是计算浮点数时，会碰到取舍的问题**

先介绍下**两种舍入模式**：

1. 向最接近数舍入
2. 向零舍入

浮点数之间的计算，采用第一种向最接近数舍入，如果是浮点数转整型，采用向零舍入模式

我们可以回想下，Java中浮点数之间计算后，结果并不是严格准确的；浮点数转整型，会丢弃小数部分；

这些都和舍入模式相匹配。

### 2.4 类型转换指令

用于对类型的**显式转换**；如果是隐式的（如int转long）就不用这些指令，因为虚拟机直接支持。

注意，转换时可能会出现不同的正负号，因为long转int是简单的丢弃多余的高位部分，所以如果原来是负数，转换后可能就是正数了。

对于浮点型的转换，

- 如果是NaN，则转成int或long的0
- 如果不是无穷大，则按向零舍入来取整
  - 如果取整后在范围内，则直接用
  - 如果不在范围内，根据符号取边界值

### 2.5 对象创建与访问指令

Java中的对象包括类实例和数组，创建他们所采用的字节码并不同。

对象创建完毕后，可以通过访问指令来获取对象实例（或数组实例）中的字段（或数组元素）。

### 2.6 操作数栈管理指令

用于管理操作数栈中的元素

### 2.7 控制转移指令

控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令的下一条指令继续执行程序。

### 2.8 方法调用和返回指令

方法调用（分派、执行过程）将会在以后介绍。

方法调用有一系列以"invoke"开头的指令

返回有一系列以“return”结尾的指令

### 2.9 异常处理指令

关于异常，有三种来源：

- Java程序显式抛出，由athrow指令实现
- Java程序try catch处理，用`异常表`来完成
- 程序发生异常状况，自动抛出

### 2.10 同步指令

Java虚拟机支持两种同步：**方法级的同步**和方法内部**一段指令序列**的同步。

这两种同步都是靠管程（或者说锁）来实现的

#### 对于方法级的同步

它是隐式的，不用字节码指令来控制

因为方法的访问标志里如果声明了`ACC_SYNCHRONIZED`，就能够表示它是同步方法

然后在方法**执行线程**就要**先获取管程，才能执行方法**，方法结束后就会释放管程

#### 对于指令序列的同步

它通常是由`synchronized`关键字声明的

Java虚拟机的指令集中有`monitorenter`和`monitorexit`两条指令来支持`synchronized`

**实现`synchronized`指令，是`Javac编译器`和`Java虚拟机`共同协作的结果**

怎么理解这句话呢？

这就要谈谈这两个指令的用法了，这**两条指令**是加在同步指令序列的**两端**（开始和结束处），来**保证同步性**。

**如果指令正常执行，毫无疑问能配对成功。**

**如果执行到一般发生异常了，这时候被迫跳出同步指令序列，即只执行了`monitorenter`，而没有执行到`monitorexit`**

那怎么办呢？这就要看编译器了

> 在编译时，为了保证方法异常时，monitorenter和monitorexit指令仍能够配对，编译器自动生成一个异常处理程序，声明可处理所有的异常，然后只要在monitorexit后面再来条相同的指令，就能成功配对了。