---
title: (三).Executor框架介绍
description: 介绍了Java的线程池框架
categories: 线程和线程池
tags: 
	- 源码
	- 线程池
top: 50
---

# Executor

![executor_1](https://gitee.com/aurora1004/pictures/raw/master/20210430161315.PNG)

## 一、好处

Executor是Java提供的线程池框架

首先，介绍一下使用线程池的好处：

1. 降低资源消耗
2. 提高响应速度
3. 提高线程的可管理性

另外，还能避免**this逃逸问题**

> 即在构造器完成构造前，将自身的**this**引用向外抛出，并被其他线程获取到，这样其他线程有可能**访问**还**未初始化**的变量
>
> 详情请转至https://www.cnblogs.com/jian0110/p/9369096.html

## 二、组成

### 1.任务

任务有内外之分

**外部的任务**是指实现了Runnable接口的类，使用的时候把该类对象传进去，就会执行重写的run方法

传进去后，线程池会把该对象包装成Worker内部类的形式

### 2.任务的执行

执行的方式有两种，一种是直接调用**execute()**，这是**Executor接口**提供的方法

另一种是调用**ExecutorService**提供的**submit()**，它实际上也是调用前者执行的，区别在于它具有返回值，返回了一个Future对象。

### 3.结果

调用submit执行的话，会返回结果对象，它是实现Future接口的对象。

------



## 三、执行流程图

执行流程如下：

![executor_2](https://gitee.com/aurora1004/pictures/raw/master/20210430161525.png)

**1.**主线程创建实现**Runnable**或**Callable**接口的对象

**2.**把对象交给**Executor Service**的**execute**或**submit**方法，去执行

**3.**如果是采用submit的方式执行，那么会返回一个**Future**或**Future Task**对象

**4.**主线程可以执行FutureTask.get()来等待任务完成，也可以调用FutureTask.cancel()来取消任务

----



## 四、ThreadPoolExecutor类介绍

**线程池实现类 `ThreadPoolExecutor` 是 `Executor` 框架最核心的类。**

### 1.构造方法

共有四个构造方法，内部实际上都是用的同一个，如下

```java
public ThreadPoolExecutor(int corePoolSize,      // 核心线程数  一旦超过这个数，任务就会被添加到队列中等待
                          int maximumPoolSize,   // 最大线程数
                          long keepAliveTime,    // 存活的最长时间（指核心线程数之外的线程空闲后的存活时间）
                          TimeUnit unit,		 // 时间单位
                          BlockingQueue<Runnable> workQueue, // 阻塞队列
                          ThreadFactory threadFactory, // 工厂
                          RejectedExecutionHandler handler) { //拒绝策略
                          // ......
}
```

**参数说明**

|      参数       |                             描述                             |
| :-------------: | :----------------------------------------------------------: |
|  corePoolSize   |                          核心线程数                          |
| maximumPoolSize | 线程池最大线程数，当阻塞队列满时，线程数会从核心线程数变成最大线程数 |
|  keepAliveTime  |              非核心线程没有任务执行时的存活时间              |
|      unit       |                        存活时间的单位                        |
|    workQueue    |                           阻塞队列                           |
|  threadFactory  | 线程工厂，默认是Executors工具类提供的默认工厂，也可以自己实现ThreadFactory接口 |
|     handler     |                           拒绝策略                           |



### 2.状态

```Java
private static final int COUNT_BITS = Integer.SIZE - 3;      // 32 - 3 = 29
private static final int CAPACITY   = (1 << COUNT_BITS) - 1; // 2^29 - 1，即左边29个1
// 可以看出，状态是有序的，从小到大
private static final int RUNNING    = -1 << COUNT_BITS;   // -1补码表示为 111 
private static final int SHUTDOWN   =  0 << COUNT_BITS;	  //  0补码表示为 000 
private static final int STOP       =  1 << COUNT_BITS;   //  1补码表示为 001 
private static final int TIDYING    =  2 << COUNT_BITS;   //  2补码表示为 010 
private static final int TERMINATED =  3 << COUNT_BITS;   //  3补码表示为 011 

// int共有32位
// 前3位表示状态，后29位表示线程数量
```

**状态说明如下**

|      状态      |                             描述                             |      数值       | 结构          |
| :------------: | :----------------------------------------------------------: | :-------------: | ------------- |
|  **Running**   |               接受新任务并处理工作队列中的任务               |    $-2^{29}$    | $111+29个0$   |
|  **Shutdown**  |              不接受新任务，但仍处理队列中的任务              |       $0$       | $000+29个0$   |
|    **Stop**    |    不接受新任务，也不处理队列中的任务，中断正在执行的任务    |    $2^{29}$     | $001+29个0$   |
|  **Tidying**   | 任务已经终止，正在工作的线程数为0。线程来到这个状态时，会执行terminated() |    $2^{30}$     | $010+29个0$   |
| **Terminated** |                 完成terminated()后进入此状态                 | $3\times2^{29}$ | ${011}+29个0$ |

执行的**流程**如下所示

![executor_3](https://gitee.com/aurora1004/pictures/raw/master/20210430161844.png)



---

## 五、两种创建线程池的方式

Java提供了Executors工具类来快捷的创建线程池，主要有四种

但这是**不推荐**的做法。

| 线程池                   | 描述                                                       |                       特点                       |
| :----------------------- | :--------------------------------------------------------- | :----------------------------------------------: |
| ①newFixedThreadPool      | 固定大小，当线程不够时，任务就会放入到队列中等待           | 队列容量大，线程一直存在，直到显式的调用shutdown |
| ②newSingleThreadExecutor | 只有一个线程存在，当它终止时，就会产生一个新的线程去代替它 |                    队列容量大                    |
| ③newScheduledThreadPool  | 可以指定一段延迟时间，来让线程执行                         |                允许创建的线程数大                |
| ④newCachedThreadPool     | 根据需要创建线程，没有使用的线程在60秒后会终止并移出线程池 |                允许创建的线程数大                |

从上面可以看出：

1. ①②的工作队列容量是Integer.MAX_VALUE，当任务较多时可能会出现OOM
2. ③④允许创建的线程数量为Integer.MAX_VALUE，创建线程较多时，会出现OOM

其实**Executors**提供的**四种创建**线程池的方法，实际上是调用的**ThreadPoolExecutor**的构造方法

所以推荐使用**ThreadPoolExecutor**来**手动配置**线程池参数。



------



## 六、线程池大小

上面我们知道了应该**手动创建**线程池，那么线程池的大小该如何选择呢？

在这之前先介绍一下**上下文切换**的概念

### 1.上下文切换

**背景**

> 一个**CPU核心**在任意一个时刻**只能**由一个线程使用
>
> 而线程的数量是比CPU核心数要多的
> 
> 所以我们一般采取的策略是**时间片轮转**来为每个线程执行。

**定义**

>当一个线程的时间片用完后，就会把CPU让给其他线程执行
>
>在切换的过程中，我们需要保存当前任务的状态，以便下次切换回来时，可以很快地加载状态，这就叫**上下文切换**。

那么**上下文切换**和**线程池的大小**有什么关系呢？且听我慢慢道来。

如果线程池大小设置的**过大**，就会有很多线程在**竞争**CPU资源，**上下文切换**就会变得更加**频繁**，因此开销也会增大

如果**过小**，当遇到大量任务出现的情景时，就会造成任务堆积，甚至OOM

### 2.简单的公式

假设 `n` 表示**CPU**核心数

- CPU密集型任务 $n+1$ 

这些任务主要消耗的是CPU的计算资源（计算、排序等），把线程池大小设置成核心数加1

这样可以防止某个线程暂停时，CPU空闲下来的情况，或者是防止线程偶发的缺页中断。

- I/O密集型任务 $2n$

这类任务大部分时间都在进行I/O操作，在这段时间内，CPU可以交给其他线程去执行，所以可以多配一些线程

因为如果线程数较小的话，可能大部分线程都在执行I/O，那么CPU利用率就会降低。



-----



## 七、线程复用（源码分析）

### **什么是线程复用？**

> 以前使用Thread类去创建线程时，当线程执行完任务后，就会被销毁，就算把它挂起了，也处理不了其他任务。
>
> 而Executor框架提供的线程池，可以让一个线程在执行完任务后，再去执行其他任务，这就叫做**线程复用**。

ThreadPoolExecutor的一大特点就是**线程复用**。



首先放张图介绍下线程池执行任务的**流程**

<img src="https://gitee.com/aurora1004/pictures/raw/master/20210430162129.png" alt="executor_4" style="zoom:67%;" />

1. 工作线程数小于核心线程数

创建一个线程**作为核心线程**，去执行该任务。

2. 工作线程数大于等于核心线程数

把任务添加到阻塞队列中

3. 阻塞队列满了

创建线程作为**非核心线程**，去执行任务



既然想了解它的线程复用原理，就免不了看源码的过程，下面放出了一些关键方法。

### 1.execute()

之前提到，不管是用execute()还是submit()来执行任务，**实质**都是调用execute()来执行的

下面就来看看execute()的核心源码

```Java
int c = ctl.get();
if (workerCountOf(c) < corePoolSize) {   // 如果工作线程数小于核心线程数，就调用addWorker()
    if (addWorker(command, true))        // 该方法内部新建了线程去执行任务
        return;
    c = ctl.get();
}												 // 工作线程数大于等于核心线程数，就会来到这
if (isRunning(c) && workQueue.offer(command)) {  // 状态是Running，就把任务放入到队列中，如果失败就执行else
    int recheck = ctl.get();                     // 二次检查
    if (! isRunning(recheck) && remove(command)) // 检查不通过(状态不是Running)就删除该任务并采取拒绝策略
        reject(command);
    else if (workerCountOf(recheck) == 0)		
        addWorker(null, false);
}
else if (!addWorker(command, false))   // 当状态不是运行状态，或者队列满了，就会走到这里
    reject(command);                   // 创建非核心线程去执行任务，如果失败就采用拒绝策略
```

我们可以发现，execute()主要调用了两个方法，分别是`addWorker()`和`reject()`



### 2.reject()

主要是调用处理器去拒绝该任务，具体策略有四种

在创建线程池时，会添加默认的处理器defaultHandler，它采取的是**AbortPolicy**

```java
private volatile RejectedExecutionHandler handler;
private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
// 在构造方法里，会默认让 handler = defaultHandler
// ...
final void reject(Runnable command) {
    handler.rejectedExecution(command, this);
}
```

**具体策略：**

|        拒绝策略         |                     描述                     |                应用场景                |
| :---------------------: | :------------------------------------------: | :------------------------------------: |
|     **AbortPolicy**     | 拒绝任务并抛出异常RejectedExecutionException |            捕获异常进行处理            |
|  **CallerRunsPolicy**   |            让调用的线程去执行任务            |        并发量低时，可以使用这种        |
|    **DiscardPolicy**    |                拒绝并丢弃任务                |             当前任务不重要             |
| **DiscardOldestPolicy** | 丢弃最久未处理的工作，然后再次尝试execute()  | 之前的任务不是很重要，就可以用这种策略 |

**具体应用1：**

**场景：**用户支付后，把消息发送给用户，我们希望这个消息无论如何都能够发出去。

**解决：**使用线程池来执行任务。如果并发量很大，导致线程池的阻塞队列满了，可以采用`AbortPolicy`策略，抛出异常，然后在外部捕获异常。捕获异常后把任务存到`redis`中，另外使用一个定时器，每隔一秒去redis中异步获取任务，再次添加到线程池。

**优化版：**自定义拒绝策略，在里面把任务存到`redis`中，以此封装逻辑。

**具体应用2：**

**场景：**推送，上游生产，下游消费；我们希望下游消费得比较慢时，就不要再推送。

**解决：**开一个异步线程去获取任务，然后把任务放入到线程池中去执行推送；当阻塞队列满时，采取`CallerRunsPolicy`策略，让主线程去执行推送，这样主线程既不会空闲下来，也不会再去获取任务。

### 3.addWorker()

这里主要是把任务**包装**成Worker对象，然后**新建**线程（由工厂新建）去执行任务。

```Java
private boolean addWorker(Runnable firstTask, boolean core) {
	// 省略前面的一些判断和处理
    // ...
	boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask); // 创建Worker对象时，内部通过工厂获得了一个线程
        final Thread t = w.thread; // 使用线程
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;// 加锁
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());  // 进行检查，如果状态是Running
 												 // 如果状态是Shutdown 且firstTask是空
                if (rs < SHUTDOWN ||			 // 就把任务添加到HashSet中
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();      // 判断大小
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock(); // 解锁
            }
            if (workerAdded) {
                t.start();         // 启动线程
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);    // 调用失败的方法
    }
    return workerStarted;
}
```

看了上面的源码，我们可以发现**线程池**是通过**创建Worker**来执行任务的，同时**线程**也在Worker对象中。

那么我们再看看**Worker**类

### 4.Worker

Worker类实现了Runnable接口，重写了run()

里面调用了**runWorker()**，那么这个方法才是真正执行任务的！

```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable{
    // ...
    // 构造方法
    Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
    }
    
    public void run() {
            runWorker(this);
    }
    
    // ...
}
```

### 5.runWorker()

我们可以清楚地看到，当任务不为空时，就调用run()执行。

这里也是线程复用的实现：

当一个线程 **执行完 firstTask **后，它会通过getTask()主动去阻塞队列中**获取**任务来执行

```Java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {														// 重点，获得任务的方式有两种
        while (task != null || (task = getTask()) != null) {  	// 1.从Worker对象中得到任务
            w.lock();											// 2.如果Worker对象中的任务完成了
         														// 就通过getTask()方法去获取
          	/* 省略一些中断处理和判断... */
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();       // 前面获取到了任务，就在这里运行
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

### 6.getTask()

通过死循环来获取任务，任务是从阻塞队列中获取的

1. 工作线程数 > 核心线程数 使用poll()
2. 工作线程数 <= 核心线程数 使用take()

poll()和take()的区别在于，poll可以传递放弃等待的时间参数，超过这个时间就放弃获取

take()如果获取不到就会阻塞，一直等待（因为这时候工作线程数量少，你获取不到任务就会空闲，所以要一直阻塞，直到任务来了）

```Java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?
    for (;;) {// 通过死循环获取任务
        // 省略检查线程池状态和队列为空的判断
        int wc = workerCountOf(c);
        // 工作线程数 > 核心线程数，就是true
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
       // 省略超时和容量上限判断
        try {
            Runnable r = timed ?                                      // 1.工作线程数 > 核心线程数 用poll()
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : // 2.反之，就用take()
                workQueue.take();									  // 区别在于take()会阻塞地获取任务 
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

### 7.总结

Executor的线程复用，是让线程在完成任务后，不断地向阻塞队列获取任务

对于核心线程来说，用take方法，获取不到就会阻塞，从而保证它永远不会因为存活时间而过期销毁

而非核心线程，用poll方法，在超时时间内获取不到任务，就会放弃，从而会因为存活时间到期而销毁。

