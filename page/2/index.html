<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<!-- Referrer Policy调整致不蒜子单页面统计出错:https://senorui.top/posts/c33f.html -->
<meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aurora-ze.github.io.git","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Aurora">
<meta property="og:url" content="https://aurora-ze.github.io.git/page/2/index.html">
<meta property="og:site_name" content="Aurora">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="aurora">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://aurora-ze.github.io.git/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Aurora</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?dcdb42c8e3ad5d5a7981af32b9693ef3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Aurora" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aurora</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">矢志前行，拥抱未来！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E5%9B%9B%E3%80%81%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E5%9B%9B%E3%80%81%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">消息存储</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-13 20:06:09 / 修改时间：20:00:54" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          
            <span id="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E5%9B%9B%E3%80%81%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/" class="post-meta-item leancloud_visitors" data-flag-title="消息存储" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Kafka消息存储"><a href="#Kafka消息存储" class="headerlink" title="Kafka消息存储"></a>Kafka消息存储</h1><h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><ul>
<li><strong>kafka服务节点</strong></li>
<li>如果是单机的kafka，那么broker就只有一个；如果是集群，则会有多个broker</li>
</ul>
<h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><ul>
<li><strong>主题，是一种逻辑概念。</strong></li>
<li>一个主题可以包含多个分区，每个分区位于不同的节点上。</li>
</ul>
<h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><ul>
<li><strong>分区，是一种物理概念</strong></li>
<li>可以在某一个broker的数据目录下找到以”主题-分区”命名的文件夹</li>
</ul>
<h2 id="二、带着问题学习"><a href="#二、带着问题学习" class="headerlink" title="二、带着问题学习"></a>二、带着问题学习</h2><h3 id="2-1生产者发出的消息存在哪儿？"><a href="#2-1生产者发出的消息存在哪儿？" class="headerlink" title="2.1生产者发出的消息存在哪儿？"></a>2.1生产者发出的消息存在哪儿？</h3><p>这个是由<code>server.properties</code>文件中的<code>log.dirs</code>配置项来决定的。例如我配置在<code>kafka1/data</code>路径下。</p>
<p>数据目录的内容如下，里面的每个文件夹都是一个分区，命名格式为<code>topic-partition</code></p>
<ul>
<li><p><code>__consumer_offsets</code>：kafka内部主题</p>
</li>
<li><p><code>topic_first</code>和<code>topic_second</code>等自定义的主题及分区</p>
</li>
</ul>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111171444098.png" alt="image-20211117121306130"></p>
<p>查看topic_second-0的内容发现目前存放了5个文件，分别是：</p>
<ol>
<li><code>.index</code>：偏移量索引文件</li>
<li><code>.log</code>：真正的消息文件，即数据</li>
<li><code>.timeindex</code>：时间索引文件</li>
<li>leader-epoch-checkpoint</li>
<li>partition.metadata</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111171444616.png" alt="image-20211117121739809"></p>
<hr>
<h3 id="2-2kafka是如何存储消息的？"><a href="#2-2kafka是如何存储消息的？" class="headerlink" title="2.2kafka是如何存储消息的？"></a>2.2kafka是如何存储消息的？</h3><p>为了防止数据文件过大，kafka采用了<code>分段</code>和<code>索引</code>的方式。每一段可以由一个log文件和两个索引文件组成（以及可能的其他文件）。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111171526705.png" alt="image-20211117152613529"></p>
<h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>数据文件被分成多个<code>log</code>文件进行存储，其中：</p>
<ul>
<li>文件名：起始偏移量，表示在该文件记录的所有消息中的最小偏移量。如上图的<code>00000000000000000000.log</code>，因为是从第一条消息开始记录，所以偏移量为0</li>
<li>文件大小：由<code>log.segment.bytes</code>配置项决定，默认为1GB</li>
</ul>
<p><strong>如何定位消息所在的log文件？</strong></p>
<p>维护一个跳表，跳表的key是每个文件的起始偏移量，这样就可以得知消息在哪个log文件中。</p>
<p>例如查找消息的偏移量为121，那就在<code>120.log</code>中</p>
<table>
<thead>
<tr>
<th align="center">baseoffset=0</th>
<th align="center">baseoffset=120</th>
<th align="center">baseoffset=365</th>
<th align="center">baseoffset=488</th>
<th align="center">baseoffset=788</th>
</tr>
</thead>
</table>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>我们知道消息在哪个log文件之后，还需要知道消息在log中的具体位置，这就需要借助<code>索引文件</code>。</p>
<p><strong>索引文件结构</strong></p>
<p>每个索引项都占8字节，结构如下：</p>
<table>
<thead>
<tr>
<th align="center">relativeOffset</th>
<th align="center">position</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4字节</td>
<td align="center">4字节</td>
</tr>
</tbody></table>
<p><strong>如何根据索引文件来定位消息在log文件中的位置？</strong></p>
<p>在相对偏移量中进行二分查找，确定小于目标offset的最接近的偏移量，然后得到物理位置去log文件中往下找。</p>
<p>例如在<code>27.index</code>中查找offset为50的消息位置：</p>
<table>
<thead>
<tr>
<th align="center">relativeOffset</th>
<th align="center">position</th>
</tr>
</thead>
<tbody><tr>
<td align="center">14</td>
<td align="center">156</td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">459</td>
</tr>
<tr>
<td align="center">35</td>
<td align="center">666</td>
</tr>
<tr>
<td align="center">45</td>
<td align="center">863</td>
</tr>
</tbody></table>
<ol>
<li>计算相对偏移量<ul>
<li>50-27=23</li>
</ul>
</li>
<li>通过<code>二分查找</code>在索引文件中找到22的一项</li>
<li>去<code>27.log</code>文件中的459字节处开始往下找</li>
</ol>
<hr>
<h3 id="2-3消息的过期机制是怎样的？"><a href="#2-3消息的过期机制是怎样的？" class="headerlink" title="2.3消息的过期机制是怎样的？"></a>2.3消息的过期机制是怎样的？</h3><p>消息在磁盘上存储为一个个log文件，这些log文件会占据磁盘一定的容量。</p>
<p>因此Kafka提供了基于<strong>时间</strong>、<strong>文件大小</strong>和<strong>起始偏移量</strong>的删除策略。</p>
<p><strong>存在时间</strong>和<strong>文件大小</strong>都是由配置项决定的，默认配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.retention.hours=168                <span class="comment"># log文件保留七天</span></span><br><span class="line">log.segment.bytes=1073741824           <span class="comment"># 每个log文件最大1GB，超过则写新文件中</span></span><br><span class="line">log.retention.check.interval.ms=300000 <span class="comment"># 每隔5分钟检查是否可以删除</span></span><br></pre></td></tr></table></figure>

<p>另外，基于日志起始偏移量的删除是因为log文件有可能被截断，那么小于起始偏移量的消息就不应该被保留。</p>
<hr>
<h3 id="2-4Kafka高性能、高吞吐是怎样做到的？"><a href="#2-4Kafka高性能、高吞吐是怎样做到的？" class="headerlink" title="2.4Kafka高性能、高吞吐是怎样做到的？"></a>2.4Kafka高性能、高吞吐是怎样做到的？</h3><h5 id="顺序追加"><a href="#顺序追加" class="headerlink" title="顺序追加"></a>顺序追加</h5><p>消息顺序的写到磁盘文件中，并使用操作系统的刷盘策略。</p>
<p>兼顾消息的读写性能与完整性。</p>
<h5 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h5><p>操作系统利用内存加载了大量的磁盘页（即页缓存），使用<strong>预读</strong>和<strong>后写</strong>的方式大大加快了IO效率。</p>
<blockquote>
<p><strong>预读</strong>指读磁盘上的数据时，把后面的一部分数据也读到内存中，这样加快下一次读的效率</p>
<p><strong>后写</strong>指向磁盘写数据时，只是把数据写入到一个缓冲区中，然后由操作系统决定何时写入磁盘。在用户看来已经写入完毕。</p>
</blockquote>
<h5 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h5><p>正常传输流程：</p>
<ol>
<li>从磁盘读数据到内核的READ BUFFER缓冲区中</li>
<li>数据从内核传输到用户</li>
<li>用户态下的数据传递给socket</li>
<li>socket把数据传递给网卡（NIC）</li>
</ol>
<p>零拷贝利用<code>DMA</code>(直接内存访问)的方式，直接把数据从内核缓冲区传输到socket中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">生产者与消费者实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-13 20:06:09 / 修改时间：20:00:32" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          
            <span id="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%9E%E8%B7%B5/" class="post-meta-item leancloud_visitors" data-flag-title="生产者与消费者实践" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>之前使用命令行和脚本的方式来操作kafka，但是一般用的更多的是在项目中用高级语言来操作。</p>
<p>下面是springboot中kafka的使用</p>
</blockquote>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="生产者示例"><a href="#生产者示例" class="headerlink" title="生产者示例"></a>生产者示例</h2><h5 id="一、创建Producer类，用于编写生产者发送消息的过程。"><a href="#一、创建Producer类，用于编写生产者发送消息的过程。" class="headerlink" title="一、创建Producer类，用于编写生产者发送消息的过程。"></a>一、创建<code>Producer</code>类，用于编写生产者发送消息的过程。</h5><h5 id="二、初始化配置"><a href="#二、初始化配置" class="headerlink" title="二、初始化配置"></a>二、初始化配置</h5><p><strong>配置项说明</strong></p>
<table border="1" style="margin:200; text-align:center;">
    <tbody>
        <tr>
            <th colspan="2">配置项</th>
            <th colspan="2">描述</th>
        </tr>
        <tr>
            <td colspan="2">bootstrap.servers</td>
            <td colspan="2">broker节点，如果是集群也不需要全部列出来，一般列出两个即可</td>
        </tr>
        <tr>
            <td rowspan="3" colspan="2" >ack</td>
            <td colspan="2">ack = 1, leader同步了消息，就返回ack</td>
        </tr>
        <tr>
            <td colspan="2">ack = 0, 不等待服务端任何响应，直接返回ack</td>
        </tr>
        <tr>
            <td colspan="2">ack = -1, 所有副本同步了消息才返回ack</td>
        </tr>
        <tr>
            <td colspan="2">compression.type</td>
            <td colspan="2">压缩方式，可以配置为gzip、snappy、lz4等</td>
        </tr>



<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BROKER_LIST = <span class="string">&quot;192.168.13.130:9091,192.168.13.130:9092&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, BROKER_LIST);</span><br><span class="line">        prop.setProperty(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        prop.setProperty(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回ack策略</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">// 消息最大值</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;max.request.size&quot;</span>, <span class="string">&quot;1048576&quot;</span>);</span><br><span class="line">        <span class="comment">// 重发次数和间隔</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;retries&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;retries.backoff.ms&quot;</span>, <span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息压缩方式</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;compression.type&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义的拦截器</span></span><br><span class="line">        prop.setProperty(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, MyProducerInterceptor.class.getName());</span><br><span class="line">        <span class="keyword">return</span> prop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、定义消息并发送"><a href="#三、定义消息并发送" class="headerlink" title="三、定义消息并发送"></a>三、定义消息并发送</h5><p>对于消息的发送，我们可以选择三种模式：</p>
<ol>
<li>发后即忘，不做任何处理</li>
<li>同步发送，阻塞等待结果</li>
<li>异步回调，传入回调函数在发送完毕后执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Properties prop = initConfig();</span><br><span class="line">    KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(prop,</span><br><span class="line">            <span class="keyword">new</span> StringSerializer(),</span><br><span class="line">            <span class="keyword">new</span> StringSerializer());</span><br><span class="line">    ProducerRecord&lt;String, String&gt; record1 = <span class="keyword">new</span> ProducerRecord(TOPIC, <span class="string">&quot;aurora&quot;</span>);</span><br><span class="line">    ProducerRecord&lt;String, String&gt; record2 = <span class="keyword">new</span> ProducerRecord(TOPIC, <span class="string">&quot;20&quot;</span>);</span><br><span class="line">    ProducerRecord&lt;String, String&gt; record3 = <span class="keyword">new</span> ProducerRecord(TOPIC, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 异步，不处理结果</span></span><br><span class="line">        producer.send(record1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步，调用get阻塞等待结果</span></span><br><span class="line">        producer.send(record2).get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步回调，回调函数处理异常</span></span><br><span class="line">        producer.send(record3, (RecordMetadata recordMetadata, Exception e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;[INFO] 回调输出：&quot;</span> + recordMetadata.topic() + <span class="string">&quot;-&quot;</span></span><br><span class="line">                        + recordMetadata.partition() + <span class="string">&quot;:&quot;</span></span><br><span class="line">                        + recordMetadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产者补充部分"><a href="#生产者补充部分" class="headerlink" title="生产者补充部分"></a>生产者补充部分</h2><h5 id="一、拦截器"><a href="#一、拦截器" class="headerlink" title="一、拦截器"></a>一、拦截器</h5><p><strong>是什么？</strong></p>
<p>拦截器可以在消息发出前以及收到返回的ack后，添加额外的操作。</p>
<p><strong>如何实现？</strong></p>
<p>实现<code>ProducerInterceptor</code>接口，实现其中的方法即可。下面是一个拦截器示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProducerInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger sendSuccess = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger sendFailure = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 为消息的值添加前缀</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerRecord <span class="title">onSend</span><span class="params">(ProducerRecord record)</span> </span>&#123;</span><br><span class="line">        String newVal = <span class="string">&quot;pre-&quot;</span> + record.value();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProducerRecord(record.topic(), record.partition(), record.timestamp(),</span><br><span class="line">                record.key(), record.value(), record.headers());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 消息成功发送后，输出一些信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sendFailure.incrementAndGet();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sendSuccess.incrementAndGet();</span><br><span class="line">            System.out.println(<span class="string">&quot;write into partition: &quot;</span> + metadata.partition() + <span class="string">&quot; &quot;</span> + metadata.topic());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计消息发送成功率</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> rate = (<span class="keyword">double</span>)sendSuccess.get() / (sendSuccess.get() + sendFailure.get());</span><br><span class="line">        System.out.printf(<span class="string">&quot;[INFO] 发送成功率=%f%s\n&quot;</span>, rate*<span class="number">100</span>, <span class="string">&quot;%&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二、序列化器"><a href="#二、序列化器" class="headerlink" title="二、序列化器"></a>二、序列化器</h5><p><strong>是什么？</strong></p>
<p>将消息转化成字节流的形式，进行传输。</p>
<p>一般使用的序列化器是<code>StringSerializer</code>，在配置中添加这一项即可。</p>
<p><strong>如何实现？</strong></p>
<p>实现<code>Serializer</code>接口。</p>
<h5 id="三、分区器"><a href="#三、分区器" class="headerlink" title="三、分区器"></a>三、分区器</h5><p><strong>是什么？</strong></p>
<p>分区器可以决定消息要发往主题的哪一个分区。当然，如果指定了分区，那么分区器就不会起作用。</p>
<p><strong>如何实现？</strong></p>
<p>实现<code>Partitioner</code>接口。</p>
<h2 id="消费者示例"><a href="#消费者示例" class="headerlink" title="消费者示例"></a>消费者示例</h2><p>消费者的主要行为是订阅topic或partition，然后进行消费。</p>
<h5 id="一、初始化配置"><a href="#一、初始化配置" class="headerlink" title="一、初始化配置"></a>一、初始化配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">initConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, Config.BROKER_LIST);</span><br><span class="line">    prop.setProperty(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">    prop.setProperty(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line"></span><br><span class="line">    prop.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;group1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="二、订阅主题或分区"><a href="#二、订阅主题或分区" class="headerlink" title="二、订阅主题或分区"></a>二、订阅主题或分区</h5><p>消费者API中提供了多种方式进行订阅，下面列举了一些：</p>
<p>注意，通过<code>subscribe</code>、<code>assign</code>和<code>正则</code>这三种方式的订阅是互斥的，不要对同一个消费者混合使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Properties prop = initConfig();</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(prop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅指定topic</span></span><br><span class="line">    consumer.subscribe(Arrays.asList(Config.TOPIC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅指定topic和partition</span></span><br><span class="line">    consumer.assign(Arrays.asList(<span class="keyword">new</span> TopicPartition(Config.TOPIC, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则表达式批量订阅</span></span><br><span class="line">    consumer.subscribe(Pattern.compile(<span class="string">&quot;test*&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询并订阅topic的所有分区</span></span><br><span class="line">    List&lt;TopicPartition&gt; topic = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = consumer.partitionsFor(Config.TOPIC);</span><br><span class="line">    <span class="keyword">for</span> (PartitionInfo partition : partitions) &#123;</span><br><span class="line">        topic.add(<span class="keyword">new</span> TopicPartition(partition.topic(), partition.partition()));</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.assign(topic); </span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、拉取消息"><a href="#三、拉取消息" class="headerlink" title="三、拉取消息"></a>三、拉取消息</h5><p>通过循环不断地轮询，尝试读取消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Properties prop = initConfig();</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(prop);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省去订阅步骤...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(isRunning.get()) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            <span class="comment">// 模拟消息处理</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Topic = &quot;</span> + record.topic()</span><br><span class="line">                    + <span class="string">&quot;, partition = &quot;</span> + record.partition()</span><br><span class="line">                    + <span class="string">&quot;, offset = &quot;</span> + record.offset());</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + record.key()</span><br><span class="line">                    + <span class="string">&quot;value = &quot;</span> + record.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="四、提交位移"><a href="#四、提交位移" class="headerlink" title="四、提交位移"></a>四、提交位移</h5><p>下面演示手动提交位移，首先记得关闭自动提交：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.setProperty(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>同步提交</strong></p>
<p>按分区来对消息进行处理并提交位移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(isRunning.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="comment">// 针对分区进行消费</span></span><br><span class="line">    <span class="keyword">for</span>(TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">        List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(ConsumerRecord&lt;String, String&gt; record : partitionRecords) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Topic = &quot;</span> + record.topic()</span><br><span class="line">                    + <span class="string">&quot;, partition = &quot;</span> + record.partition()</span><br><span class="line">                    + <span class="string">&quot;, offset = &quot;</span> + record.offset());</span><br><span class="line">            System.out.println(<span class="string">&quot;key = &quot;</span> + record.key()</span><br><span class="line">                    + <span class="string">&quot;value = &quot;</span> + record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同步提交位移</span></span><br><span class="line">        <span class="keyword">long</span> lastConsumedOffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">        consumer.commitSync(Collections.singletonMap(partition, <span class="keyword">new</span> OffsetAndMetadata(lastConsumedOffset + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer.close();</span><br></pre></td></tr></table></figure>

<p><strong>异步提交</strong></p>
<p>异步提交，并传入回调函数在提交完后执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(isRunning.get()) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        <span class="comment">// 处理消息...</span></span><br><span class="line"></span><br><span class="line">        consumer.commitAsync(<span class="keyword">new</span> OffsetCommitCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(offsets);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// log.error(&quot;fail to commit offsets &#123; &#125;&quot;, offsets, exception);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、退出消费"><a href="#五、退出消费" class="headerlink" title="五、退出消费"></a>五、退出消费</h5><p>消费的大致结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning.get()) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line"> 		<span class="comment">// 消费消息、提交位移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// do some logic process</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kafka Consumer提供了<code>wakeup()</code>抛出一个WakeupException来退出消费。</p>
<p>此外，我们还可以通过设置<code>isRunning</code>为false来退出消费的循环。</p>
<h2 id="消费者补充"><a href="#消费者补充" class="headerlink" title="消费者补充"></a>消费者补充</h2><h5 id="一、再均衡监听器"><a href="#一、再均衡监听器" class="headerlink" title="一、再均衡监听器"></a>一、再均衡监听器</h5><p>再均衡是指当消费者组中的消费者数量发生变化，或主题的分区数变化时，Kafka会进行重新分配的过程。在这过程中，消费者是无法进行消费的。</p>
<p>简单示例：在发生再均衡之前，先提交位移。</p>
<p>当然也可以把位移保存在其他地方，然后再均衡结束时，取出位移并指定位移消费。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Arrays.asList(Config.TOPIC), <span class="keyword">new</span> <span class="function"><span class="title">ConsumerRebalanceListener</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onPartitionsRevoked</span>(<span class="params">Collection&lt;TopicPartition&gt; partitions</span>)</span> &#123;</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onPartitionsAssigned</span>(<span class="params">Collection&lt;TopicPartition&gt; partitions</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="二、消费者拦截器"><a href="#二、消费者拦截器" class="headerlink" title="二、消费者拦截器"></a>二、消费者拦截器</h5><p>消费者拦截器用于在消费者拿到消息或提交位移时进行定制化操作（比如过滤）。</p>
<p>自定义的消费者拦截器需要实现<code>ConsumerInterceptor</code>接口，方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConsumerInterceptor</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Configurable</span>, <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function">ConsumerRecords&lt;K, V&gt; <span class="title">onConsume</span><span class="params">(ConsumerRecords&lt;K, V&gt; records)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onCommit</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、多线程消费"><a href="#三、多线程消费" class="headerlink" title="三、多线程消费"></a>三、多线程消费</h5><p><strong>形式1：开启多个线程，每个线程消费不同的分区</strong></p>
<p><code>ConsumerThread</code>继承Thread类并重写run方法。在<code>run()</code>内部进行消息的获取和消费，这里就不再赘述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = initConfig();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 线程数可指定</span></span><br><span class="line">    ConsumerThread thread = <span class="keyword">new</span> ConsumerThread(Config.TOPIC, prop);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>形式2：多个消费者线程消费同一个分区</strong></p>
<p>这种方式可以用<code>seek()</code>或<code>assign()</code>来实现，但是对于位移提交和顺序控制将会非常困难。所以一般不推荐使用。</p>
<p><strong>形式3：线程池消费不同批次的消息</strong></p>
<p>因为使用线程池对线程进行管理，所以可能存在消费了同一分区消息的情况。因此我们需要对消费位移进行维护。</p>
<p>首先，定义<code>KafkaConsumerThread</code>，该线程负责实现将拉取到的记录加入到线程池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    KafkaConsumer consumer;</span><br><span class="line">    ExecutorService executors;</span><br><span class="line">    ConcurrentMap&lt;TopicPartition, OffsetAndMetadata&gt; offsets;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对消费者和线程池进行初始化</span></span><br><span class="line">    KafkaConsumerThread(String topic, Properties prop, <span class="keyword">int</span> threadNumber) &#123;</span><br><span class="line">        consumer = <span class="keyword">new</span> KafkaConsumer(prop);</span><br><span class="line">        consumer.subscribe(Collections.singletonList(topic));</span><br><span class="line">        executors = <span class="keyword">new</span> ThreadPoolExecutor(threadNumber, threadNumber, <span class="number">0L</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">1000</span>),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()); <span class="comment">// 让调用线程处理多余的消息</span></span><br><span class="line"></span><br><span class="line">        offsets = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">                <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                    executors.submit(<span class="keyword">new</span> RecordsHandler(records, offsets));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 提交位移</span></span><br><span class="line">                <span class="keyword">if</span> (!offsets.isEmpty()) &#123;</span><br><span class="line">                    consumer.commitSync(offsets);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对封装的<code>RecordsHandler</code>实现消息的消费逻辑（主要列出了重写的<code>run()</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    <span class="keyword">for</span>(TopicPartition partition : records.partitions()) &#123;</span><br><span class="line">        List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = <span class="keyword">this</span>.records.records(partition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费过程...</span></span><br><span class="line">        <span class="keyword">for</span>(ConsumerRecord record : partitionRecords) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Current Thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;topic = &quot;</span> + record.topic()</span><br><span class="line">                    + <span class="string">&quot; partition = &quot;</span> + record.partition()</span><br><span class="line">                    + <span class="string">&quot; value = &quot;</span> + record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录位移, 条件为没有偏移量记录或消费偏移量更大 fixme</span></span><br><span class="line">        <span class="keyword">long</span> lastConsumedOffset = partitionRecords.get(partitionRecords.size() - <span class="number">1</span>).offset();</span><br><span class="line">        <span class="keyword">if</span> (!offsets.containsKey(partition) || lastConsumedOffset + <span class="number">1</span> &gt; offsets.get(partition).offset()) &#123;</span><br><span class="line">            offsets.put(partition, <span class="keyword">new</span> OffsetAndMetadata(lastConsumedOffset + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h5 id="一、未指定partition和key时，消息全部发往一个分区"><a href="#一、未指定partition和key时，消息全部发往一个分区" class="headerlink" title="一、未指定partition和key时，消息全部发往一个分区"></a>一、未指定partition和key时，消息全部发往一个分区</h5><p><strong>问题描述</strong></p>
<p>连续发十条消息（编号0-9），我希望消费者读到的顺序是错位的，如<code>0369147258</code>。但是发现消息顺序读出来了。</p>
<p>打印一些信息后，发现消息都发在同一个分区了，因此消费者当然就会顺序消费了。（Kafka保证了消息的分区有序性）</p>
<p><strong>相关配置</strong></p>
<ol>
<li>发送策略：发后即忘</li>
<li>分区器：未设置，使用默认分区器</li>
</ol>
<p><strong>分析</strong></p>
<p>最后发现是因为粗心，生产者配置部分都是自己写的，忘记参照视频的样例。</p>
<p>默认的分区器使用粘性分区的思想，同一批发送的消息会发送到相同的分区，这样避免了分区的重复计算。（关于消息的分区器，可以参考另一篇理论性的文章）</p>
<p>如果希望消息发送到不同的分区，可以尝试设置<code>RoundRobin</code>分区器，实现轮询分配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者处</span></span><br><span class="line">prop.setProperty(ProducerConfig.PARTITIONER_CLASS_CONFIG, RoundRobinPartitioner.class.getName());</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">生产者与消费者理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-13 20:06:09 / 修改时间：20:00:45" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          
            <span id="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%90%86%E8%AE%BA/" class="post-meta-item leancloud_visitors" data-flag-title="生产者与消费者理论" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><h2 id="消息分区策略"><a href="#消息分区策略" class="headerlink" title="消息分区策略"></a>消息分区策略</h2><p>问题：当生产者向包含多个分区的Topic发送消息时，消息会发往哪个分区呢？</p>
<p>解释：</p>
<ol>
<li>发送时指定<code>partition</code>：发送到指定分区</li>
<li>发送时未指定<code>partition</code>：由分区器来决定</li>
</ol>
<p>在Kafka生产者中分区器主要有两种，默认分区器和轮询分区器。</p>
<h3 id="一、默认分区器"><a href="#一、默认分区器" class="headerlink" title="一、默认分区器"></a>一、默认分区器</h3><p>默认分区器利用了<code>粘性分区</code>的思想。</p>
<blockquote>
<p><code>粘性分区</code>表示在Kafka一次批量发送消息的过程中，会尽可能的减少分区的分配变动。</p>
<p>因此分区就是具备粘性的，在同一次批量发送中消息就会分配到同一个分区。</p>
</blockquote>
<h5 id="DefaultPartitioner"><a href="#DefaultPartitioner" class="headerlink" title="DefaultPartitioner"></a>DefaultPartitioner</h5><p><code>partition()</code>计算得到要发送的分区号，源码如下：</p>
<ol>
<li>未指定key时，用粘性分区缓存来获取分区号</li>
<li>指定key时，通过计算哈希值并求余的方式得到分区号。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> stickyPartitionCache.partition(topic, cluster);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StickyPartitionCache"><a href="#StickyPartitionCache" class="headerlink" title="StickyPartitionCache"></a>StickyPartitionCache</h5><p><code>StickyPartitionCache</code>类主要利用利用map记录主题和消息发往的分区号的映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StickyPartitionCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Integer&gt; indexCache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StickyPartitionCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.indexCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * partition()返回分区号</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 如果在map中找到了上次发往某个主题时分配的分区号，就返回该分区号（粘性分区）</span></span><br><span class="line"><span class="comment">    * 如果map中未找到，则调用nextPartition()执行一次重新分配分区号的动作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        Integer part = indexCache.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (part == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextPartition(topic, cluster, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> part;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、轮询分区器"><a href="#二、轮询分区器" class="headerlink" title="二、轮询分区器"></a>二、轮询分区器</h3><p>从<code>RoundRobinPartitioner</code>类的注解可以看到，如果希望消息能够分布式的写到不同的分区上，那么就可以使用轮询分区器。</p>
<p>它具备两个特点：</p>
<ol>
<li>平等的写入到每个分区</li>
<li>消息设置的key不会生效（即不会对它求hash来取值）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &quot;Round-Robin&quot; partitioner</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This partitioning strategy can be used when user wants </span></span><br><span class="line"><span class="comment"> * to distribute the writes to all partitions equally. This</span></span><br><span class="line"><span class="comment"> * is the behaviour regardless of record key hash. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="nextValue"><a href="#nextValue" class="headerlink" title="nextValue()"></a>nextValue()</h5><p>在map寻找topic对应的分区号，未找到则返回0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextValue</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">    AtomicInteger counter = topicCounterMap.computeIfAbsent(topic, k -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> counter.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="partition"><a href="#partition" class="headerlink" title="partition()"></a>partition()</h5><p>借助<code>nextValue()</code>返回的值来求余计算分区号。</p>
<p>此外，这里还有一些额外的逻辑，如判断是否有可用分区和确保nextValue为正。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">    <span class="keyword">int</span> nextValue = nextValue(topic);</span><br><span class="line">    List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">if</span> (!availablePartitions.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">        <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产者过程分析"><a href="#生产者过程分析" class="headerlink" title="生产者过程分析"></a>生产者过程分析</h2><p>生产者主要使用两个线程：主线程和Sender线程</p>
<p>主线程调用<code>send()</code>后，依次经过了<code>拦截器-序列化器-分区器</code>，然后被添加到消息累计器中。然后由Sender线程获取消息并发送给broker。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111211654366.png" alt="image-20211118170513669"></p>
<h3 id="一、消息累加器"><a href="#一、消息累加器" class="headerlink" title="一、消息累加器"></a>一、消息累加器</h3><p>在消息累加器中，每个分区都会对应一条队列，经过分区器计算或是直接指定分区的消息，便会加入到对应的队列中。</p>
<p>消息累加器<code>RecordAccumulator</code>使用map存储了某个主题下每个分区和队列的映射关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordAccumulator</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; batches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>队列中的<code>ProducerBatch</code>对象表示批量的记录，分配消息时会取出队列的最后一条batch记录，并把消息添加在batch中。</p>
<p>这里对应的就是<code>ProducerBatch</code>类下的tryAppend()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 检查空间后，调用MemoryRecordsBuilder对象的append方法来向内存中写入新消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FutureRecordMetadata <span class="title">tryAppend</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value, Header[] headers, Callback callback, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.recordsBuilder.append(timestamp, key, value, headers); </span><br><span class="line">        <span class="keyword">this</span>.maxRecordSize = Math.max(<span class="keyword">this</span>.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(),</span><br><span class="line">                recordsBuilder.compressionType(), key, value, headers));</span><br><span class="line">        <span class="keyword">this</span>.lastAppendTime = now;</span><br><span class="line">        FutureRecordMetadata future = <span class="keyword">new</span> FutureRecordMetadata(<span class="keyword">this</span>.produceFuture, <span class="keyword">this</span>.recordCount,</span><br><span class="line">                                                               timestamp,</span><br><span class="line">                                                               key == <span class="keyword">null</span> ? -<span class="number">1</span> : key.length,</span><br><span class="line">                                                               value == <span class="keyword">null</span> ? -<span class="number">1</span> : value.length,</span><br><span class="line">                                                               Time.SYSTEM);</span><br><span class="line">        <span class="comment">// we have to keep every future returned to the users in case the batch needs to be</span></span><br><span class="line">        <span class="comment">// split to several new batches and resent.</span></span><br><span class="line">        thunks.add(<span class="keyword">new</span> Thunk(callback, future));</span><br><span class="line">        <span class="keyword">this</span>.recordCount++;</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h2><h3 id="一、位移提交"><a href="#一、位移提交" class="headerlink" title="一、位移提交"></a>一、位移提交</h3><p><strong>对于Kafka分区而言，它的每条消息都有唯一的offset，用来表示消息在分区中的位置；而消费者也是通过offset来得知上次消费消息的位置。</strong></p>
<h5 id="那么这个位移存在哪儿？"><a href="#那么这个位移存在哪儿？" class="headerlink" title="那么这个位移存在哪儿？"></a>那么这个位移存在哪儿？</h5><p>旧版存在ZooKeeper中，新版存在Kafka Broker的<code>__consumer_offsets</code>主题中。</p>
<h5 id="什么是位移提交？为什么要提交位移？"><a href="#什么是位移提交？为什么要提交位移？" class="headerlink" title="什么是位移提交？为什么要提交位移？"></a>什么是位移提交？为什么要提交位移？</h5><p>消费者将消费的位移提交到Kafka Broker的动作，就是<strong>位移提交</strong>。而之所以需要提交，是因为消费者使用拉取消息的方式，Kafka并不知道消费者消费到哪儿了，需要消费者来告诉它。</p>
<h5 id="怎样进行位移提交"><a href="#怎样进行位移提交" class="headerlink" title="怎样进行位移提交?"></a>怎样进行位移提交?</h5><p>Kafka提供了<strong>自动提交</strong>和<strong>手动提交</strong>两种方式。</p>
<p>首先，确认一点，提交的位移指的是下一次要消费的消息所在的偏移量。</p>
<p><strong>自动提交</strong></p>
<p>自动提交指的是Kafka会定期的提交一次位移，定期由两个参数来配置：</p>
<ul>
<li><p><code>enable.auto.commit</code>：是否开启自动提交，默认为true</p>
</li>
<li><p><code>auto.commit.interval.ms</code>：自动提交的间隔，默认为5秒</p>
</li>
</ul>
<p>自动提交存在的问题：</p>
<ol>
<li><code>重复消费</code>：因为位移是延后提交的，所以存在消费者消费之后，还没来得及提交位移就宕机的可能。</li>
<li><code>消息丢失</code>：如果消费者端把读到的消息放入队列中等待另一个线程处理，那么有可能提交位移后消费者宕机，处理线程还未处理消息。</li>
</ol>
<p><strong>手动提交</strong></p>
<p>手动提交可以让开发人员根据程序的逻辑在合适的地方提交位移，<strong>注意，采用手动提交时必须关闭自动提交</strong>。</p>
<p>手动提交的时机非常重要：</p>
<ol>
<li>如果先提交再处理消息，消息可能还没处理消费者就宕机了，导致<strong>消息丢失</strong>。</li>
<li>如果先处理再提交，提交位移前消费者宕机就会造成<strong>重复消费</strong>。</li>
</ol>
<p>如果希望消息精确的只被消费一次，可以采用二阶段提交的方式：落表，并在消息处理前判断是否已存在记录。（还是有缺陷？何时落表？）</p>
<h2 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h2><p>分区分配策略：</p>
<ol>
<li>决定了处于同一消费者组中的消费者该消费哪个分区</li>
<li>保证一个分区只能被同一个消费者组中的一个消费者消费</li>
</ol>
<p>如果要打破<code>2</code>的限制</p>
<h3 id="一、RangeAssignor"><a href="#一、RangeAssignor" class="headerlink" title="一、RangeAssignor"></a>一、RangeAssignor</h3><h5 id="1-1分配原理"><a href="#1-1分配原理" class="headerlink" title="1.1分配原理"></a>1.1分配原理</h5><p>对<code>单个主题</code>的所有分区进行平均分配。</p>
<ul>
<li>如果分区数与消费者数能够整除，那么每个消费者分配到的分区数量都是一样的。</li>
<li>如果有余数，那么把余数分区一份份分给靠前（排序后）的消费者</li>
</ul>
<h5 id="1-2示例"><a href="#1-2示例" class="headerlink" title="1.2示例"></a>1.2示例</h5><blockquote>
<p>两个消费者订阅两个主题，每个主题3个分区。</p>
<p>如主题t0的分区为t0p0、t0p1、t0p2</p>
</blockquote>
<p>对于一个主题来说，每个消费者先分配1个分区，然后多余的1个分区分给第一个消费者。</p>
<p><strong>分配t0后的结果：</strong></p>
<ul>
<li>消费者C0：t0p0、t0p1</li>
<li>消费者C1：t0p2</li>
</ul>
<p><strong>然后分配t1后的结果：</strong></p>
<ul>
<li>消费者C0：t0p0、t0p1、t1p0、t1p1</li>
<li>消费者C1：t0p2、t1p2</li>
</ul>
<p>设想一下，如果新订阅了第三个主题（分区数为3），那么消费者C0所分配到的分区数还会多两个，<strong>不均衡</strong>的情况会更加严重。</p>
<h5 id="1-3特点"><a href="#1-3特点" class="headerlink" title="1.3特点"></a>1.3特点</h5><p>通过上述例子可以发现，<code>Range</code>策略可以保证<strong>分配一个主题的分区时每个消费者所分配到的分区数之差在一个以内。</strong></p>
<p>但是，当订阅多个主题时可能会存在某个消费者过载的问题，并且可能会随着订阅主题数的增加而愈发严重。</p>
<h3 id="二、RoundRobinAssingor"><a href="#二、RoundRobinAssingor" class="headerlink" title="二、RoundRobinAssingor"></a>二、RoundRobinAssingor</h3><h5 id="2-1分配原理"><a href="#2-1分配原理" class="headerlink" title="2.1分配原理"></a>2.1分配原理</h5><p>对消费者组订阅的<code>所有主题及分区</code>进行排序并依次分配。</p>
<h5 id="2-2示例1-同上述的例子"><a href="#2-2示例1-同上述的例子" class="headerlink" title="2.2示例1@同上述的例子"></a>2.2示例1<code>@同上述的例子</code></h5><blockquote>
<p>两个消费者订阅两个主题，每个主题3个分区。</p>
<p>所有订阅主题的分区排序：t0p0、t0p1、t0p2、t1p0、t1p1、t1p2</p>
</blockquote>
<p>分配结果（依次分配给消费者）：</p>
<ul>
<li>消费者C0：t0p0、t0p2、t1p1</li>
<li>消费者C1：t0p1、t1p0、t1p2</li>
</ul>
<p>可以看到，如果每个消费者订阅的主题是相同的，那么可以保证尽可能的均匀分配。</p>
<h5 id="2-3示例2-订阅不同主题"><a href="#2-3示例2-订阅不同主题" class="headerlink" title="2.3示例2@订阅不同主题"></a>2.3示例2<code>@订阅不同主题</code></h5><p>再看这个订阅不同主题的例子：</p>
<blockquote>
<p>三个消费者，订阅情况分别是：C0订阅t0，C1订阅t0、t1，C2订阅t0、t1、t2</p>
<p>主题分别有1，2，3个分区</p>
</blockquote>
<p>因为消费者C0和C1没有订阅所有主题，因此并不会参与所有主题分区的分配</p>
<p>所有分区排序：t0p0、t1p0、t1p1、t2p0、t2p1、t2p2</p>
<p>分配结果：</p>
<ul>
<li>消费者C0：t0p0</li>
<li>消费者C1：t1p0</li>
<li>消费者C2：t1p1、t2p0、t2p1、t2p2</li>
</ul>
<h5 id="2-4特点"><a href="#2-4特点" class="headerlink" title="2.4特点"></a>2.4特点</h5><p>和<code>RangeAssignor</code>相比，<code>RoundRobinAssignor</code>通过从多主题的角度考虑，保证了当每个消费者订阅相同的主题时的分配均衡（最多差一个）。</p>
<p>但是订阅的主题不同时，它并没有做到最优分配，例如上述例子中<code>t1p1</code>可以分配给C1</p>
<h3 id="三、StickyAssingor"><a href="#三、StickyAssingor" class="headerlink" title="三、StickyAssingor"></a>三、StickyAssingor</h3><p>粘性分配的目的：</p>
<ol>
<li>与其他分配策略一样，尽量保证分区的分配均衡。</li>
<li>进行<strong>再分配</strong>时，尽可能的减少分配的变化，即拥有“粘性”</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="一、消息丢失问题"><a href="#一、消息丢失问题" class="headerlink" title="一、消息丢失问题"></a>一、消息丢失问题</h3><p>Kafka生产者与消费者都有可能存在消息丢失的问题。</p>
<h5 id="生产者端"><a href="#生产者端" class="headerlink" title="生产者端"></a>生产者端</h5><p>原因在于<code>ack</code>的取值，值为0或1时没有做到所有副本的消息同步，因此副本宕机会造成消息丢失。</p>
<p><code>ack</code>取-1时所有副本同步后才算消息写入成功，但这样消息吞吐量会有所损失。</p>
<h5 id="消费者端"><a href="#消费者端" class="headerlink" title="消费者端"></a>消费者端</h5><p>原因可能是开启了自动提交位移，也可能是手动提交位移的情况下先提交再消费。</p>
<p>如何解决可以看上述的<strong>手动提交</strong>部分。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%80%E3%80%81Kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%80%E3%80%81Kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-13 20:06:09" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-21 16:56:18" itemprop="dateModified" datetime="2021-11-21T16:56:18+08:00">2021-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          
            <span id="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%80%E3%80%81Kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/" class="post-meta-item leancloud_visitors" data-flag-title="环境搭建" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><blockquote>
<p>在Linux上搭建Kafka，需要有Java8和Zookeeper环境:stuck_out_tongue_winking_eye:</p>
</blockquote>
<h2 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h2><h5 id="查看Java包"><a href="#查看Java包" class="headerlink" title="查看Java包"></a>查看Java包</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search java</span><br></pre></td></tr></table></figure>

<h5 id="选择jdk8进行安装"><a href="#选择jdk8进行安装" class="headerlink" title="选择jdk8进行安装"></a>选择jdk8进行安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk-devel.x86_64</span><br></pre></td></tr></table></figure>

<h5 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加变量JAVA_HOME，表示jdk安装路径。路径最后一长串可能不太一样，需要自己进入jvm目录下查看</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.171-8.b10.el6_9.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加变量CLASSPATH，表示jvm扫描class文件的路径</span></span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加变量PATH，表示可以执行java提供的命令</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h5 id="查看java版本"><a href="#查看java版本" class="headerlink" title="查看java版本"></a>查看java版本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>



<h2 id="安装Zookeeper"><a href="#安装Zookeeper" class="headerlink" title="安装Zookeeper"></a>安装Zookeeper</h2><h5 id="安装并解压"><a href="#安装并解压" class="headerlink" title="安装并解压"></a>安装并解压</h5><p>在安装前，最好进入到要安装的目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在官网（http://zookeeper.apache.org/releases.html）选择版本，找到下载路径</span></span><br><span class="line">wget https://downloads.apache.org/zookeeper/zookeeper-3.6.3/apache-zookeeper-3.6.3-bin.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf apache-zookeeper-3.6.3-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="得到Zookeeper配置文件"><a href="#得到Zookeeper配置文件" class="headerlink" title="得到Zookeeper配置文件"></a>得到Zookeeper配置文件</h5><p>在<code>conf</code>文件夹中拷贝配置文件示例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必选，修改成自己想要的路径</span></span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/services/zookeeper/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可增加，日志目录</span></span><br><span class="line">dataLogDir=/usr/<span class="built_in">local</span>/services/zookeeper/logs</span><br></pre></td></tr></table></figure>

<p>这里提一句，zookeeper的日志是二进制，需要经过处理后才能看</p>
<p>详情请参考这里：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sagech/p/10827174.html">zookeeper 事务日志查看 - 浪荡小新 - 博客园 (cnblogs.com)</a></p>
<h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ZOOKEEPER_HOME=/usr/<span class="built_in">local</span>/services/zookeeper/apache-zookeeper-3.6.3-bin <span class="comment"># 注意这里的路径要根据实际来填</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ZOOKEEPER_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="comment"># 使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start   <span class="comment"># 如果打印出一些信息，即表示启动成功</span></span><br><span class="line">zkServer.sh status  <span class="comment"># 查看状态</span></span><br><span class="line">zkServer.sh stop    <span class="comment"># 关闭</span></span><br><span class="line">zkServer.sh restart <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>



<h2 id="安装Kafka"><a href="#安装Kafka" class="headerlink" title="安装Kafka"></a>安装Kafka</h2><h5 id="下载并解压"><a href="#下载并解压" class="headerlink" title="下载并解压"></a>下载并解压</h5><p>同样，记得提前进入安装目录；否则就要下载完后再移动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在quick start中点击进入下载页面</span></span><br><span class="line"><span class="comment"># https://kafka.apache.org/quickstart</span></span><br><span class="line">wget https://dlcdn.apache.org/kafka/3.0.0/kafka_2.13-3.0.0.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压，笨办法，移动压缩包，然后再原地解压</span></span><br><span class="line">tar -zxvf kafka_2.13-3.0.0.tgz</span><br></pre></td></tr></table></figure>

<h5 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kafka根目录下/config/server.properties文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改broker.id为正数</span></span><br><span class="line">broker.id=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置消息文件的路径（数据与日志分离）</span></span><br><span class="line">log.dir=/usr/<span class="built_in">local</span>/services/kafka/data</span><br></pre></td></tr></table></figure>

<h5 id="集群搭建（可选）"><a href="#集群搭建（可选）" class="headerlink" title="集群搭建（可选）"></a>集群搭建（可选）</h5><p>尝试在单台虚拟机上搭建3个kafka broker。</p>
<blockquote title="结束啦" style="padding:12px;border-left-color:#98bf21;background-color:rgb(249, 248, 250);">
 <p style="font-weight: bold;">提示</p>
 <p>到这里，kafka安装及环境搭建就告一段落啦~ </p>
 <p>接下来开始正式使用「kafka」</p>
</blockquote>




<h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><h2 id="启动与关闭"><a href="#启动与关闭" class="headerlink" title="启动与关闭"></a>启动与关闭</h2><h5 id="启动Kafka"><a href="#启动Kafka" class="headerlink" title="启动Kafka"></a>启动Kafka</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先启动zookeeper</span></span><br><span class="line">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再启动kafka</span></span><br><span class="line">bin/kafka-server-start.sh  config/server.properties</span><br></pre></td></tr></table></figure>

<h5 id="关闭kafka-broker、producer、consumer"><a href="#关闭kafka-broker、producer、consumer" class="headerlink" title="关闭kafka broker、producer、consumer"></a>关闭kafka broker、producer、consumer</h5><p><code>Ctrl + C</code>或者输入<code>bin/kafka-server-stop.sh</code></p>
<h5 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># run this script to auto start the kafka broker and zookeeper</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/service/kafka</span><br><span class="line"></span><br><span class="line">bash bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br><span class="line"></span><br><span class="line">bash bin/kafka-server-start.sh  config/server.properties</span><br></pre></td></tr></table></figure>



<h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><p>topic相当于文件系统中的文件夹，events就相当于一个个要放入文件夹中的文件。</p>
<h5 id="创建名为quickstart的topic"><a href="#创建名为quickstart的topic" class="headerlink" title="创建名为quickstart的topic"></a>创建名为quickstart的topic</h5><ul>
<li><code>topic</code>：指定topic名称</li>
<li><code>replication-factor</code>：备份数</li>
<li><code>partitions</code>：分区数</li>
<li><code>bootstrap-server</code>：2.2版本后推荐用它来代替zookeeper</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --topic quickstart --replication-factor 1 --partitions 1 --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<h5 id="列出所有topic"><a href="#列出所有topic" class="headerlink" title="列出所有topic"></a>列出所有topic</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<h5 id="查看某个topic信息"><a href="#查看某个topic信息" class="headerlink" title="查看某个topic信息"></a>查看某个topic信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --topic quickstart --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<h5 id="删除某个topic"><a href="#删除某个topic" class="headerlink" title="删除某个topic"></a>删除某个topic</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topic.sh --delete --topic quickstart --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>



<h2 id="生产与消费"><a href="#生产与消费" class="headerlink" title="生产与消费"></a>生产与消费</h2><h5 id="启动生产者"><a href="#启动生产者" class="headerlink" title="启动生产者"></a>启动生产者</h5><p>启动完毕后，在控制台输入的内容将会写入到<code>topic</code>中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --topic quickstart --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>

<h5 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --topic quickstart --from-beginning --bootstrap-server localhost:9092</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/Kafka%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/Kafka%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">Kafka特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-13 20:06:09 / 修改时间：20:01:04" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          
            <span id="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/Kafka%E7%89%B9%E6%80%A7/" class="post-meta-item leancloud_visitors" data-flag-title="Kafka特性" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="EOS"><a href="#EOS" class="headerlink" title="EOS"></a>EOS</h3><p><strong>EOS（exactly once semantics）：精确一次处理语义</strong></p>
<p>Kafka的EOS体现在三个方面：</p>
<ol>
<li>幂等：保证消息发到一个分区只会发一次，分区不会有重复消息。</li>
<li>事务：保证原子性的写入到多个分区，要么全部写入成功，要么全部失败</li>
<li>流式EOS</li>
</ol>
<p><strong>幂等的实现</strong></p>
<p>引入producer id（pid），每个batch消息包含了pid以及起始和结束的序列号（从0开始递增）</p>
<p>broker接收消息时，判断是否是同一个生产者发送过的相同消息，就可以实现去重。</p>
<p>具体的判断逻辑是和上次的batch信息相比，如果pid、初始和结束序列号都相等，则判断为重复。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/docker/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/docker/docker/" class="post-title-link" itemprop="url">docker使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-13 20:06:09 / 修改时间：20:09:33" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">虚拟机相关</span></a>
                </span>
            </span>

          
            <span id="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/docker/docker/" class="post-meta-item leancloud_visitors" data-flag-title="docker使用" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在传统项目中，开发和运维的对接往往会出现环境不一致的问题，即使能够统一环境，也需要进行很多配置，非常麻烦。</p>
<p>所以人们就提出一种方式，即</p>
<blockquote>
<p>把开发时的环境抽离并保存下来，当其他地方需要运行项目时，直接拉取这个环境，就省去了麻烦的配置过程。</p>
</blockquote>
<p>这也就是docker的思想。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote>
<p> docker采用容器的思想，把镜像配置在容器中，当其他人需要运行项目时，只需要从docker仓库中拉去相应的镜像，即可解决环境冲突问题。</p>
</blockquote>
<blockquote>
<p>轻巧，和VM相比，他只需要几兆空间，因为只用到了核心命令等</p>
</blockquote>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><blockquote>
<p>官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
</blockquote>
<h3 id="1-检查环境"><a href="#1-检查环境" class="headerlink" title="1.检查环境"></a>1.检查环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r              <span class="comment"># 查看内核版本，需要3.1及以上</span></span><br><span class="line">cat /etc/os-release   <span class="comment"># 查看CentOS版本，需要7以上</span></span><br></pre></td></tr></table></figure>

<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.install </span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.set repository  not sure</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo </span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.update index</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.install docker-ce</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.start docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># sure</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>

<h2 id="三、docker组件介绍"><a href="#三、docker组件介绍" class="headerlink" title="三、docker组件介绍"></a>三、docker组件介绍</h2><p><strong>docker的核心三大组件为：镜像、容器和仓库</strong></p>
<p>三者的关系如下所示：</p>
<img data-src="https://gitee.com/aurora1004/pictures/raw/master/docker_component.png" alt="docker_component" style="zoom: 67%;" />

<p>在谈这些之前，我们先要了解下Linux相关的一些基础知识。</p>
<p>Linux操作系统分为两部分，<strong>内核与用户空间</strong>。Linux真正<strong>核心</strong>部分在于内核，而<strong>用户空间</strong>只是各大厂商在内核基础上添加自己的软件与工具集形成的发布版本。</p>
<p><strong>镜像</strong></p>
<blockquote>
<p>docker镜像实际上是由一层一层的系统文件组成，这种层级的文件系统被称为UnionFS( Union file system  统一文件系统)，镜像可以基于dockerfile构建，dockerfile是一个描述文件，里面包含了若干条密令，每条命令都会对基础文件系统创建新的层次结构。</p>
</blockquote>
<p><strong>镜像仓库</strong></p>
<p>镜像仓库顾名思义便是用来存放镜像的，docker提供了一个注册服务器（register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像，docker运作中使用的默认仓库是docker hub公共仓库。</p>
<p><strong>容器</strong></p>
<p>docker容器是由docker镜像创建的运行实例。</p>
<p>docker容器类似虚拟机，可以执行包含启动，停止，删除等。每个容器间是相互隔离的。</p>
<p>容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件，因此可以看作是一个简易版的Linux环境（包含root用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序。</p>
<h2 id="四、常用命令"><a href="#四、常用命令" class="headerlink" title="四、常用命令"></a>四、常用命令</h2><h3 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1.帮助命令"></a>1.帮助命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info    <span class="comment"># 显示系统信息，包括容器和镜像</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h3 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2.镜像命令"></a>2.镜像命令</h3><h5 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地主机上的所有镜像</span></span><br><span class="line">docker images  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">	- a <span class="comment"># all</span></span><br><span class="line">	- q <span class="comment"># 只显示镜像id</span></span><br></pre></td></tr></table></figure>

<h5 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在docker hub中搜索镜像</span></span><br><span class="line">docker search mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选项</span></span><br><span class="line">	--filter	<span class="comment"># 搜索过滤 如 --filter=STARS=3000</span></span><br></pre></td></tr></table></figure>

<h5 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line"><span class="comment"># 拉取结果分析，待补充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定版本，注意，版本必须是存在的</span></span><br><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全部删除</span></span><br><span class="line">docker rmi -f $(docker images -aq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定id或名称</span></span><br><span class="line">docker rmi -f id或name</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3.容器命令"></a>3.容器命令</h3><p>首先，需要一个镜像才能运行容器。</p>
<h5 id="拉取cent-OS镜像"><a href="#拉取cent-OS镜像" class="headerlink" title="拉取cent OS镜像"></a>拉取cent OS镜像</h5><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker pull centOS</span></span><br></pre></td></tr></table></figure>

<h5 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="comment"># 参数</span></span><br><span class="line"> --name=<span class="string">&quot;Name&quot;</span> 用来区分容器</span><br><span class="line"> -d 后台运行</span><br><span class="line"> -it 启动并进入容器</span><br><span class="line"> -p 绑定端口，有多种方式</span><br><span class="line"> 	-p ip:主机端口:容器端口</span><br><span class="line"> 	-p 主机端口:容器端口(最常用)</span><br><span class="line"> 	-p 容器端口</span><br><span class="line"> 	容器端口</span><br><span class="line"> -P 随机指定端口 </span><br></pre></td></tr></table></figure>

<h5 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 查看正在运行和历史运行的容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 只显示id</span></span><br><span class="line">docker ps -q</span><br></pre></td></tr></table></figure>

<h5 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果在创建容器时加上了 -it，就会直接进入到容器中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.退出，但是容器也会停止</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.退出，容器不停止</span></span><br><span class="line">ctrl + p + q</span><br></pre></td></tr></table></figure>

<h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"></span><br><span class="line">docker ps -aq | xargs docker rm</span><br></pre></td></tr></table></figure>

<h5 id="启动和停止容器"><a href="#启动和停止容器" class="headerlink" title="启动和停止容器"></a>启动和停止容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start   <span class="comment"># 启动</span></span><br><span class="line">docker stop    <span class="comment"># 停止</span></span><br><span class="line">docker <span class="built_in">kill</span>    <span class="comment"># 强制停止</span></span><br><span class="line">docker restart <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure>

<h3 id="4-其他命令"><a href="#4-其他命令" class="headerlink" title="4.其他命令"></a>4.其他命令</h3><h5 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d 镜像名</span><br><span class="line"><span class="comment"># 发现容器停止了</span></span><br><span class="line"><span class="comment"># 因为docker必须要有一个前台进程运行着才行</span></span><br></pre></td></tr></table></figure>

<h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看指定id的10条日志</span></span><br><span class="line">docker logs -tf --tail 10 容器id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure>

<h5 id="查看镜像元数据"><a href="#查看镜像元数据" class="headerlink" title="查看镜像元数据"></a>查看镜像元数据</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">问题总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-13 20:06:09 / 修改时间：19:57:51" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/" itemprop="url" rel="index"><span itemprop="name">谷粒学苑</span></a>
                </span>
            </span>

          
            <span id="/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-meta-item leancloud_visitors" data-flag-title="问题总结" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-前端页面展示的日期为空"><a href="#1-前端页面展示的日期为空" class="headerlink" title="1.前端页面展示的日期为空"></a>1.前端页面展示的日期为空</h3><p>前端收到日期数据为空 <code>-&gt;</code> 后端读数据库得到日期为空 <code>-&gt;</code> 数据库中数据正常</p>
<p>最后定位问题出在实体类这儿：</p>
<blockquote>
<p>我用<code>@TableField</code>注解来指定实体类属性与表字段的映射关系，即属性update_time对应表中字段gmt_modified。</p>
<p>但是mybatis-plus默认会把实体类的属性转化成驼峰形式的<code>updateTime</code>，导致原先的映射对不上了，因此查询为空。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE, value = &quot;gmt_modified&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date updated_time;</span><br></pre></td></tr></table></figure>

<p><strong>解决方式（二选一!!!）</strong></p>
<p>①把属性修改成驼峰形式的（讲道理就该写成驼峰式的，当时脑子抽了…）</p>
<p><code>private Date updatedTime;</code></p>
<p>②或者关闭自动转驼峰</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml文件</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h3 id="2-枚举类型为空"><a href="#2-枚举类型为空" class="headerlink" title="2.枚举类型为空"></a>2.枚举类型为空</h3><p>同上问，数据库（int）中读出来的数据经mybatis plus转化为枚举后，变为空。</p>
<p>最后的做法是把表的字段类型由int改为tinyint(4)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">项目模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-13 20:06:09 / 修改时间：19:57:35" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/" itemprop="url" rel="index"><span itemprop="name">谷粒学苑</span></a>
                </span>
            </span>

          
            <span id="/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97/" class="post-meta-item leancloud_visitors" data-flag-title="项目模块" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="父工程介绍"><a href="#父工程介绍" class="headerlink" title="父工程介绍"></a>父工程介绍</h3><p>父工程的主要特点是：</p>
<ol>
<li>父工程使用<code>Spring Intializr</code>创建为SpringBoot项目，</li>
<li>使用<code>properties</code>和<code>dependencyManagement</code>进行总的依赖和版本管理。</li>
</ol>
<p>这样做的好处是可以让所有子模块都使用父工程的依赖和版本，从而<strong>确保各个子模块的依赖和版本保持一致</strong>。</p>
<p>如果某个子模块需要使用不同于父工程的版本，只需要在自己的模块中声明版本即可，这样就不会继承父工程的版本。</p>
<h3 id="讲师管理模块"><a href="#讲师管理模块" class="headerlink" title="讲师管理模块"></a>讲师管理模块</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">项目介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-13 20:06:09 / 修改时间：19:57:21" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/" itemprop="url" rel="index"><span itemprop="name">谷粒学苑</span></a>
                </span>
            </span>

          
            <span id="/2021/12/13/%E9%A1%B9%E7%9B%AE/%E8%B0%B7%E7%B2%92%E5%AD%A6%E8%8B%91/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/" class="post-meta-item leancloud_visitors" data-flag-title="项目介绍" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p><code>在线教育</code>：以网络为媒介的教学方式</p>
<p>谷粒学苑是一个在线教育平台，为学员和教师提供了一个学习与授课的平台。它借助互联网打破了时间与空间的限制，使得工作繁忙或是学习时间不固定的群体都能借此来充能。</p>
<h2 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h2><p>项目用户分为两类，管理员和普通用户。</p>
<p><strong>对于管理员来说，模块有：</strong></p>
<ol>
<li>讲师管理</li>
<li>课程分类管理</li>
<li>课程管理</li>
<li>统计分析</li>
<li>订单管理</li>
<li>banner</li>
<li>权限管理</li>
</ol>
<p><strong>对于普通用户来说，模块有：</strong></p>
<ol>
<li>首页数据展示</li>
<li>讲师列表和详情</li>
<li>课程列表和详情<ul>
<li>视频播放</li>
</ul>
</li>
<li>登录和注册</li>
<li><code>微信扫码登录</code></li>
<li><code>微信扫码支付</code></li>
</ol>
<h2 id="项目使用技术"><a href="#项目使用技术" class="headerlink" title="项目使用技术"></a>项目使用技术</h2><p><strong>后端</strong></p>
<ul>
<li>springboot</li>
<li>springcloud</li>
<li>mybatisplus</li>
<li>springsecurity</li>
</ul>
<p><strong>前端</strong></p>
<ul>
<li>vue+element-ui+axios+nodejs</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>阿里云oss</li>
<li>阿里云视频点播服务</li>
<li>阿里云短信服务</li>
<li>微信支付</li>
<li>docker</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/Vue/%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/Vue/%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">Vue指令学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-13 20:06:09 / 修改时间：19:59:49" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
                </span>
            </span>

          
            <span id="/2021/12/13/%E9%A1%B9%E7%9B%AE/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/Vue/%E6%8C%87%E4%BB%A4/" class="post-meta-item leancloud_visitors" data-flag-title="Vue指令学习" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h3><blockquote>
<p>代码部分只展示了关键部分</p>
</blockquote>
<h5 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h5><p>通过参数来设置标签内的值</p>
<p>注意，会覆盖标签内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&#39;demo&#39; v-text&#x3D;&#39;para&#39;&gt;被覆盖啦呀，真惨&lt;&#x2F;div&gt; </span><br></pre></td></tr></table></figure>

<h5 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h5><p>和 <code>v-text</code> 类似，区别在于 <code>v-html</code> 能解析成HTML，进行赋值</p>
<h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>绑定方法，<strong>简写形式如下</strong></p>
<p>另外，绑定方法可以具体化，如@keyup.enter表示键盘键入回车键后，调用某方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id&#x3D;&#39;demo&#39; @click&#x3D;&#39;method&#39; type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot;&gt;&lt;&#x2F;input&gt; </span><br></pre></td></tr></table></figure>

<h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p>用来改变元素的属性值，来使它隐藏或出现</p>
<p>注意，是通过修改属性的方式实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&#39;demo2&#39;&gt;</span><br><span class="line">       &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点击改变&quot; @click&#x3D;&#39;click_it&#39;&gt; </span><br><span class="line">       &lt;p v-show&#x3D;&quot;flag&quot;&gt;嘿嘿，会员内容哦&lt;&#x2F;p&gt;   </span><br><span class="line">   &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><h5 id="v-bind-单向绑定"><a href="#v-bind-单向绑定" class="headerlink" title="v-bind(单向绑定)"></a>v-bind(单向绑定)</h5><p>设置元素的内部属性，如src、<strong>class</strong></p>
<p><strong>简写形式如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&#39;demo&#39; &gt;</span><br><span class="line">        &lt;img v-bind:src&#x3D;&quot;para&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 下面的改变class属性比较重要 --&gt;</span><br><span class="line">&lt;div id&#x3D;&#39;demo&#39; &gt;</span><br><span class="line">        &lt;img :class&#x3D;&quot;&#123;clazz_type:isNeedToChange&#125;&quot;  v-bind:src&#x3D;&quot;para&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- 一些参数 --&gt;</span><br><span class="line">isNeedToChange: true</span><br><span class="line">.clazz_type &#123; border: 1px solid red; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="v-model-双向绑定"><a href="#v-model-双向绑定" class="headerlink" title="v-model(双向绑定)"></a>v-model(双向绑定)</h5><p>页面上的值发生变化时（比如用户输入内容），被绑定的变量也会变化。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><p>同样也是用来决定元素的隐藏与出现</p>
<p>但是它是通过修改DOM树的方式实现的</p>
<h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>遍历数组中的值，并利用一个模板显示出来</p>
<p>如下，<strong>li <strong>标签就是所谓的模板，在模板中添加</strong>遍历项student</strong>的名字和年龄</p>
<p>所以就会输出数组中所有学生的名字和年龄</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&#39;demo&#39; &gt;</span><br><span class="line">       &lt;ul&gt;</span><br><span class="line">           &lt;li v-for&#x3D;&quot;(student, index) in students&quot;&gt;</span><br><span class="line">               第&#123;&#123; index + 1 &#125;&#125;位同学叫&#123;&#123;student.name&#125;&#125;，年龄&#123;&#123;student.age&#125;&#125;</span><br><span class="line">           &lt;&#x2F;li&gt;</span><br><span class="line">       &lt;&#x2F;ul&gt;</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aurora"
      src="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
  <p class="site-author-name" itemprop="name">aurora</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">144</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Aurora-Ze" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Aurora-Ze" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:88775682whz@gmail.com" title="E-Mail → mailto:88775682whz@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      
      
       <div>
          <iframe class="cc-license motion-element" frameborder="no" border="0" marginwidth="0" marginheight="0" width="280" height="86" src="//music.163.com/outchain/player?type=2&id=3986241&auto=1&height=32"></iframe>
       </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aurora</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <span class="post-count">| 博客共95.3k字</span>
  </div>-->


<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("04/07/2021 15:54:40");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

        








      </div>
    </footer>
  </div>

  


  <script src=""></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/darkmode-js.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>


<script>
var options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: 'transparent', // default: '#fff'
  backgroundColor: 'transparent',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: true, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}
const darkmode = new Darkmode(options);
darkmode.showWidget();
</script>
<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
