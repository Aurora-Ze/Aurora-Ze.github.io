---
title: 二叉树最近公共祖先
categories: leetcode
top_img: https://gitee.com/aurora1004/pictures/raw/master/wallhaven-013gj1.jpg
cover: https://gitee.com/aurora1004/pictures/raw/master/wallhaven-013gj1.jpg
---

# 最近公共祖先

题目请看这里：[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

思路参考了大佬的题解：[后序遍历 DFS ，清晰图解](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/)

## 描述

给定两个节点p，q，在它们的公共祖先中找出最近的一个（包含自己）。

## 思路

![](https://gitee.com/aurora1004/pictures/raw/master/Snipaste_2021-04-27_11-23-17.png)

这类题可以用递归方式求解，那么具体怎么递归呢？

我们可以先处理左右子节点，然后根据左右子节点的情况，递推到父节点，这就是`后序遍历`的思想

**现在假设root是当前节点，left是子节点，right是右节点**

**递归终止条件：**

- 遍历到叶子节点
- 遇到目标节点

**递归过程：**

对`left`和`right`采取递归，得到返回值

**递归返回值（核心）：**

- `left`为空且`right`为空，说明当前节点的子树不存在目标节点，返回`null`
- `left`不为空且`right`不为空，说明目标节点分布在子树两侧，返回`root`
- `left`和`right`只有一个不为空，返回不为空的那个

## 代码

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) {
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
 
        if (left == null && right == null) {
            return null;
        } else if (left == null) {
            return right;
        } else if (right == null) {
            return left;
        }
        return root;
    }
```

