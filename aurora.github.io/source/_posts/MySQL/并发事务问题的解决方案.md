---
title: 事务并发解决方案
categories: MySQL
---

# 一、事务

关于事务的介绍，请看另一篇博客。

**解决并发事务访问，主要有两种方式：**

- **LBCC**（Lock Based Concurrent Control）


- **MVCC**（Multi-Version Concurrent Control）

### 相关问题

- 脏读，读到其他事务修改后未提交的数据
- 不可重复读，多次读数据，得到的不一致
- 幻读，多次读的结果不同（多了数据或少了数据）

### 事务隔离级别

| 级别\问题（是否存在） | 脏读 | 不可重复读 |      幻读      |
| :-------------------: | :--: | :--------: | :------------: |
|       读未提交        |  是  |     是     |       是       |
|       读已提交        |  否  |     是     |       是       |
|       可重复读        |  否  |     否     | 是（MVCC时有） |
|        串行化         |  否  |     否     |       否       |

# 二、LBCC

## 2.1锁的类型

官网链接：[MySQL :: MySQL 8.0 Reference Manual :: 15.7.1 InnoDB Locking](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)

查阅MySQL官网，得知InnoDB存储引擎提到了以下几种锁方案

1. 共享锁与排他锁 （行级别）

2. 意向锁 （表级别）

3. 记录锁

4. 间隙锁

5. Next-Key 锁

还有另外三种不做详细介绍，就简单说明一下概念

1. 插入意向锁
2. 自增锁
3. 预测锁

下面我们将依次介绍上述5种锁的概念

## 2.2共享锁与排他锁

共享锁和排他锁是InnoDB实现的行级别的锁。

`共享锁`又叫读锁，用来读取数据。多个共享锁可以同时存在。

`排他锁`又叫写锁，用来更新或删除数据（插入呢？），不能与其他锁并存

举个简单的例子

如果事务`T1`在读表中的记录`r`，那它就对记录`r`加了读锁

这时候事务`T2`想要对记录`r`进行一些操作

- 如果是读操作，`T2`可以直接对记录`r`加读锁
- 如果是写操作，`T2`必须等待`T1`释放锁之后，才能对记录`r`加写锁

## 2.3意向锁

### 2.3.1为什么要有意向锁呢？

针对一个场景：

如果要对一张表加**表锁**，就要先确保表中的**任意一行数据**都没有**被锁定**

那么就需要进行全表扫描来判断，效率十分低下

**而上述问题的本质，就是锁过于单一，只有读锁、写锁这些行级别锁的话，粒度较少，不具备灵活性。**

所以提出了意向锁的思想 。

### 2.3.2意向锁

> 意向读锁：表明一个事务**想要**对某行数据设置读锁。
>
> 意向写锁：表明一个事务**想要**对某行数据设置写锁。

光说这个概念可能不太好理解，我们结合官网上的描述，来分析下它的主要目的、协议吧。

### 2.3.3官方解释

**关于意向锁的解释**

> `InnoDB` supports *multiple granularity locking* which permits coexistence of row locks and table locks.
>
> `InnoDB`支持多粒度的锁来保证行锁和表锁的共存。
>
> Intention locks are `table-level` locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table. 
>
> 意向锁是表级别的锁，它代表一个事务之后想要获取的是什么类型（读锁或写锁）的锁。
>
> PS：实现了多粒度的锁。

**意向锁的主要目的**

> Intention locks do not block anything except full table requests (for example, `LOCK TABLES ... WRITE`). The main purpose of intention locks is to show that someone is locking a row, or going to lock a row in the table.
>
> 意向锁不会阻塞除`全表扫描`外的任何请求，它的主要目的就是表明其他事务正在锁，或者说将要锁某些记录。
>
> PS：结合上面的例子，有了意向锁之后，就不用靠全表扫描来判断当前事务是否可以加表锁

**意向锁的协议**

> Before a transaction can acquire a shared lock on a row in a table, it must first acquire an `IS` lock or stronger on the table.
>
> 一个事务获取某行的读锁之前，必须先获取表的意向读锁。
>
> Before a transaction can acquire an exclusive lock on a row in a table, it must first acquire an `IX` lock on the table.
>
> 一个事务获取某行的写锁之前，必须先获取表的意向写锁。

### 2.3.4锁的具体使用

首先，我们要了解意向锁和读写锁的共存关系（是否兼容）

|        |  IS  |  IX  |  S   |  X   |
| :----: | :--: | :--: | :--: | :--: |
| **IS** |  是  |  是  |  是  |  否  |
| **IX** |  是  |  是  |  否  |  否  |
| **S**  |  是  |  否  |  是  |  否  |
| **X**  |  否  |  否  |  否  |  否  |

**分析：**

意向锁之间：仅仅代表一个加锁的意向，所以意向锁之间不冲突

读写锁之间：读锁与读锁不冲突，写锁与其他锁（这里只讨论读写锁）都冲突

混合：要注意有读锁的情况下，意向写锁会冲突，即不能有写的念头。

**用法：**

从官网摘录一段select的语句结构

```sql
SELECT
	...
	[FOR {UPDATE | SHARE}
        [OF tbl_name [, tbl_name] ...]
        [NOWAIT | SKIP LOCKED]
      | LOCK IN SHARE MODE]
```

**使用意向读锁：**

`select ... for share`或`select ... lock in share mode`

两种方式来获取IS锁和对应记录的S锁，基本上是等价的

区别的话

1. 看上面select语句的格式，可以发现`for share`可以添加一些参数，参数在后面介绍

2. `lock in share mode`提供向后兼容性。

**使用意向写锁：**

`select ... for update`语句会先尝试获取IX锁，然后再获取目标记录的写锁

如果获取不到，则会阻塞等待。（如果超时了就报错）

**参数说明：**

- nowait：不等待锁释放，立刻执行，获取不到锁就报错
- skip locked：也是立刻执行，但忽略那些被加锁的数据，只操作不加锁的数据。

这两个参数在基于语句复制的情况下，是不安全的（官网上提到，但我不懂...猜测一下，可能是在有主从数据库的时候，会不安全吧）

[如果想看更详细的，请转至官网处](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html)

------

下面开始是一些具体锁的介绍，先贴一张图大致表示一下

![lock_concret](https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210502173400.png)

## 2.4记录锁（锁定记录）

在进行等值查询时，锁住**匹配**到的记录。确切地说，应该是锁住记录的主键（或隐式主键）

例如`select * from table1 where id = 4 for update`就是锁住了`id = 4`的记录

## 2.5间隙锁（锁定范围）

在查询时，锁定**区间范围**

①`select * from table1 where id = 6 for update`

②`select * from table1 where id > 20 for update`

假设表的记录为**1，4，7，10**

那么语句①锁住区间（4，7）；语句②锁住区间（10，+∞）

**间隙锁之间并不冲突**

## 2.6临界锁（锁定范围，左开右闭）

条件：进行范围查询时，包含**区间**和**具体记录**

`select * from table where id > 5 and id < 9 for update`

那么锁定的范围为(4，7] 和 (7，10]，即(4，10]

我们可以发现，**临界锁 = 间隙锁 + 记录锁**

***而间隙锁锁住区间，不让其他事务进行插入，目的就在于避免幻读问题的出现***

------

讲完这些锁之后，我们谈谈在**不同隔离级别**下**锁**的**实现**：

|   隔离级别   |                           机制                           |
| :----------: | :------------------------------------------------------: |
|      RU      |                          不加锁                          |
| Serializable | 所有select语句隐式地转化成共享锁，会与update、delete互斥 |

| 隔离级别 | 普通select语句 | 加锁的select和更新语句 |
| :------: | :------------: | :--------------------: |
|    RC    |      MVCC      |         记录锁         |
|    RR    |      MVCC      | 记录锁、间隙锁、临界锁 |

> ①普通查询时，为什么RR可以解决不可重复读，而RC不可以
>
> 两者都采用MVCC，而因为RR的快照读read-view使用的是同一个，而RC是每次查询生成一次新的read-view

# 三、MVCC

## 3.1定义

用于实现数据库的并发访问的一种方法，全称为多版本并发控制。

## 3.2前置概念

在学习MVCC前，需要先知道两个概念

- **当前读**

读取记录的最新版本，读取时还要加锁，保证其他并发事务不能修改当前记录，如共享锁、排他锁都是当前读

- **快照读**

不加锁的、非阻塞的读。快照读的实现是基于多版本并发控制的，避免加锁操作，降低开销

读到的数据不一定是最新数据，可能是历史版本

## 3.3思想

>  维持一个数据的多个版本，使得读写操作没有冲突

## 3.4实现

隐式字段 + undo回滚日志 + 快照

- **隐式字段**

> 每行记录除了有用户定义的字段外，还有隐式字段，如事务id、回滚指针、自增ID

依次解释：

事务id是指**修改过**当前记录的**最近**的一次事务id

回滚指针，指向的是回滚日志中的关于**这条记录**的**上一个版本**

自增ID，当表没有设定主键时，会采用自增ID来作为主键，构建主键索引

- **undo回滚日志**

记录每次修改的操作，可从前往后遍历来进行数据回滚

在进行**修改（更新、插入、删除）**操作时，mysql会生成一条日志（主键+当前事务id+回滚指针，指向前一条记录）

删除只是把标志位改为true，即逻辑删除

- **read-view**

> read-view是事务进行快照读时产生的读视图，记录并维护了系统中当前较为活跃的事务id

## 3.5例子

在某次事务查询时，得到read-view 为 **[100,200,300]**

 可以看出活跃事务中最小id为100，最大id为300

从回滚日志中依次向后遍历，假设每次遍历到的事务id为x

则有以下三种情况：

1. x < 100 表示此事务已提交，数据可用

2. x > 300 表示此事务还未开始（不确定？）

3. 在100和300中间，此时就要查看read-view，如果事务id在read-view里面，即说明此事务是活跃的，还没提交，数据不可用

   否则数据就可用。

## 3.6RR和RC隔离级别下

针对同一个事务来说，

- 读已提交：每次查询都会生成新的read-view

- 可重复读：只用第一次查询时生成的read-view（解决了不可重复读）

# 四、补充问题

## 4.1死锁

**定义**

这里的死锁可以理解成两个及以上的事务在共同竞争锁资源，而产生的等待现象。

**解决方案一**

设置一个超时等待时间，超时后对某个事务进行回滚，然后其他事务就可以执行下去

但是光靠超时来解决的话，可能会有大量事务要进行回滚，会非常耗时

**解决方案二**

等待图，这可以算是一种死锁检测算法。

画出各个事务之间的依赖关系，如果形成环路，说明存在死锁。

## 4.2锁升级

~~知识盲区...~~

InnoDB存储引擎并不存在锁升级的情况，因为它并不是根据每个记录来产生行锁的。

它是根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式

