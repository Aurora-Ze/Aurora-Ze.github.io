---
title: 单例模式
categories: 设计模式
tags:
	- 设计模式之创建型
---

## 单例模式

### 描述

确保类只有一个实例

![img](https://gitee.com/aurora1004/pictures/raw/master/eca1f422-8381-409b-ad04-98ef39ae38ba.png)

### 懒汉式

##### 版本1：普通单例

把构造方法变为私有，通过静态方法来获取静态对象实例。

只有在用到对象时，才进行创建，节省了资源。

**但是，多个线程同时进入判断后，会实例化多个对象，所以线程不安全。**

```java
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
```

##### 版本2：无脑加锁

对获取对象的方法进行**加锁**，使同一时间只能有一个线程访问该方法

其他线程想要调用该方法，就得等待，因此等待时间会变长，性能较差，不推荐。

```java
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static synchronized  Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
```

##### 版本3：双重校验锁

我们可以只对判断语句内部加锁，这样只有对象还没被实例化过，才会进行加锁并创建对象。

如果对象被实例化过，其他线程就不会阻塞，直接得到对象。

**注意**

**1.这里要用到两个if判断，如果只有外层一个判断，仍然会有多个线程进入判断内部，依次执行实例化操作**

**2.uniqueInstance使用volatile修饰，防止指令重排序**

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
        	synchronized (Singleton.class) {
        		if (uniqueInstance == null) {
        			uniqueInstance = new Singleton();
        		}
    		}
        }
        return uniqueInstance;
    }
}
```

##### 版本4：静态内部类

加载外部类时，内部类并不会被加载到内存中。

只有调用`getUniqueInstance()`，触发了`SingletonHolder.INSTANCE`后，才会加载内部类，并实例化对象。

这种实现不仅具有延迟初始化，还利用了JVM提供对线程安全的支持。

```Java
public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

##### 版本5：枚举类

```java
public enum Singleton {
    INSTANCE;
}

public static void main(String[] args) {
	Singleton firstSingleton = Singleton.INSTANCE;
}
```

### 饿汉式

上面线程不安全的原因，在于多个线程同时进入判断后，会实例化多个对象

所以可以直接把对象实例化，但这样丢失了节省资源的好处。

```Java
public class Singleton {

    private static Singleton uniqueInstance = new Singleton();

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        return uniqueInstance;
    }
}
```

