---
title: 项目介绍
categories: tensquare
---

#### 一、项目介绍

###### 1. 背景

本项目旨在搭建一个交流平台，主要目标是爱好写作、分享博客的各位小伙伴们

用户可以在其中浏览文章，发布文章、发表评论等。

当遇到美文时，可以点赞，或关注作者，以及时获取其最新推送

###### 2. 需求分析

用户：发布文章，修改文章，删除文章，点赞，发布评论，关注作者

系统：推送消息给用户

###### 3. 模块划分

按功能来划分，可以分成以下模块

- 文章模块

对文章进行操作，包括发布、修改、删除、点赞等

- 评论模块

用户在某一篇文章下发表评论、删除评论

- 用户模块

用户登录、注册

- 消息模块

消息推送，包括文章被读者点赞，或者是关注的作者发表了新文章

###### 4. 架构及技术选型

- ###### 开发模式

采用前后端分离的开发方式

- 后端架构

采用当前主流的基于 Spring Cloud 的微服务架构

用到的技术有：Spring Boot、Spring Cloud、MyBatis Plus、MySQL

用到的组件有：

|   组件   |                 描述                 |
| :------: | :----------------------------------: |
|  Eureka  |             用来注册服务             |
|  Maven   |               管理依赖               |
|  Feign   |              服务间调用              |
|  Redis   |      缓存用户间的订阅和点赞关系      |
|  netty   |  异步通信，配合消息队列完成消息推送  |
| RabbitMQ |             存放通知消息             |
| MongoDB  | 持久化存储评论数据（不太重要的数据） |
|  docker  |            部署虚拟化容器            |

###### 5. 补充

模块划分后，又添加了common模块和encrypt模块

 `common` 用来部署一些公共部分，如状态码StatusCode，返回结果Result，分页查询结果PageResult、ID生成器IdWorker

 `encrypt` 用来进行接口加密，前端用公钥对数据进行加密，后端用私钥进行解密

#### 二、难点总结

##### 1. 分页查询

controller层

```java
@RequestMapping(value = "search/{page}/{size}", method = RequestMethod.POST)
public Result findByPage(@PathVariable Integer page,
                         @PathVariable Integer size,
                         @RequestBody Map<String,Object> map) {      // json数据转成map而不是对象，方便遍历属性
    Page<Article> pageData = articleService.search(map, page, size); // 调用service层的方法
    PageResult<Article> pageResult = new PageResult<>(               // 封装成自己定义的结果类
            pageData.getTotal(), pageData.getRecords()
    );
    return new Result(true, StatusCode.OK, "查询成功", pageResult);
}
```

service层

```java
public Page<Article> search(Map<String, Object> map, Integer page, Integer size) {
    EntityWrapper<Article> wrapper = new EntityWrapper<Article>();
    for (String field : map.keySet()) {
        wrapper.eq(null != map.get(field), field, map.get(field));// 不考虑字段值为空
    }
    Page<Article> pageData = new Page<>(page, size);
    List list = articleDao.selectPage(pageData, wrapper); // 传入分页参数（Page）、查询条件（EntityWrapper）
    pageData.setRecords(list);                            // 目的是找到和 map 中非空的键值对相匹配的数据
    return pageData;
}
```

##### 2. 使用redis

```java
String userKey = "article_subscribe_" + userId;  // 作者集合
String authorKey = "article_author_" + authorId; // 读者集合
Boolean flag = redisTemplate.boundSetOps(userKey).isMember(authorId);// 查询该用户是否已经订阅作者

if (flag) {
    // 取消订阅
    redisTemplate.boundSetOps(userKey).remove(authorId); // redis 删除指定集合的某条数据
    redisTemplate.boundSetOps(authorKey).remove(userId);
    // 删除绑定关系
    rabbitAdmin.removeBinding(binding);
    return false;
} else {
    // 进行订阅
    redisTemplate.boundSetOps(userKey).add(authorId);    // redis 往指定集合添加一条数据
    redisTemplate.boundSetOps(authorKey).add(userId);
    // 声明队列、添加绑定关系
    rabbitAdmin.declareQueue(queue);
    rabbitAdmin.declareBinding(binding);
    return true;
}
```

##### 3.rabbitMQ使用

```Java
// 创建管理器
RabbitAdmin rabbitAdmin = new RabbitAdmin(rabbitTemplate.getConnectionFactory());
// 声明交换机，路由键为article_subscribe，消息通过交换机来发送
DirectExchange exchange = new DirectExchange("article_subscribe");
rabbitAdmin.declareExchange(exchange);
// 创建消息队列
Queue queue = new Queue("article_subscribe_" +  userId, true);
// 绑定交换机与队列
Binding binding = BindingBuilder.bind(queue).to(exchange).with(authorId);

boolean flag; // 获取是否订阅的关系
if (flag) {
    //如果已经订阅，就取消绑定队列与交换机的绑定关系
	rabbitAdmin.removeBinding(binding);    
} else {
	rabbitAdmin.declareQueue(queue);
    rabbitAdmin.declareBinding(binding);
}
//...关注作者发布文章后，生成消息推送
rabbitTemplate.convertAndSend("article_subscribe", userId, id);
```