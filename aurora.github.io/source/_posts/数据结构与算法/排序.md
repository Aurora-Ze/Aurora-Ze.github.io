---
title: 排序算法
categories: 数据结构与算法
---

# 笔记——排序

## 一、简单排序

#### 1.冒泡排序

- **说明**

  每次比较**相邻**两个元素大小，把较大的移到后面

  在第k轮排序完成后（k从1开始），数组的**最后k位**是排好序的

- **代码**

```Java
public void bubbleSort (int[] nums) {
    //每排完一个元素，i值-1
    for ( int i = nums.length - 1; i > 0; i -- ) {
        //比较相邻元素
        for ( int j = 0 ; j < i; j ++ ) {
            if ( nums[j] > nums[j+1] ) {
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
}
```

- **复杂度分析**

  1. 时间复杂度为	$O(n^2)$

------



#### 2.选择排序

- **组成**

`已排序 + 未排序`

- **说明**

  每次在已排序部分的末尾添加一个位置，然后所有未排序元素竞争这个位置，最小的进入

  具体地说，就是从前往后，在数组中找到未排序的位置，然后遍历后面剩余数字，**找到最小的**，交换到前面去

- **代码**

  ```Java
  public void selectSort ( int[] nums ) {
      for ( int i = 0; i < nums.length; i ++ ) {
          int minIndex = i;//前i个元素都是排好序的
          for ( int j = i + 1; j < nums.length; j ++ ) {
              if ( nums[j] < nums[i] ) {
                  minIndex = j;
              }
          }
          int temp = nums[i];
          nums[i] = nums[minIndex];
          nums[minIndex] = temp;
      }
  }
  ```

  

- **复杂度分析**

  1. 时间复杂度	$O(n^2)$

------



#### 3.插入排序

- **说明**

  像是打扑克牌一样，每拿到一张牌，就遍历前面，找到合适的位置插入。

  具体来说，应该是从排好序的元素里，**从后往前**依次判断是否要交换

- **对比**

> **选择排序**和**插入排序**，都有一部分是排序好的，不同之处在于：
>
> <u>**选择排序**</u>是从没排序的元素里找到最小的，然后放到已经排序部分的最后；
>
> 而**<u>插入排序</u>**是在已经排序的元素（严格来说，并没有排完序，只是有序）里找到合适的位置，插入当前元素

- **代码**

```Java
public void insertSort ( int[] nums ) {
    //从第二个元素开始
	for ( int i = 1; i < nums.length; i ++ ) {
        //依次向前一个元素比较
		for ( int j = i; j > 0; j -- ) {
			if ( nums[j] < nums[j-1] ) {
				int temp = nums[j-1];
				nums[j-1] = nums[j];
				nums[j] = temp;
			} else {
			//表明元素已经在正确位置
				break;
			}
		}
	}
}
```

- **优化版代码**

```Java
public void insertSort ( int[] nums ) {
    
	for ( int i = 1; i < nums.length; i ++ ) {
        // 用临时变量tmp存储当前值
        // 然后让大于tmp的数字都向后移动一位，留出空位来插入
        int tmp = nums[i]
		int j = i;
        while (j > 0 && tmp < nums[j-1]) {
            nums[j] = nums[j-1];
            j--;
        }
        nums[j] = tmp;
	}
}
```



- **复杂度分析**
  1. 时间复杂度	$O(n^2)$

------



## 二、进阶排序

#### 1.希尔排序(面试不重要)

- **说明**

1. 希尔排序是插入排序的改良版，插入排序在寻找插入位置时，需要进行相邻元素的多次比较与交换，而希尔排序则定义了`增长量`，可以间隔的比较与交换。
2. 希尔排序按`增长量`来分组，对每组数据进行插入排序；然后减小`增长量`，重复操作。

- **代码**

```Java
public void shellSort ( int[] nums ) {
	//初始化增长量
	int h = 1;
	while ( h < nums.length/2 ) {
		h = h * 2 + 1;
	}
	//开始排序
	while ( h >= 1 ) {
		//进阶版插入排序
		for ( int i = h; i < nums.length; i ++ ) {
			for ( int j = i; j >= h; j -= h ) {
				if ( nums[j] < nums[j-h] ) {
					int temp = nums[j-h];
					nums[j-h] = nums[j];
					nums[j] = temp;
				} else {
					break;
				}
			}
		}
		//更新增长量
		h = h / 2;
	} 
}
```



- **~~复杂度分析~~**

emmm......，超纲了，不用了解

------

#### 2.快速排序

- 说明

1. 快速排序可以看作是冒泡排序的进阶版，区别在于快排的交换是`跳跃式`的
2. 快排使用了一个`基准点`，每次排序的目的都是把小于基准点的数放到基准点左边，大于等于的数放在右边
3. 数组长度较小时，使用插入排序而不是快速排序

- 代码（基础版）

```Java
class Solution {
    final Random RANDOM = new Random();
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }
    public void quickSort(int[] nums, int left, int right) {
        if (right - left <= 7) {
            insertSort(nums, left, right);
            return;
        }
        int index = partition(nums, left, right);
        quickSort(nums, left, index - 1);
        quickSort(nums, index + 1, right);
    }
    public void insertSort(int[] nums, int left, int right) {
        for (int i = left + 1; i <= right; ++ i) {
            int tmp = nums[i];
            int j = i;
            while (j > left && tmp < nums[j-1]) {
                nums[j] = nums[j-1];
                j --;
            }
            nums[j] = tmp;
        }
    }
    public int partition(int[] nums, int left, int right) {
        int randomIndex = RANDOM.nextInt(right - left + 1) + left; // 包含nums[right]
        swap(nums, left, randomIndex);

        int pivot = nums[left]; // 定义基准值
        int lt = left;          // 小于pivot的最右边
        for (int i = left + 1; i <= right; ++ i) {
            if (nums[i] < pivot) {
                lt ++;
                swap(nums, lt, i);
            }
        }
        swap(nums, lt, left);
        return lt;
    }
    public void swap(int[] nums, int a, int b) {
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}
```

- 双指针碰撞

```Java
public int partition(int[] nums, int left, int right) {
        int randomIndex = RANDOM.nextInt(right - left + 1) + left; // 包含nums[right]
        swap(nums, left, randomIndex);
        int pivot = nums[left];
        int lt = left + 1;
        int gt = right;
        while (true) {
            while (lt <= right && nums[lt] < pivot) {
                lt ++;
            }
            while (gt >= left && nums[gt] > pivot) {
                gt --;
            }
            if (lt >= gt) break;
            // 等概分布
            swap(nums, lt, gt);
            lt ++;
            gt --;
        }
        swap(nums, left, gt);
        return gt;
    }
```

- 三指针（相同元素划分到基准值，不进行递归）

```Java
// 待补充
```

- 复杂度分析

  1. 时间复杂度

     最坏情况为$O(n^2)$，平均为$O(nlogn)$

#### 3.归并排序

- **说明**

将待排序的数字一分为二，排序子数组后，最后进行合并

- **优化**
  - 划分的数组长度小于等于7时，采用插入排序
  - 使用全局辅助数组temp，避免多次创建
- **代码**

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        int[] temp = new int[nums.length];
        part(nums, 0, nums.length - 1, temp);
        return nums;
    }
    /*
    *   分治
    */
    public void part(int[] nums, int left, int right, int[] temp) {
        if (right - left + 1 <= 7) {
            insertSort(nums, left, right);
            return;
        }
        int mid = (right + left) >>> 1;
        part(nums, left, mid, temp);
        part(nums, mid + 1, right, temp);

        if (nums[mid] <= nums[mid+1]) {
            return;
        }
        merge(nums, left, mid, right, temp);
    }
    /*
    *   合并
    */
    public void merge(int[] nums, int left, int mid, int right, int[] temp) {
        System.arraycopy(nums, left, temp, left, right - left + 1);
        int i = left;
        int j = mid + 1; 
        for (int k = left; k <= right; k ++) {
            if (i == mid + 1) {
                nums[k] = temp[j];
                j++;
            } else if (j == right + 1) {
                nums[k] = temp[i];
                i++;
            } else if (temp[i] <= temp[j]) {
                nums[k] = temp[i];
                i++;
            } else {
                nums[k] = temp[j];
                j++;
            } 
        }
    }

    /*
    *   插入排序
    */
    public void insertSort(int[] nums, int left, int right) {
        for (int i = left + 1; i <= right; i ++) {
            int tmp = nums[i];
            int j = i;
            while (j > left && tmp < nums[j-1]) {
                nums[j] = nums[j-1];
                j --;
            }
            nums[j] = tmp;
        }
    }
}
```

- **复杂度说明**
  - 时间复杂度$O(nlogn)$
  - 空间复杂度$O(n)$

#### 4.堆排序

- 说明

用数组实现，先按大根堆来建堆，然后下沉后形成升序的数组。

- 实现

```Java
public void sort(int[] nums){
 
    for (int i = (nums.length - 1) / 2; i >= 0; --i) { 
        adjustHeap(nums, i, nums.length);
    }
    for (int j = nums.length - 1; j > 0; --j) {
        swap(nums, 0, j);
        adjustHeap(nums, 0, j);
    }
}

public void swap(int[] nums, int index1, int index2) {
    int tmp = nums[index1];
    nums[index1] = nums[index2];
    nums[index2] = tmp;
}
```



------

## 三、排序算法的稳定性总结

| 排序算法 | 是否稳定 |                             原因                             |
| :------: | :------: | :----------------------------------------------------------: |
| 冒泡排序 |   稳定   |        因为只有前一个元素大于后一个元素时，才发生交换        |
| 选择排序 |  不稳定  |      为每个位置选择当前最小的元素进行交换，会破坏稳定性      |
| 插入排序 |   稳定   |         原因和冒泡排序类似，只有大于时才插入到其后面         |
| 希尔排序 |  不稳定  | 首次排序时是稳定的，但他分成了好几组，不同组之间排序时可能会打乱顺序 |
| 快速排序 |  不稳定  |               基准值左右两侧交换时会破坏稳定性               |

