---
title: 红黑树
categories: 数据结构与算法
---



## 红黑树

##### 1. 定义

> 红黑树是一种含有红黑节点并能**自平衡**的**二叉查找树**

- 每个节点只能是红色或黑色
- 根节点为黑色
- 每个叶子节点（这里是指为空的节点）是黑色
- **红色**节点的**子节点**一定是**黑色**
- **任意一个节点**到每个**叶子节点**的路径都包含**相同数量**的黑色节点

##### 2. 插入元素（每个新插入的节点默认是红色）

红黑树在插入节点时：

1. 先按搜索的顺序，把节点放在合适位置（类似二叉查找）
2. 然后判断是否满足红黑树定义
3. 不满足就会发生**旋转**和**变色**现象

判断条件如下：

|            情况            |          做法          |
| :------------------------: | :--------------------: |
|        父节点为黑色        |       什么都不做       |
| 父节点红色，且叔叔也是红色 | 父亲叔叔变黑，祖父变红 |
|  父红色，且叔叔为空或黑色  |      旋转 + 变色       |

<img src="https://gitee.com/aurora1004/pictures/raw/master/20210430111115.png" style="zoom:67%;" />

父节点红色，叔叔为黑色的情形：



##### 3. HashMap红黑树部分源码

红黑树插入节点 `x` 时，进行了以下判断：

1. 若x的父亲是null，说明x是根节点，直接返回x（这里x就是根节点了，所以返回x）
2. 若x的父亲是黑色 或者 x的祖父是空（即x的父亲为根节点，而根节点一定是黑色的），直接返回根节点
3. 

```Java
static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,
                                                    TreeNode<K,V> x) {
            x.red = true; // 要插入的节点
            for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {
                if ((xp = x.parent) == null) { // x父亲为空，即x为根节点
                    x.red = false;
                    return x;
                }
                else if (!xp.red || (xpp = xp.parent) == null)// x父亲为黑色 或者 x祖父为空，不用调整
                    return root;
                if (xp == (xppl = xpp.left)) {
                    if ((xppr = xpp.right) != null && xppr.red) {// 如果父亲叔叔都是红色
                        xppr.red = false;						 // 则把父亲叔叔改成黑色，祖父改成红色
                        xp.red = false;							 // 更新当前节点为祖父，进行下一次循环
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.right) {
                            root = rotateLeft(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateRight(root, xpp);
                            }
                        }
                    }
                }
                else {
                    if (xppl != null && xppl.red) {
                        xppl.red = false;
                        xp.red = false;
                        xpp.red = true;
                        x = xpp;
                    }
                    else {
                        if (x == xp.left) {
                            root = rotateRight(root, x = xp);
                            xpp = (xp = x.parent) == null ? null : xp.parent;
                        }
                        if (xp != null) {
                            xp.red = false;
                            if (xpp != null) {
                                xpp.red = true;
                                root = rotateLeft(root, xpp);
                            }
                        }
                    }
                }
            }
        }
```

![](E:\吴和泽\NotepadFile\resources\rotate.png)

**左旋转，即以旋转点为中心，逆时针旋转**

**右旋，则是以旋转点为中心，顺时针旋转**

```Java
static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,
                                              TreeNode<K,V> p) {
            TreeNode<K,V> r, pp, rl;
            if (p != null && (r = p.right) != null) {
                if ((rl = p.right = r.left) != null) // 这里分两步，赋值和判断											   									 	 // 赋值：r1 = r.left 且 p.right = r.left
                    rl.parent = p;					 // 判断：r.left != null
                if ((pp = r.parent = p.parent) == null)
                    (root = r).red = false;
                else if (pp.left == p)
                    pp.left = r;
                else
                    pp.right = r;
                r.left = p;
                p.parent = r;
            }
            return root;
        }
```

