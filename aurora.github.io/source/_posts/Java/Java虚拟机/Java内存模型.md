---
title: Java内存模型
categories: JVM
---

# 一、背景

在介绍Java内存模型之前，我们先了解下计算机的内存模型，这对Java的内存模型有着很大的参考作用。

## 1.1计算机—多任务处理

> 当前计算机大部分是支持多任务处理；在许多场景下，计算机可以同时处理多个任务。

为什么这样做

1. 压榨CPU资源

   如果只有一个任务，它进行I/O操作时，CPU会空闲

   因此安排多任务执行，避免资源浪费

2. 多请求的客观事实

   一个服务器端往往会同时收到几个客户端的请求

## 1.2计算机—内存模型

### 版本1

根据冯诺依曼提出的计算机体系结构，我们令处理器和主存进行通信：

<img src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504152643.png" alt="image-20210504152623819" style="zoom: 67%;" />

**缺陷：**

处理器访问寄存器的速度远快于访问主存的速度，而每次都要从主存读数据，要等待很久

### 版本2.1

添加高速缓存，把常用的数据放在缓存中，供处理器直接访问。它的访问速度仅次于寄存器，但是比主存快很多。

<img src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504153055.png" alt="image-20210504153047767" style="zoom:67%;" />

**缺陷：**

- 缓存一致性：多个高速缓存如何保证数据的一致（或者说，同步）

- 指令重排序问题：

  处理器内部会优化指令的顺序，以保证CPU资源的高效利用；

  指令重排序保证当前任务内排序后的结果是和原先保持一致的，但不保证多任务间数据的协调。

### 版本2.2

添加缓存一致性协议，来确保缓存间数据的可见性

**可见性**就是指当一个高速缓存内的数据发生变化时，其他拥有该数据的高速缓存应该能察觉到它的变化。

<img src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504154702.png" alt="image-20210504154658533" style="zoom:67%;" />

# 二、Java内存模型

Java内存模型设计如下：

可以看到，它和计算机的内存模型基本一致。

- Java线程用来执行任务，每个线程都拥有工作内存；

- 所有的任务都必须在工作内存中执行。

- 所有的数据都存放在主内存中，通过`save`和`load`等操作加载到工作内存中

<img src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504155538.png" alt="image-20210504155535163" style="zoom:67%;" />

## 2.1原子操作

Java提供了一些原子的、不可再分的操作，如下。

### 作用于主内存中的变量

|  指令  |                       描述                        |
| :----: | :-----------------------------------------------: |
|  lock  |         加锁，标志一个变量为线程独占状态          |
| unlock |    解锁，把一个处于线程独占状态的变量释放出来     |
|  read  |       把变量传输到工作内存中，配合load使用        |
| write  | 把工作内存传来的变量写入到主内存中，配合store使用 |

### 作用于工作内存中的变量

|  指令  |                    描述                    |
| :----: | :----------------------------------------: |
|  load  | 把主内存传来的变量放入工作内存的变量副本中 |
|  use   |            把变量传递给执行引擎            |
| assign |    把执行引擎传过来的变量赋值给工作内存    |
| store  |              把变量传给主内存              |

### 用法

使用`read`和`load`组合把变量从`主内存`传递到`工作内存`，并保存在工作内存的变量副本中。

使用`store`和`write`组合把变量从`工作内存`传递到`主内存`，并写入。

# 三、内存模型三大特征

> Java内存模型以及相关指令主要是围绕**如何处理并发过程中的原子性、可见性和有序性**进行的。

下面我们就来谈谈这三大特征。

## 原子性

> 原子性，指某个操作不可再分。

上面提到的8个指令都支持原子性：

- 8个指令本身都是原子性的

  单个操作是原子性的，一起使用就不一定了

- lock和unlock可以保证更大维度的原子性

  `synchronized`关键字是用字节码指令`monitorenter`和`monitorexit`实现的，这两个指令隐式的表达了`lock`和`unlock`的意思。

所以我们可以认为：

1. **基本数据类型的访问、读写都是具有原子性的**

2. **`synchronized`关键字修饰的代码块是具有原子性的**

3. **`volatile`关键字修饰的变量是不具备原子性的**

   这个如何理解呢？

   volatile修饰，只是保证了读取变量时，是最新的正确的

   但是后续的更新、赋值过程，别的线程是可以修改变量，从而使当前值失效的。

## 可见性

> 可见性指**volatile**修饰的变量，一旦被某个线程修改，其他线程可以立刻察觉到变化。

Java有3个关键字能实现可见性，分别是`volatile`、`synchronized`和`final`

- **volatile**，后面会介绍

- **synchronized**

  `unlock`后必须写回到主内存，从而保证了可见性

- **final**

  该关键字修饰的变量，一旦完成初始化，其他线程都可见。

## 有序性

> 如果在本线程内观察，所有操作都是有序的；如果在其他线程中观察，那么观察到的都是无序的操作。

两种方式实现有序性：

- volatile，后面介绍

- synchronized

  因为变量在同一时间只能被一个线程`lock`，所以代码块只能串行进入。

# 四、Volatile关键字

`volatile`关键字用来修饰变量，它有两个作用：

- 保证可见性
- 禁止指令重排序

接下来我们从内存模型的角度理解一下它的实现。

## 3.1保证可见性

> 可见性指**volatile**修饰的变量，一旦被某个线程修改，其他线程可以立刻察觉到变化。

Java虚拟机通过原子操作实现了这一点

现在假设变量`a`是被volatile修饰的，那么

1. `read`、`load`和`use`组合使用

   `a`在使用时必须从主内存中读取到工作内存中，然后再传递给执行引擎

2. `asign`、`store`和`write`组合使用

   `a`修改后，由执行引擎传递给工作空间，然后必须再写回主内存中。

## 3.2禁止指令重排序

> 指令重排序是处理器为了高效利用资源而进行的操作
>
> 该操作不影响当前线程的最终结果

在多线程环境下，指令重排序可能会造成访问数据错误。

虚拟机通过设置`内存屏障`的方式来禁止指令重排，具体地说，是禁止让屏障之后的指令，重排序到内存屏障的前面。

