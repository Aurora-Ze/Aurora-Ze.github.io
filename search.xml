<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统——系统调用</title>
      <link href="2021/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
      <url>2021/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="阅读文章"><a href="#阅读文章" class="headerlink" title="阅读文章"></a>阅读文章</h2><p><a href="https://www.cnblogs.com/chenwb89/p/operating_system_002.html">操作系统篇之一：浅谈实模式与保护模式</a></p><p><a href="https://www.cnblogs.com/chenwb89/p/operating_system_003.html">操作系统篇之二：分段机制与GDT|LDT</a></p><p><a href="https://www.cnblogs.com/chenwb89/p/operating_system_004.html">操作系统篇之三：调用门与特权级（CPL、DPL和RPL)</a></p><p><strong>「操作系统」</strong>向下管理底层硬件，向上提供计算机的基础服务，如文件管理、内存管理、进程管理等等。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><blockquote><p>系统调用是操作系统提供给上层的功能的接口</p></blockquote><h3 id="为什么会有系统调用？"><a href="#为什么会有系统调用？" class="headerlink" title="为什么会有系统调用？"></a>为什么会有系统调用？</h3><p><strong>思考</strong></p><p>运行时数据都在内存中，用户为什么要通过系统调用，而不是直接去内存中取？</p><p><strong>解答</strong></p><p>是为了数据安全和操作的难易程度考虑。</p><p>如果用户可以直接操作内存，那么对内存地址的改动，就很有可能会造成应用程序的崩溃，早期的操作系统经常蓝屏死机就是这个原因。</p><h3 id="怎样隔离用户直接操作内存的情况"><a href="#怎样隔离用户直接操作内存的情况" class="headerlink" title="怎样隔离用户直接操作内存的情况"></a>怎样隔离用户直接操作内存的情况</h3><p>实模式与保护模式</p><p>系统刚开机或重启那会儿处于实模式，之后便处于保护模式中。</p><p>而在保护模式中，有一个叫做<code>特权级</code>的概念，其中，</p><ul><li>CPL：当前进程的权限级别</li><li>DPL：某个内存段的固定权限级别</li><li>RPL：进程请求某个内存段时的权限</li></ul><p><del>如果进程在内核态，它的CPL就会变成0；当它访问某块DPL为3的内存时，</del></p><h3 id="既然隔离了，怎样进入内核态呢"><a href="#既然隔离了，怎样进入内核态呢" class="headerlink" title="既然隔离了，怎样进入内核态呢"></a>既然隔离了，怎样进入内核态呢</h3><p>对于<code>Intel x86</code>，硬件提供了中断指令<code>int</code></p><p>当发生系统调用时，C语言会把代码解析成汇编指令，然后通过中断指令进入内核态（实际上是修改DPL为3，然后再改回来，从而得到权限）</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——IO及磁盘</title>
      <link href="2021/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO%E5%8F%8A%E7%A3%81%E7%9B%98/"/>
      <url>2021/08/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/IO%E5%8F%8A%E7%A3%81%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="阅读文章"><a href="#阅读文章" class="headerlink" title="阅读文章"></a>阅读文章</h2><p><a href="https://www.cnblogs.com/iwehdio/p/13681037.html">IO控制、IO缓冲、磁盘调度</a></p><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><blockquote><ul><li><input checked="" disabled="" type="checkbox"> 1、什么是IO，有哪些IO类型</li><li><input disabled="" type="checkbox"> 2、进程发起IO请求的过程是怎样的</li><li><input disabled="" type="checkbox"> 3、操作系统怎样处理IO，对IO做了哪些优化</li></ul></blockquote><p>进程在执行时可能需要读取键盘输入、或向磁盘输出数据，这些操作都属于I/O</p><p>IO类型：用户（键盘鼠标交互）、磁盘等外设、网络通信</p><h3 id="I-O控制"><a href="#I-O控制" class="headerlink" title="I/O控制"></a>I/O控制</h3><p>最开始是由CPU直接向IO设备下达指令，并且要阻塞等待IO操作完成</p><p>后来：</p><ul><li><strong>IO模块</strong>封装各类IO的细节，向上层提供api。</li><li><strong>中断指令</strong>可以让CPU执行其他进程，IO操作结束后发送中断指令给CPU，再让其切换到发起IO操作的进行来执行。<ul><li><code>问题</code>中断指令是怎么发起的，是硬件提供的，还是操作系统提供的？</li></ul></li><li><strong>DMA模块</strong><code>直接存储访问</code>可以让内存与IO模块直接进行数据传输，CPU只需要在IO开始和结束时进行干涉。</li></ul><h3 id="I-O缓冲"><a href="#I-O缓冲" class="headerlink" title="I/O缓冲"></a>I/O缓冲</h3><p><strong>局限性</strong></p><p>我们都知道读写IO的速度是比CPU执行速度慢很多的</p><p>所以当一个进程在读取磁盘上的数据块时，它会挂起（切换其他进程执行）或一直等待</p><p>但是因为数据会读到进程的工作空间，所以这个进程的工作空间会被锁住，确保在等待IO期间不被换下（例如分页中的页置换）</p><p><strong>优化</strong></p><p>操作系统提供I/O缓冲区，缓冲策略可以是读完一个数据块后，立刻读后面的</p><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><blockquote><ul><li><input checked="" disabled="" type="checkbox"> 1、磁盘结构、常用术语</li><li><input checked="" disabled="" type="checkbox"> 2、向磁盘读/写数据的过程</li><li><input checked="" disabled="" type="checkbox"> 3、磁盘调度算法有哪些，什么场景下用哪个会更好，调度算法是在哪个过程用的</li></ul></blockquote><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>柱面、盘面、磁臂、磁头、磁道、扇区、转速</strong></p><h3 id="读写过程"><a href="#读写过程" class="headerlink" title="读写过程"></a>读写过程</h3><ul><li><p><strong>寻道</strong></p><ul><li><code>描述</code>：磁头找到对应的柱面（C、D、E盘等等），然后在盘面上找到对应的磁道</li><li><code>时间计算</code>：$T_{寻道}=T_{磁头启动}+m*n(跨越n个磁道，每个磁道耗时m)$</li><li><code>优化思路</code>：减少跨越磁道的个数，即<strong>磁盘调度算法</strong></li></ul></li><li><p><strong>旋转延迟</strong></p><ul><li><code>描述</code>：磁盘要旋转一段距离，好让磁头定位到目标扇区</li><li><code>时间计算</code>：$T_{旋转}=\frac{1}{2r}，假设平均需要转半圈$</li></ul></li><li><p><strong>传输</strong></p><ul><li><code>描述</code>：接下来磁盘继续旋转，这次是进行读写了。</li><li><code>时间计算</code>：$T_{传输}=\frac{b}{rN}，表示读写b个字节，磁道总字节为N$</li><li><code>优化思路</code>：数据放一块，可以顺序读写，避免再次寻道（随机IO）</li></ul></li></ul><p><strong>所以在磁盘上的耗费时间也可以计算：寻道时间、旋转延迟、传输时间</strong></p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p><strong>使用场景</strong></p><p>每个IO设备应该都有一个队列，如果磁盘正在处理某次IO，那么其他IO请求就会在队列中等待。</p><p>如果按请求进来的顺序执行，就可能存在请求的磁盘位置过于分散，寻道时间大大增加的情况。</p><p><strong>调度算法大致有三种类型：队列式、最短距离、扫描</strong></p><ul><li><strong>FIFO</strong><ul><li><code>描述</code>：按队列顺序来处理IO请求</li><li><code>缺点</code>：大部分情况就是随机IO</li><li><code>应用</code>：访问位置比较密集时，性能还说得上去</li><li><code>变种</code>：<strong>LIFO</strong>后进来的先处理，充分利用了局部性</li></ul></li><li><strong>SSTF</strong><ul><li><code>描述</code>：每次选择与当前磁道最近的请求进行执行</li><li><code>缺点</code>：可能会出现饥饿，距离远的永远达不到；还有就是得计算距离</li><li><code>应用</code>：比FIFO快蛮多的</li></ul></li></ul><p>下面是扫描算法，有好几种变种</p><ul><li><p><strong>SCAN</strong></p><ul><li><code>描述</code>：磁臂沿着一个方向扫描，处理遇到的所有请求，到边界后再调头扫描</li><li><code>缺点</code>：对磁臂周围的局部区域不公平，因为等待时间长；多余扫描</li></ul></li><li><p><strong>C-SCAN</strong></p><ul><li><code>描述</code>：和SCAN类似，但它不调头，而是重复从起点到终点的扫描</li><li><code>应用</code>：这样对局部区域比较公平</li><li><code>缺点</code>：还有个缺点没解决，就是多余扫描</li></ul></li><li><p><strong>C-LOOK</strong></p><ul><li><code>描述</code>：前面没有请求了，就直接回到起点</li></ul></li><li><p>N步SCAN：把请求队列划分成多个长度为N的子队列</p></li><li><p>FSCAN：用两个子队列，新请求全放在另一个队列中</p></li></ul><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>IO请求多时，一个磁盘处理不过来</p><p>那就用多个磁盘集成在一起，就是RAID了</p><h3 id="磁盘高速缓存"><a href="#磁盘高速缓存" class="headerlink" title="磁盘高速缓存"></a>磁盘高速缓存</h3><p>跟CPU和内存之间建立的高速缓存一样，内存中有一块地方专门做磁盘的缓存。</p><p>IO请求先判断能否命中磁盘高速缓存，再去决定是否进行IO</p><p><strong>命中缓存时，如何把数据交给进程</strong></p><ul><li>就硬传，把数据传到进程的工作</li><li>以共享内存的方式，把地址传给进程即可</li></ul><p><strong>新的磁盘IO完成后，高速缓存要存入新的数据，采取怎样的更新策略（页置换）</strong></p><ul><li><strong>LRU</strong><ul><li>最近最少使用</li><li>用栈（双端队列）维护，每次用到一个页，把它放到栈顶。置换时把栈底（最久没用过）的换出去</li></ul></li><li><strong>LFU</strong><ul><li>使用频率最低</li><li>对每个页计数</li><li>缺点：可能某个页刚放进来又被置换出去了，对局部性情况不友好。</li></ul></li></ul><h2 id="Linux中的IO"><a href="#Linux中的IO" class="headerlink" title="Linux中的IO"></a>Linux中的IO</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Protobuf入门</title>
      <link href="2021/08/16/%E5%B7%A5%E5%85%B7/protocol%20buffers/"/>
      <url>2021/08/16/%E5%B7%A5%E5%85%B7/protocol%20buffers/</url>
      
        <content type="html"><![CDATA[<h1 id="文档链接"><a href="#文档链接" class="headerlink" title="文档链接"></a>文档链接</h1><p><a href="https://developers.google.com/protocol-buffers">protocol-buffers官网</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3教程</a></p><p><a href="https://halfrost.com/protobuf_encode/#toc-0">高效的数据压缩编码方式 Protobuf </a></p><h1 id="protocol-buffers"><a href="#protocol-buffers" class="headerlink" title="protocol buffers"></a>protocol buffers</h1><h3 id="什么是protocol-buffers"><a href="#什么是protocol-buffers" class="headerlink" title="什么是protocol buffers"></a>什么是protocol buffers</h3><p><strong>官方文档</strong></p><blockquote><p>Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p></blockquote><p><strong>翻译</strong></p><blockquote><p>protocol buffers是Google开源的一种对结构化数据进行序列化的方式。它具有语言无关、平台无关和可扩展性；和xml相比，它更小，更快并且更加简单。</p><p>用户只需要定义一次所需的结构化数据， 就可以利用生成的各种语言的代码从数据流中读写数据</p></blockquote><h3 id="选择语言进行安装"><a href="#选择语言进行安装" class="headerlink" title="选择语言进行安装"></a>选择语言进行安装</h3><p><a href="https://github.com/protocolbuffers/protobuf/releases">Releases · protocolbuffers/protobuf (github.com)</a></p><h1 id="一、定义Message"><a href="#一、定义Message" class="headerlink" title="一、定义Message"></a>一、定义Message</h1><p>示例：在<code>.proto</code>文件中定义一个名叫<code>SearchRequest</code>的消息格式，用来表示搜索的请求</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;./mvp&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">UserLoginReq</span> </span>&#123;<br>        <span class="hljs-built_in">string</span> UserName = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">string</span> Password = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">UserLoginRsp</span> </span>&#123;<br>        <span class="hljs-built_in">bool</span> IsLogin = <span class="hljs-number">1</span>;<br>        User UserInfo = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><ul><li>第一行<code>syntax = &quot;proto3&quot;</code>表示使用proto3的语法，要放在正文（非空行和非注释行）中的第一行，如果没有这一行，则表示使用proto2语法</li><li><code>go_package</code>指定生成目标代码的目录</li><li>消息体<code>UserLoginReq</code>由2个字段构成，每个字段包含类型、名称和值。</li></ul><h3 id="1-1-指定字段类型"><a href="#1-1-指定字段类型" class="headerlink" title="1.1 指定字段类型"></a>1.1 指定字段类型</h3><p>如示例中的<code>UserName</code>字段，类型为<code>string</code>；</p><p>类型既可以是数值类型，也可以是复合类型（枚举、其他消息体）</p><h3 id="1-2-设定字段值"><a href="#1-2-设定字段值" class="headerlink" title="1.2 设定字段值"></a>1.2 设定字段值</h3><p>字段值是唯一的，被用来标识该字段在消息的二进制格式</p><p><strong>字段值从1到15使用一个字节来编码，16到2047使用两个字节来编码，因此对于频繁出现的字段，它的值应该设成1到15之间。</strong></p><p>关于更多，可以先去了解下<code>protocol buffer</code>的编码</p><h3 id="1-3-指定字段规则"><a href="#1-3-指定字段规则" class="headerlink" title="1.3 指定字段规则"></a>1.3 指定字段规则</h3><ul><li><p><strong>singular</strong></p><p>  表示该字段出现次数不多于1（0个或者1个）</p><p>  proto3默认使用这种规则</p></li><li><p><strong>repeated</strong></p><p>  表示字段可以出现任意次，可以理解成数组</p></li></ul><h1 id="二、定义Service"><a href="#二、定义Service" class="headerlink" title="二、定义Service"></a>二、定义Service</h1><p>如果想要将上面定义的<code>Message</code>类型用于<code>rpc调用</code>，就要定义一个服务，服务中可以声明多个接口。</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">LoginService</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">rpc</span> Login(UserLoginReq) <span class="hljs-keyword">returns</span> (UserLoginRsp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-完整示例"><a href="#2-1-完整示例" class="headerlink" title="2.1 完整示例"></a>2.1 完整示例</h3><figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;./mvp&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">LoginService</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">rpc</span> Login(UserLoginReq) <span class="hljs-keyword">returns</span> (UserLoginRsp)</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义用户登陆请求</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">UserLoginReq</span> </span>&#123;<br>        <span class="hljs-built_in">string</span> UserName = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">string</span> Password = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义用户登陆响应</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">UserLoginRsp</span> </span>&#123;<br>        <span class="hljs-built_in">bool</span> IsLogin = <span class="hljs-number">1</span>;<br>        User UserInfo = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义用户消息格式</span><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">User</span> </span>&#123;<br>        <span class="hljs-built_in">uint64</span> UserID = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">string</span> NickName = <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">uint64</span> Age = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">repeated</span> <span class="hljs-built_in">string</span> ImgURL = <span class="hljs-number">4</span>;<br>        UserType UserType = <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义枚举类型：用户权限类型</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UserType</span> </span>&#123;<br>        UT_Nil = <span class="hljs-number">0</span>;<br>        UT_Visit = <span class="hljs-number">1</span>;<br>        UT_Normal = <span class="hljs-number">2</span>;<br>        UT_Admin = <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、生成Go代码"><a href="#三、生成Go代码" class="headerlink" title="三、生成Go代码"></a>三、生成Go代码</h1><h3 id="3-1-下载插件"><a href="#3-1-下载插件" class="headerlink" title="3.1 下载插件"></a>3.1 下载插件</h3><p><code>protocol buffer complier</code>需要一个插件才能生成Go代码，因此先下载插件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest<br></code></pre></td></tr></table></figure><p>下载完毕后在<code>$GOPATH/bin</code>路径下会生成<code>protoc-gen-go</code></p><h3 id="3-2-利用插件生成代码"><a href="#3-2-利用插件生成代码" class="headerlink" title="3.2 利用插件生成代码"></a>3.2 利用插件生成代码</h3><p>在项目的根目录下用终端（或cmd）输入以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">protoc --go_out=. <span class="hljs-variable">$SRC_DIR</span>/addressbook.proto<br></code></pre></td></tr></table></figure><p>参数说明</p><ul><li><p><code>go_out</code>：表示生成go代码</p></li><li><p><code>$SRC_DIR/addressbook.proto</code>：表示协议所在位置</p></li><li><p>如果想要指定代码生成的位置，则在协议文件中添加</p>  <figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;yourpath&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h1 id="四、demo"><a href="#四、demo" class="headerlink" title="四、demo"></a>四、demo</h1><h3 id="4-1-编码并写入文件"><a href="#4-1-编码并写入文件" class="headerlink" title="4.1 编码并写入文件"></a>4.1 编码并写入文件</h3><p>主要使用<code>Marshal()</code>进行编码</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// TestProtoWrite 测试把消息写入指定文件中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestProtoWrite</span><span class="hljs-params">()</span></span>  &#123;<br>    login := &amp;mvp.UserLoginReq &#123;<br>        UserName: <span class="hljs-string">&quot;zhangsan&quot;</span>,<br>        Password: <span class="hljs-string">&quot;123&quot;</span>,<br>    &#125;<br><br>    out, err := proto.Marshal(login)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalln(<span class="hljs-string">&quot;Fail to encode message login:&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">if</span> err = ioutil.WriteFile(FilePath, out, fs.FileMode(<span class="hljs-number">777</span>)); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalln(<span class="hljs-string">&quot;Fail to write file:&quot;</span>, err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-读取消息并解码"><a href="#4-2-读取消息并解码" class="headerlink" title="4.2 读取消息并解码"></a>4.2 读取消息并解码</h3><p>使用<code>Unmarshal()</code>进行解码</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// TestProtoRead 测试从指定文件中读取消息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestProtoRead</span><span class="hljs-params">()</span></span>  &#123;<br>    in, err := ioutil.ReadFile(FilePath)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalln(<span class="hljs-string">&quot;Fail to read file:&quot;</span>, err)<br>    &#125;<br>    login := &amp;mvp.UserLoginReq&#123;&#125;<br>    <span class="hljs-keyword">if</span> err = proto.Unmarshal(in, login); err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalln(<span class="hljs-string">&quot;Fail to decode message login:&quot;</span>, err)<br>    &#125;<br>    fmt.Println(login)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五、编码详解"><a href="#五、编码详解" class="headerlink" title="五、编码详解"></a>五、编码详解</h1><h3 id="5-1-Base-128-Varints"><a href="#5-1-Base-128-Varints" class="headerlink" title="5.1 Base 128 Varints"></a>5.1 Base 128 Varints</h3><h5 id="官方文档说明"><a href="#官方文档说明" class="headerlink" title="官方文档说明"></a>官方文档说明</h5><blockquote><p>To understand your simple protocol buffer encoding, you first need to understand <em>varints</em>. Varints are a method of serializing integers using one or more bytes. Smaller numbers take a smaller number of bytes.</p><p>Each byte in a varint, except the last byte, has the <em>most significant bit</em> (msb) set – this indicates that there are further bytes to come. The lower 7 bits of each byte are used to store the two’s complement representation of the number in groups of 7 bits, <strong>least significant group first</strong>.</p></blockquote><h5 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h5><blockquote><p>为了帮助你理解<code>protocol buffer</code>的编码方式，你需要先了解一下<code>varints</code>。<code>varints</code>是一种将整数类型序列化成一个或多个字节的方法。越小的数字序列化后产生的字节数就越少。</p><p>varints中除了最后一个字节，其他字节的最高有效位都置为1，用来表示接下来还有字节；剩余的低7位则是对每7位为一组的二进制数据的补码表示。</p></blockquote><h5 id="编码示例"><a href="#编码示例" class="headerlink" title="编码示例"></a>编码示例</h5><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210701200434.png"></p><p>解码过程就是上述编码的逆过程，这里就不再赘述。</p><h3 id="5-2-消息类型编码"><a href="#5-2-消息类型编码" class="headerlink" title="5.2 消息类型编码"></a>5.2 消息类型编码</h3><blockquote><p>从之前的消息示例中我们可以看出，消息是由一系列的键值对组成的。</p></blockquote><h5 id="键值对介绍"><a href="#键值对介绍" class="headerlink" title="键值对介绍"></a>键值对介绍</h5><p>键被称为<code>tag</code>，由<code>field number</code>和<code>wire type</code>构成，前者表示设定的字段号，后者可以查表得。</p><p>值就是该字段被赋予的数值。</p><p><code>tag</code>的计算方式为：<br>$$<br>tag = (field number &lt;&lt; 3)  | wire type<br>$$<br>表格如下，其中3，4已被废弃，就是说<code>wire type</code>取值应该只有0，1，2，5，因此用三比特即可表示<code>wire type</code>。</p><table><thead><tr><th align="left">Type</th><th align="left">Meaning</th><th align="left">Used For</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">Varint</td><td align="left">int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td align="left">1</td><td align="left">64-bit</td><td align="left">fixed64, sfixed64, double</td></tr><tr><td align="left">2</td><td align="left">Length-delimited</td><td align="left">string, bytes, embedded messages, packed repeated fields</td></tr><tr><td align="left">3</td><td align="left">Start group</td><td align="left">groups (deprecated)</td></tr><tr><td align="left">4</td><td align="left">End group</td><td align="left">groups (deprecated)</td></tr><tr><td align="left">5</td><td align="left">32-bit</td><td align="left">fixed32, sfixed32, float</td></tr></tbody></table><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>现有以下消息，假设传入消息，a的值是150</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Test1</span> </span>&#123;<br>    <span class="hljs-keyword">required</span> <span class="hljs-built_in">int32</span> a = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个消息体编码后得到的结果是<code>08 96 01</code>（16进制）</p><ul><li><p>计算tag</p><p>  0001 ++ 000，得到<code>0001000</code>，即<strong>08</strong></p></li><li><p>对150进行编码，采取上述<code>varints</code>方式</p><ul><li>10010110</li><li>1，0010110</li><li>00000001，10010110</li><li>得到编码<code>10010110，00000001</code></li><li>用16进制表示，即<strong>96 01</strong></li></ul></li></ul><h3 id="5-3-字符串编码"><a href="#5-3-字符串编码" class="headerlink" title="5.3 字符串编码"></a>5.3 字符串编码</h3><p>和普通的整型相比，字符串在消息体中的编码方式多了一个length，表示字符串编码后的长度。</p><p>形式为<code>key length content</code>。</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>b赋值为testing</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">Test2</span> </span>&#123;<br>    <span class="hljs-keyword">optional</span> <span class="hljs-built_in">string</span> b = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码后的结果是<code>12 07 74 65 73 74 69 6e 67</code></p><p>其中<strong>07</strong>表示长度，后面的7个16进制就是testing的utf8编码</p><p>最开始的<strong>12</strong>就是key，由0010010转换成16进制得到。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码总结</title>
      <link href="2021/08/16/golang/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>2021/08/16/golang/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>记录完成需求时，需要注意的一些编码习惯</p><h3 id="1-使用cast包进行类型转换"><a href="#1-使用cast包进行类型转换" class="headerlink" title="1.使用cast包进行类型转换"></a>1.使用cast包进行类型转换</h3><p>涉及<code>string</code>转<code>uint64</code>或其他类型时，多用<code>cast.ToUint64</code>、<code>cast.ToString</code>等函数</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// &quot;github.com/spf13/cast&quot;</span><br>feedIDSet.Add(cast.ToUint64(v.ContentID))<br></code></pre></td></tr></table></figure><p>用cast包时遇到一个问题</p><p><strong>描述：</strong></p><blockquote><p>类型OrderPostStatus等价于类型int32。</p><p>现在拿到一个OrderPostStatus类型的变量，想要转换成int32，于是我很自然地就想到用cast.ToInt32()，之后发现这个值一直是0，没有转换成功</p></blockquote><p><strong>分析：</strong></p><p>查看ToInt32()的代码，发现它是先用类型断言来判断类型，然后再根据判断得到的类型，进行值的转换。</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> s := i.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">int32</span>(s), <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-keyword">int64</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">int32</span>(s), <span class="hljs-literal">nil</span><br><span class="hljs-comment">// 此处省略一堆类型...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, fmt.Errorf(<span class="hljs-string">&quot;unable to cast %#v of type %T to int32&quot;</span>, i, i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而这些类型断言都只是判断了基本的类型，对于自定义的类型，它会走到default代码块里返回0</p><p><strong>解决：</strong></p><p>直接用<code>int32(value)</code>进行强转</p><h3 id="2-使用WaitGroup"><a href="#2-使用WaitGroup" class="headerlink" title="2.使用WaitGroup"></a>2.使用WaitGroup</h3><p><code>ao</code>层涉及到对举报信息进行组装，需要调用3个微服务分别来获取<code>用户名</code>、<code>动态内容图片</code>和<code>评论内容</code>。</p><p>原先的写法是都写在主线程中，这样耗时比较大；正确的做法应该是<code>开启3个协程</code>去调用三个微服务</p><figure class="highlight golang"><table><tr><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">3</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>s.getReportUserID(ctx, reports)<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>s.getFeedDetail(ctx, reports)<br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>s.getCommentDetail(ctx, reports)<br>&#125;()<br><br>wg.Wait()<br></code></pre></td></tr></table></figure><h3 id="3-使用set"><a href="#3-使用set" class="headerlink" title="3.使用set"></a>3.使用set</h3><p>golang没有提供set集合，在添加id到集合中时，可以使用自建的<code>set.NewUint64Set()</code>来获取set，以进行去重。</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// &quot;git.code.oa.com/demeter/groupshop/group-shop-comm/set&quot;</span><br>reportUserIDSet := set.NewUint64Set()<br></code></pre></td></tr></table></figure><h3 id="4-pb文件"><a href="#4-pb文件" class="headerlink" title="4.pb文件"></a>4.pb文件</h3><p>对于协议中定义的枚举类型。pb文件中会提供map方便进行转换，就不用自己去做实现了</p><p>例如<code>product_post.proto</code>文件中定义如下枚举</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">OrderPostStatus</span> </span>&#123;<br>    PostOrderNotExist = <span class="hljs-number">0</span>; <span class="hljs-comment">//未进入待评价状态</span><br>    PostOrderWaitPublish = <span class="hljs-number">1</span>; <span class="hljs-comment">//待评价</span><br>    PostOrderPublished = <span class="hljs-number">2</span>; <span class="hljs-comment">//已评价</span><br>    PostOrderClosed = <span class="hljs-number">3</span>; <span class="hljs-comment">//订单已完成，不予评价</span><br>&#125;<br></code></pre></td></tr></table></figure><p>生成的<code>product_post.pb.go</code>文件会带有map</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Enum value maps for OrderPostStatus.</span><br><span class="hljs-keyword">var</span> (<br>OrderPostStatus_name = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int32</span>]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-number">0</span>: <span class="hljs-string">&quot;PostOrderNotExist&quot;</span>,<br><span class="hljs-number">1</span>: <span class="hljs-string">&quot;PostOrderWaitPublish&quot;</span>,<br><span class="hljs-number">2</span>: <span class="hljs-string">&quot;PostOrderPublished&quot;</span>,<br><span class="hljs-number">3</span>: <span class="hljs-string">&quot;PostOrderClosed&quot;</span>,<br>&#125;<br>OrderPostStatus_value = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int32</span>&#123;<br><span class="hljs-string">&quot;PostOrderNotExist&quot;</span>:    <span class="hljs-number">0</span>,<br><span class="hljs-string">&quot;PostOrderWaitPublish&quot;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;PostOrderPublished&quot;</span>:   <span class="hljs-number">2</span>,<br><span class="hljs-string">&quot;PostOrderClosed&quot;</span>:      <span class="hljs-number">3</span>,<br>&#125;<br>)<br></code></pre></td></tr></table></figure><p>补充：更方便的是直接强转，不要用cast包（参照第一点中的问题）</p><h3 id="5-输出日志"><a href="#5-输出日志" class="headerlink" title="5.输出日志"></a>5.输出日志</h3><p>调试时多打一些日志来看数据，方便定位问题</p><h3 id="6-优化代码逻辑"><a href="#6-优化代码逻辑" class="headerlink" title="6.优化代码逻辑"></a>6.优化代码逻辑</h3><p>遇到复杂的需求，一开始单纯为了完成需求，写完后发现for循环内写了一堆逻辑，就要多想想怎么优化它。</p><h3 id="7-格式化输出记录"><a href="#7-格式化输出记录" class="headerlink" title="7.格式化输出记录"></a>7.格式化输出记录</h3><ol><li><p><strong>通用的占位符</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">%v    <span class="hljs-comment">//根据值的类型，输出它该有的样子</span><br>%+v   <span class="hljs-comment">//带上包和结构体名</span><br>%#v   <span class="hljs-comment">//输出时带上结构体的每个字段名</span><br>%T    <span class="hljs-comment">//输出类型</span><br></code></pre></td></tr></table></figure></li><li><p><strong>常用类型</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">%b    <span class="hljs-comment">//布尔</span><br>%d    <span class="hljs-comment">//整数</span><br>%s    <span class="hljs-comment">//字符串</span><br>%p    <span class="hljs-comment">//指针</span><br>%q    <span class="hljs-comment">//带双引号的字符串，自动转义</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="8-初始化二维数组"><a href="#8-初始化二维数组" class="headerlink" title="8.初始化二维数组"></a>8.初始化二维数组</h3><p>在家刷leetcode时遇到题目需要一个二维切片<code>visited</code>来表示是否访问过当前位置。</p><p><strong>错误做法</strong></p><p>因为之前创建一维切片用的是make函数，所以我以为创建二维切片只要在函数里多传一个参数就可以了</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 想创建一个3行5列的二维数组</span><br>visited := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">bool</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>上面创建的<code>visited</code>，确实是3行，但是每行的长度都为0，说明第二个长度参数<code>5</code>并没有生效</p><p>于是我去仔细地看了下make函数的注释说明</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Slice: The size specifies the length. The capacity of the slice is</span><br><span class="hljs-comment">//equal to its length. A second integer argument may be provided to</span><br><span class="hljs-comment">//specify a different capacity; it must be no smaller than the</span><br><span class="hljs-comment">//length. For example, make([]int, 0, 10) allocates an underlying array</span><br><span class="hljs-comment">//of size 10 and returns a slice of length 0 and capacity 10 that is</span><br><span class="hljs-comment">//backed by this underlying array.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">make</span><span class="hljs-params">(t Type, size ...IntegerType)</span> <span class="hljs-title">Type</span></span><br></code></pre></td></tr></table></figure><p>这才发现：</p><ul><li>传入一个<code>size</code>时，它就表示切片的长度和容量，即两者相等</li><li>传入两个<code>size</code>时，第一个参数表示长度，第二个参数表示切片容量（容量不小于长度）</li></ul><p>所以刚才make函数创建的实际上是一个长度3，容量5的二维切片，但是每个一维切片是空的，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">[[] [] []]<br></code></pre></td></tr></table></figure><p><strong>正确做法</strong></p><p>从上面可以看出，创建的每个一维切片还是空的，所以需要对每个一维切片做一次初始化操作</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">visited := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">bool</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> visited &#123;<br>    visited[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, <span class="hljs-number">5</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-遍历map"><a href="#9-遍历map" class="headerlink" title="9.遍历map"></a>9.遍历map</h3><p><strong>问题描述：</strong></p><p>在返回的已买商品列表中，相同的商品带有相同的订单号，我们期待的是不同的订单号。</p><p>因为在实现中订单和商品是一对一的关系，所以就算是购买相同商品，每次购买的订单号一定是不同的。</p><p><strong>问题定位：</strong></p><p>遍历订单时，把从map中得到的<code>商品信息</code>重复添加到切片中</p><p>然后切片中两个元素的指针是相同的，导致修改一个的订单号，就会修改其他相同指针的。</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, order := <span class="hljs-keyword">range</span> orders &#123;<br><span class="hljs-keyword">if</span> spuInfo, ok := spuIDMap[order.SpuId]; ok &#123;<br>spuInfo.OrderID = cast.ToString(order.OrderId)<br>spuInfosRsp = <span class="hljs-built_in">append</span>(spuInfosRsp, spuInfo)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正确做法：</strong></p><p>得到商品信息<code>spuInfo</code>后，深拷贝一份新的，这样它们的地址就不相同，修改一个也不会影响到其他。</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, order := <span class="hljs-keyword">range</span> orders &#123;<br><span class="hljs-keyword">if</span> spuInfo, ok := spuIDMap[order.SpuId]; ok &#123;<br>newSpu := deepCopy(spuInfo)<br>newSpu.OrderID = cast.ToString(order.OrderId)<br>spuInfosRsp = <span class="hljs-built_in">append</span>(spuInfosRsp, newSpu)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git&amp;GitHub使用</title>
      <link href="2021/08/16/%E5%B7%A5%E5%85%B7/Git&amp;Github%E4%BD%BF%E7%94%A8/"/>
      <url>2021/08/16/%E5%B7%A5%E5%85%B7/Git&amp;Github%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、拉取某一远程分支"><a href="#一、拉取某一远程分支" class="headerlink" title="一、拉取某一远程分支"></a>一、拉取某一远程分支</h2><p>项目分支太多，只想要某一分支时，可以添加<code>--single-branch</code>参数</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b 分支名 --single-branch 仓库路径<br></code></pre></td></tr></table></figure><h2 id="二、合并分支并解决冲突"><a href="#二、合并分支并解决冲突" class="headerlink" title="二、合并分支并解决冲突"></a>二、合并分支并解决冲突</h2><p><strong>开发流程</strong></p><p>master -&gt; 创建特性分支 -&gt; 在特性分支上开发 -&gt; 拉取最新master，合并到特性分支 -&gt; 提交到远程仓库，并提MR</p><p><strong>解释</strong></p><ol><li>开发需求时，通常是从master分支中拉一个新的分支，称为特性分支，然后在特性分支上开发。</li></ol><ol start="2"><li><p>开发完毕后，申请<code>merge request</code>到master分支上。</p></li><li><p>但是这时候master分支可能已经发生了变化，比如同事早一步开发完，合到了master分支上。</p></li><li><p>这时候就需要把master拉下来，合并到特性分支上。</p></li></ol><p>具体的操作方式很简单，在<code>idea</code>上先把master分支<code>pull</code>下来</p><p>然后点击master分支（不要切换），选择<code>merge into current</code>，如果有冲突，进行解决即可。</p><h2 id="三、项目中引用外部协议"><a href="#三、项目中引用外部协议" class="headerlink" title="三、项目中引用外部协议"></a>三、项目中引用外部协议</h2><h5 id="1-修改协议项目中的go-mod"><a href="#1-修改协议项目中的go-mod" class="headerlink" title="1. 修改协议项目中的go.mod"></a>1. 修改协议项目中的go.mod</h5><p>把<code>go.mod</code>的module路径改成带GitHub的，如</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">module github.com&#x2F;Aurora-Ze&#x2F;protocol<br></code></pre></td></tr></table></figure><h5 id="2-修改协议文件"><a href="#2-修改协议文件" class="headerlink" title="2. 修改协议文件"></a>2. 修改协议文件</h5><p><code>go_package</code>符合url路径</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">package</span> user.cgi;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;github.com/Aurora-Ze/protocol/user/cgi&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="3-引入"><a href="#3-引入" class="headerlink" title="3. 引入"></a>3. 引入</h5><p>在随便一个go文件中的<code>import</code>块里添加，然后<code>Alt + Enter</code>提示同步依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&quot;github.com&#x2F;Aurora-Ze&#x2F;protocol&#x2F;user&#x2F;cgi&quot;<br></code></pre></td></tr></table></figure><h2 id="四、添加Github-SSH-key"><a href="#四、添加Github-SSH-key" class="headerlink" title="四、添加Github SSH key"></a>四、添加Github SSH key</h2><p>如果想要通过SSH的方式克隆项目，就要先在本地生成SSH密钥对，然后把公钥添加到GitHub配置中，就可以建立起本地和远程GitHub仓库的连接。</p><p>通过SSH有个好处，就是不需要再输入账号和个人令牌进行登陆验证，避免信息泄露</p><h5 id="1-设置name和email"><a href="#1-设置name和email" class="headerlink" title="1. 设置name和email"></a>1. 设置name和email</h5><p>在项目目录下，打开cmd输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">git config user.name &quot;xxx&quot;<br>git cinfig user.email &quot;xxx@gmail.com&quot;<br></code></pre></td></tr></table></figure><h5 id="2-生成密钥"><a href="#2-生成密钥" class="headerlink" title="2. 生成密钥"></a>2. 生成密钥</h5><p>密钥默认生成在用户目录下的<code>.ssh</code>文件夹中，如果已经存在，请备份或指定其他位置</p><p>按三次回车后生成密钥，然后把<code>.pub</code>中内容添加到GitHub的<code>SSH and GPG keys</code>中上</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ssh-keygen -C &quot;xxx@gmail.com&quot;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-t：指定密钥类型，默认rsa</li><li>-C：添加注释</li><li>-f：指定密钥保存的文件</li><li>-b：指定密钥长度，最小1024位，默认3072</li></ul><p>如果想要更高的安全性，密钥签名算法可以选择<code>ed25519</code>，其长度为256位，无需设置密钥尺寸</p><h5 id="3-指纹"><a href="#3-指纹" class="headerlink" title="3.指纹"></a>3.指纹</h5><p>生成密钥对后，命令行中会显示一串字母，称为指纹。第一次连接远程主机时，也会显示指纹。</p><p>指纹是公钥经过哈希和编码后生成的较短的字符串，通过它可以判断本地密钥对的公钥和远程主机配置的公钥是否一致</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Your public key has been saved <span class="hljs-keyword">in</span> C:/Users/xxx/.ssh/test_rsa/id_rsa.pub.<br>The key fingerprint is:<br>SHA256:nCWjRmyWUj7+E8/X9UW5KRdsl9Ml4W0z1t8X5vsRmFs 87654321xxx@gmail.com<br></code></pre></td></tr></table></figure><h2 id="五、把多个提交合并为一个"><a href="#五、把多个提交合并为一个" class="headerlink" title="五、把多个提交合并为一个"></a>五、把多个提交合并为一个</h2><blockquote><p>为了让master分支更加干净一些，我们在提MR之前，最好先把自己分支上的多个提交合并成一个。</p><p>有两种方式可以实现</p></blockquote><p><strong>第一种：替换旧的提交</strong></p><p>在每次提交时，添加<code>amend</code>参数，即</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git commit -amend<br></code></pre></td></tr></table></figure><p>该参数会覆盖上一次的提交，并生成新的commit</p><p>只要我们在第二次及以后每次提交时，都采用该命令，就可以始终保持commit记录为一个了。</p><p><strong>注意</strong>：之后<code>push</code>到远程分支，要带上<code>-f</code>参数，即<strong>强制推送</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git push -f <br></code></pre></td></tr></table></figure><p><strong>局限性</strong>：如果我们已经有了多次提交，那么这个方式就不太适用。</p><p><strong>第二种：rebase命令</strong></p><p>用git log查看提交日志，选择最近的一次他人提交，复制id</p><p>git rebase -i id，然后在vim模式下把不想要的提交前缀改为d，想要合并的改为s，保持上面第一个为pick即可</p><p>最后rebase完毕后，<strong>记得要强制push</strong></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引及优化</title>
      <link href="2021/08/16/MySQL/%E7%B4%A2%E5%BC%95/"/>
      <url>2021/08/16/MySQL/%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="一、索引数据结构类型"><a href="#一、索引数据结构类型" class="headerlink" title="一、索引数据结构类型"></a>一、索引数据结构类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>这是一类由<code>B-Tree</code>、<code>B+Tree</code>或<code>B*Tree</code>的数据结构来进行表数据存储的索引结构。</p><p>至于这三者的区别，因为与索引优化无关，就不再这里介绍。</p><p><strong>B+Tree结构</strong></p><p>每个节点都可以看作是逻辑页，中间节点存储了指向下层逻辑页的指针，然后叶子节点存储了指向其他叶子节点的指针。</p><p><strong>即中上部分是树，且最底层的叶子用双向链表相接</strong></p><p>一般来说，B-Tree作为索引，可以支持多种方式的查询（这里指能用到索引的查询方式）</p><ul><li>全值匹配<ul><li>查询条件和索引的所有列匹配</li><li>例如以姓名和年龄建了索引，那么执行<code>SELECT * FRPM user WHERE name = &quot;zhangsan&quot; AND age = 18</code>就用到了全值匹配</li></ul></li><li>最左前缀匹配<ul><li>用索引的第一列查询</li><li>例如只用<code>name</code>来查询，但是如果只用<code>age</code>查询，无法走索引查询，因为索引树在构建时，是先按name再按age的顺序来排的。</li></ul></li><li>范围匹配<ul><li>匹配索引第一列的某个范围</li></ul></li></ul><p><strong>使用B-Tree这类索引的限制</strong></p><p>最左前缀原则，查找时必须匹配索引的第一列才行，不能跳过。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引是通过计算索引列的值得到哈希码，然后去哈希表中拿到对应数据的地址，最后获取数据的。</p><p>例如<code>name</code>字段建立了哈希索引，那么在查询<code>name = &quot;zhangsan&quot;</code>时，会计算得到某个key，然后去哈希表中得到value。value表示的就是数据存放的地址。</p><p>因此它不支持范围查找、部分索引列查找、排序等等。</p><p>但是它也有优点，相对来说查询速度会更快。。</p><blockquote><p>这里提一句，InnoDB引擎实现了自适应哈希索引，即在B+Tree基础上，对于一些频繁使用的索引值，系统会对它们创建一个哈希索引。</p><p>只能说InnoDB牛批！</p></blockquote><h3 id="空间索引R-Tree"><a href="#空间索引R-Tree" class="headerlink" title="空间索引R-Tree"></a>空间索引R-Tree</h3><p>MyISAM支持空间索引，它不需要前缀匹配，因为它会从所有维度来索引数据？？？</p><p>但是MySQL的GIS支持不完善，不推荐使用…</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>这是一种特殊的索引，它查找的是文本中的关键词，而不是直接比较索引值。    </p><h2 id="二、索引优点"><a href="#二、索引优点" class="headerlink" title="二、索引优点"></a>二、索引优点</h2><ul><li>减少服务器需要扫描的数据量</li><li>避免排序和临时表</li><li>将随机IO变为顺序IO</li></ul><h2 id="三、索引优化"><a href="#三、索引优化" class="headerlink" title="三、索引优化"></a>三、索引优化</h2><h3 id="使用独立的列"><a href="#使用独立的列" class="headerlink" title="使用独立的列"></a>使用独立的列</h3><p>假如age建立了索引，那么查询时要使用<code>age = 18</code>而不是<code>age + 1 = 19</code>这种形式。</p><h3 id="模拟哈希索引"><a href="#模拟哈希索引" class="headerlink" title="模拟哈希索引"></a>模拟哈希索引</h3><p>假设表采用InnoDB引擎，如果查询条件包含url字符串，如</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> url <span class="hljs-keyword">WHERE</span> url <span class="hljs-operator">=</span> &quot;www.baidu.com&quot;;<br></code></pre></td></tr></table></figure><p>对<code>url</code>字段直接建索引，会使得索引的体积非常大，因为url本身是有一定长度的。</p><p>这时我们可以采取伪哈希索引，即在表中新增一列<code>url_crc</code>，然后该列的值为对url字段进行哈希后的整型，对整型建索引和查找是比较高效的。</p><p>这里有个注意点，因为哈希值可能会发生冲突（即重复），所以查询时还是要带上原url，如下所示</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> url <span class="hljs-keyword">WHERE</span> url <span class="hljs-operator">=</span> &quot;www.baidu.com&quot; <span class="hljs-keyword">AND</span> url_crc <span class="hljs-operator">=</span> CRC32(&quot;www.baidu.com&quot;);<br></code></pre></td></tr></table></figure><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>另一种解决查询条件的字符串过长的方法，是建立前缀索引</p><p>在前缀的长度和区分度上寻求一个平衡，使得既能提高查询效率，又不至于出现太多重复的索引值。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>如之前提过的<code>name</code>和<code>age</code>，两者查询是交集的话，就可以建立以name和age共同构建的联合索引，而不是两个单列索引。</p><p>如果两者查询是并集，如</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> &quot;zhangsan&quot; <span class="hljs-keyword">OR</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure><p>这样可以建立两个单列索引，但是查询写法要改一下，用<code>union</code>使两个查询都能用到索引（虽然MySQL现在也会优化成联合的方式）</p><p><strong>正确做法</strong></p><ul><li>建两个单列索引</li><li>使用联合</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> &quot;zhangsan&quot;<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">!=</span> &quot;zhangsan&quot; <span class="hljs-keyword">AND</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>这是由存储引擎实现的，这里讨论的是InnoDB。</p><p>聚簇索引就是在索引中把数据和索引值都放在一起，可以说，<strong>聚簇索引就是一张表</strong>，默认用主键来构建聚簇索引。</p><p>在InnoDB的实现中，B+Tree的叶子节点存放了索引列的值和其他列的值（即所有数据），中间节点只存放了索引列的值</p><p><strong>好处</strong></p><p>查询和非聚簇索引相比更快，因为可以直接拿到数据，不用再去其他地方读</p><p>聚簇索引中获取一个页中的相关数据会非常快，比如用户的所有邮箱数据都聚集在一个页中，那么可以快速获得</p><p><strong>坏处</strong></p><p>插入时：按照主键递增的顺序插入效率最高，如果主键不递增，那么插入到索引的中间位置，开销就会变大</p><p>更新时：在聚簇索引中，想要在修改索引列的值，代价会非常高</p><p><strong>二级索引</strong></p><p>主键构成的索引就是聚簇索引，那么其他列构成的索引就是二级索引了。</p><p>二级索引的叶子存储了对应记录的主键，思考一哈，为啥不存指向那行数据的指针呢？</p><blockquote><p>原因就是降低维护成本。如果二级索引的叶子节点存储数据的行指针，那么数据的位置发生变化（行移动或页分裂）时，就要增加二级索引的维护工作。</p></blockquote><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>查询时如果当前索引就包含了要查询的内容，不必再拿着主键去聚簇索引中查找，这种情况就被称为<code>覆盖索引</code></p><p>使用覆盖索引查询，就减少了回表的次数，提高查询效率</p><h3 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h3><p>两种方式可以得到有序的数据：排序和索引顺序扫描。</p><p><strong>索引顺序扫描</strong></p><p>在索引按顺序扫描时，如果每条记录都不能覆盖所需字段，它就得回表查询对应的数据行</p><p>这样产生的IO开销，会导致索引顺序扫描的速度比顺序全表扫描还来的慢。</p><h3 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h3><p><code>重复索引</code>是指索引列及其顺序都一致，这种重复情况应该避免。</p><p>而<code>索引冗余</code>是指，某个索引包含了原有的索引，是其超集。</p><p>例如现在已经建立<code>name</code>字段的索引，现在又新建了一个<code>name</code>和<code>age</code>字段的联合索引，这种情况就是冗余索引。</p><p><strong>那我们可不可以扩展原先的<code>name</code>索引呢，这样不就可以避免索引冗余了</strong></p><p>但是扩展<code>name</code>索引，给它加上age字段，会使原来的索引变大，从而影响其他使用原索引的查询速度</p><p>索引冗余有个致命的缺陷，就是索引越多，增删改的性能就会越低。所以要根据具体情况来决定是否冗余索引。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="2021/05/13/leetcode/17_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>2021/05/13/leetcode/17_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>链接直达<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个字符串，找出其中的最长的回文子串</p><p>回文示例：aba，a，abba等</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>观察<code>abcba</code>回文字符串，我们发现以下特征：</p><ol><li><code>下标0</code>和<code>下标4</code>处字符相等</li><li>它的子结构<code>bcb</code>是回文字符串</li><li>单个字符<code>c</code>也是回文的</li></ol><p><strong>1.状态定义</strong></p><p><code>dp[i][j]</code>表示下标从<code>i</code>到<code>j</code>的字符串是否回文（true或false）。</p><p><strong>2.状态初始化</strong></p><p>$当i == j 时，dp[i][j] = true$，即（1，1）、（2，2）、（3，3）等位置均是<code>true</code>。</p><p><strong>3.状态转移</strong></p><p>$dp[i][j] = true$：字符串<code>i</code>位置与<code>j</code>位置字符相等，且掐头去尾后，仍是回文字符串，即满足  $dp[i+1][j-1] = true$</p><p>$dp[i][j] = false$：除上述情况以外。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = s.length();<br>    <br>    <span class="hljs-comment">//记录变量</span><br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//初始化dp</span><br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len][len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>        dp[i][i] = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//开始遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; len; j ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (i == j-<span class="hljs-number">1</span> || dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])) &#123;<br>                dp[i][j] = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-comment">//比较回文串长度</span><br>                <span class="hljs-keyword">if</span> (end - start &lt; j - i) &#123;<br>                    start = i;<br>                    end = j;<br>                &#125;<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.substring(start, end + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序链表中的重复元素</title>
      <link href="2021/05/13/leetcode/16_%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>2021/05/13/leetcode/16_%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h1><p>链接直达：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>维持一个<code>cur</code>指针，表示当前节点</li><li>循环结束条件：<code>cur</code>或<code>cur.next</code>指向空，表示遍历到链表尾部</li><li>$cur.val == cur.next.val$<ul><li>跳过<code>next</code>节点</li></ul></li><li>$cur.val != cur.next.val$<ul><li>更新<code>cur</code>指针，指向下一个节点</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span> &amp;&amp; cur.next != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.val == cur.next.val) &#123;<br>            cur.next = cur.next.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.next;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="2021/05/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2021/05/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h3 id="一、最基础版"><a href="#一、最基础版" class="headerlink" title="一、最基础版"></a>一、最基础版</h3><p>特点</p><ul><li><p>循环条件：$left &lt;= right，即left = right + 1时退出循环$</p></li><li><p>命中<code>target</code>直接返回，退出循环就说明没找到</p></li></ul><p>这样的二分查找有个缺点，无法找到相同数字的边界，只能看情况找。</p><p><strong>例如数组[1,2,2,2,3]，查找2的话会命中中间的，无法处理边界。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、搜索左侧边界"><a href="#二、搜索左侧边界" class="headerlink" title="二、搜索左侧边界"></a>二、搜索左侧边界</h3><p><strong>特点</strong></p><ul><li><strong>找到相同元素时收缩右侧边界，目的在于向左侧靠拢</strong></li><li>退出循环时$left = right + 1$，此时<ul><li><code>target</code>大于所有元素，会发生越界，返回<code>-1</code></li><li><code>left</code>没有命中，返回<code>-1</code></li><li><code>left</code>命中元素，返回<code>left</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>           left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<span class="hljs-comment">//注意点1:收缩右侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//注意点2:判断越界、命中情况</span><br>    <span class="hljs-keyword">if</span> (left == nums.length || nums[left] != target) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、搜索右侧边界"><a href="#三、搜索右侧边界" class="headerlink" title="三、搜索右侧边界"></a>三、搜索右侧边界</h3><p><strong>和左侧边界的方法类似，区别在于命中时要收缩左侧边界，即向右侧靠拢。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>           left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<span class="hljs-comment">//注意点1:收缩右侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//注意点2:判断越界、命中情况</span><br>    <span class="hljs-keyword">if</span> (left == nums.length || nums[left] != target) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础概念</title>
      <link href="2021/05/09/Java/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>2021/05/09/Java/Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><blockquote><p>面向过程是以过程为中心，把问题分解成一个个步骤，然后按步骤来执行。</p></blockquote><h3 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h3><blockquote><p>是一种基于现实世界的概念，以万物皆为对象的思想来解决问题。</p></blockquote><h3 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h3><p><strong>封装：</strong>提取出事物的特征和行为，封装成对象；作用：隐藏细节，代码模块化</p><p><strong>继承：</strong>使用现有对象的所有功能，而且不用修改原对象，就能进行扩展。作用：扩展功能</p><p>前两者都是为了重用代码</p><p><strong>多态：父类用子类是去实现，为了接口重用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式id生成</title>
      <link href="2021/05/09/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90/"/>
      <url>2021/05/09/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式id生成方式"><a href="#分布式id生成方式" class="headerlink" title="分布式id生成方式"></a>分布式id生成方式</h1><h3 id="一、数据库自增ID"><a href="#一、数据库自增ID" class="headerlink" title="一、数据库自增ID"></a>一、数据库自增ID</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>创建表时设置主键为<code>auto_increment</code></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>实现简单，但是每次生成ID都要访问一次数据库，带来压力；而且多台设备下可能会重复。</p><h3 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h3>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发学习笔记</title>
      <link href="2021/05/07/Java/Java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1/"/>
      <url>2021/05/07/Java/Java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、理解"><a href="#一、理解" class="headerlink" title="一、理解"></a>一、理解</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>最早接触<code>原子性</code>是在事务的四大特性中，当时理解的是事务要么全部完成，要么就失败回滚。</p><p>看了<code>并发编程实战后</code>，看到了对<code>原子性</code>的全新理解</p><blockquote><p>假设有两个操作A和B，从执行A的线程来看，另一个线程执行B时，要么把B全部执行完，要么就完全不执行，那么A和B对彼此来说，都是原子的。</p></blockquote><h2 id="this逃逸"><a href="#this逃逸" class="headerlink" title="this逃逸"></a>this逃逸</h2><blockquote><p>在类的构造方法中，把<strong>this引用</strong>传递出去，就会造成<strong>this逃逸</strong>。</p><p>哪怕逃逸的语句是写在构造方法的最后一行，但因为JVM指令重排序，可能会让它先执行。</p></blockquote><p>一种<strong>常见的情况</strong>就是在构造方法中启动了一个新线程，我们可以使用<strong>工厂方法</strong>来避免。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java锁机制</title>
      <link href="2021/05/05/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>2021/05/05/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、同步方式"><a href="#一、同步方式" class="headerlink" title="一、同步方式"></a>一、同步方式</h1><p>涉及到线程安全的问题时，往往有两种方式进行数据的同步，即<code>互斥同步</code>和<code>非阻塞同步</code>。</p><ul><li><p>互斥同步</p><p>悲观的思想，认为<code>加锁</code>才能保证数据的线程安全性</p><p>线程挂起、唤醒的操作需要由操作系统来进行，因此互斥同步需要在用户态和内核态切换，开销较大</p></li><li><p>非阻塞访问</p><p>乐观思想，当获取不到锁时，重复地去获取</p><p>这是基于硬件指令集的发展而来的，因为有了<code>Compare-and-Swap</code>指令</p></li></ul><h1 id="二、锁优化"><a href="#二、锁优化" class="headerlink" title="二、锁优化"></a>二、锁优化</h1><p>在这里，锁不仅仅指互斥同步的锁，还包含了一些不用互斥、阻塞的锁。</p><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><p>当一个线程获取不到锁时，会在处理器中自旋一段时间，避免频繁地挂起、阻塞。</p><p><strong>优化版：根据上次情况，适当改变自旋次数</strong></p><p>如果上次获取过这个对象的锁，那么这次获取的机会也大，自旋次数可以增加一些</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>检测到持有锁的对象没有发生逃逸，不会存在竞争关系，可以消除当前对象的锁</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>多个锁变为一个锁</p><hr><p>后面的锁会提到底层实现，所以先需要了解一些前缀知识。</p><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>对象头包含<code>mark word</code>和标记，其中<code>mark word</code>包含了对象的哈希码、回收年龄等。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>前面提到互斥锁需要切换到内核态，开销较大。所以我们思考，能不能用非阻塞的方式来实现锁机制。</p><p>而轻量级锁就是一种基于<code>CAS</code>的锁机制。</p><p><strong>加锁过程</strong></p><ol><li><p>在线程的栈帧中开辟<code>Lock Record</code>空间，记录对象头中<code>mark word</code>内容</p></li><li><p>用<code>CAS</code>操作把指向<code>Lock Record</code>的指针替换对象头中的<code>mark word</code></p><p>如果成功，则表示获取到锁，可以执行同步代码块</p><p>如果失败，检验一下指针是不是指向自己栈帧的，来判断锁是不是自己的        </p></li></ol><p><strong>释放锁过程</strong></p><ol><li><p>用<code>CAS</code>操作尝试把<code>Lock Record</code>的内容覆盖到<code>对象头</code>中</p><p>如果成功，释放成功</p><p>如果失败，释放并唤醒其他线程???</p></li></ol><p>如果有两个以上线程竞争，就会进行<code>锁膨胀</code>，变为重量级锁</p><p>轻量级锁在有竞争时，既有互斥的开销，还要进行CAS，所以存在竞争时性能较差</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>思想：绝大多数情况下，资源都不存在竞争。</p><p>偏向锁使用了更加轻量级的方式，它连CAS都不用进行，直接令当前线程获取锁。</p><p>但是一旦发生了竞争，就要根据是否加锁，来变为<code>无锁</code>或<code>轻量级锁</code>状态</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>多个线程竞争时，轻量级锁会膨胀为重量级锁，它就表示以前的互斥锁。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——内存管理</title>
      <link href="2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-1程序的运行"><a href="#1-1程序的运行" class="headerlink" title="1.1程序的运行"></a>1.1程序的运行</h2><p>主要有三步，<strong>编译</strong>、<strong>链接</strong>和<strong>装入</strong>。</p><ul><li><strong>编译</strong>，源码编译成若干个目标模块</li><li><strong>链接</strong>，多个目标模块与所需库函数链接，形成完整模块</li><li><strong>装入</strong>，把完整模块装入到内存中</li></ul><h2 id="1-2链接方式"><a href="#1-2链接方式" class="headerlink" title="1.2链接方式"></a>1.2链接方式</h2><h3 id="1-2-1静态链接"><a href="#1-2-1静态链接" class="headerlink" title="1.2.1静态链接"></a>1.2.1静态链接</h3><p>执行前链接库函数</p><h3 id="1-2-2装入时动态链接"><a href="#1-2-2装入时动态链接" class="headerlink" title="1.2.2装入时动态链接"></a>1.2.2装入时动态链接</h3><p>模块放入内存时，链接上目标库函数</p><h3 id="1-2-3运行时动态链接"><a href="#1-2-3运行时动态链接" class="headerlink" title="1.2.3运行时动态链接"></a>1.2.3运行时动态链接</h3><p>执行时需要某个模块时，才进行链接</p><h2 id="1-3装入方式"><a href="#1-3装入方式" class="headerlink" title="1.3装入方式"></a>1.3装入方式</h2><p>装入过程中，要把模块放入到内存中运行，可是该放在内存的哪个位置呢？</p><p>因此出现了3种不同的装入方式，<strong>绝对装入</strong>、<strong>静态重定位</strong>和<strong>动态重定位</strong>。</p><h3 id="1-3-1绝对装入"><a href="#1-3-1绝对装入" class="headerlink" title="1.3.1绝对装入"></a>1.3.1绝对装入</h3><p>编译时程序就已经知道了它的物理（绝对）地址，所以装入时直接放在相应位置即可。</p><p>只适用于单道程序环境</p><h3 id="1-3-2静态重定位"><a href="#1-3-2静态重定位" class="headerlink" title="1.3.2静态重定位"></a>1.3.2静态重定位</h3><p>由装入程序把逻辑地址转变成物理地址</p><p><strong>特点：装入时必须分配所需的全部内存空间</strong></p><p>早期多道批处理系统使用这种方式。</p><h3 id="1-3-3动态重定位"><a href="#1-3-3动态重定位" class="headerlink" title="1.3.3动态重定位"></a>1.3.3动态重定位</h3><p>装入时还是使用的逻辑地址，等到指令真正运行时，才会把逻辑地址转换成物理地址</p><p>是通过一个<code>重定位寄存器</code>存储模块的起始位置来实现的。</p><h2 id="1-4编址方式"><a href="#1-4编址方式" class="headerlink" title="1.4编址方式"></a>1.4编址方式</h2><p>内存有两种编址方式，分别是<strong>按字节编址</strong>和<strong>按字编址</strong></p><ul><li><p><strong>按字节编址</strong></p><p>  从地址0开始，每个存储单元表示1字节</p></li><li><p><strong>按字编址</strong></p><p>  <code>字</code>指的是处理器的字长，例如32位计算机，字长就是32位，转化成字节就是4字节</p><p>  所以每个存储单元就是4字节</p></li></ul><h1 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h1><p>操作系统管理内存，主要做了几件事</p><ol><li>内存空间的分配与回收</li><li>内存空间的扩充</li><li>地址转换</li><li>内存保护</li></ol><p>下面我们打乱顺序，从最简单的开始将。</p><h1 id="三、内存保护"><a href="#三、内存保护" class="headerlink" title="三、内存保护"></a>三、内存保护</h1><p>内存保护指一个进程应该只能访问自己空间的数据</p><p>两种方法：</p><ul><li>一是设置上限、下限寄存器</li><li>二是采用重定位寄存器</li></ul><h1 id="四、内存空间分配与回收"><a href="#四、内存空间分配与回收" class="headerlink" title="四、内存空间分配与回收"></a>四、内存空间分配与回收</h1><p>内存分配可以采用连续分配，也可以采用非连续分配的方式。</p><p>下面这张图介绍了连续分配内存的相关知识。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210505160506.png" alt="连续分配管理"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>书单</title>
      <link href="2021/05/05/%E5%B7%A5%E5%85%B7/%E4%B9%A6%E5%8D%95/"/>
      <url>2021/05/05/%E5%B7%A5%E5%85%B7/%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h1><ul><li><input disabled="" type="checkbox"> Redis设计与实现</li><li><input disabled="" type="checkbox"> 高性能MySQL</li><li><input disabled="" type="checkbox"> 操作系统精髓与设计原理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="2021/05/04/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/05/04/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>在介绍Java内存模型之前，我们先了解下计算机的内存模型，这对Java的内存模型有着很大的参考作用。</p><h2 id="1-1计算机—多任务处理"><a href="#1-1计算机—多任务处理" class="headerlink" title="1.1计算机—多任务处理"></a>1.1计算机—多任务处理</h2><blockquote><p>当前计算机大部分是支持多任务处理；在许多场景下，计算机可以同时处理多个任务。</p></blockquote><p>为什么这样做</p><ol><li><p>压榨CPU资源</p><p>如果只有一个任务，它进行I/O操作时，CPU会空闲</p><p>因此安排多任务执行，避免资源浪费</p></li><li><p>多请求的客观事实</p><p>一个服务器端往往会同时收到几个客户端的请求</p></li></ol><h2 id="1-2计算机—内存模型"><a href="#1-2计算机—内存模型" class="headerlink" title="1.2计算机—内存模型"></a>1.2计算机—内存模型</h2><h3 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h3><p>根据冯诺依曼提出的计算机体系结构，我们令处理器和主存进行通信：</p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504152643.png" alt="image-20210504152623819" style="zoom: 67%;" /><p><strong>缺陷：</strong></p><p>处理器访问寄存器的速度远快于访问主存的速度，而每次都要从主存读数据，要等待很久</p><h3 id="版本2-1"><a href="#版本2-1" class="headerlink" title="版本2.1"></a>版本2.1</h3><p>添加高速缓存，把常用的数据放在缓存中，供处理器直接访问。它的访问速度仅次于寄存器，但是比主存快很多。</p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504153055.png" alt="image-20210504153047767" style="zoom:67%;" /><p><strong>缺陷：</strong></p><ul><li><p>缓存一致性：多个高速缓存如何保证数据的一致（或者说，同步）</p></li><li><p>指令重排序问题：</p><p>处理器内部会优化指令的顺序，以保证CPU资源的高效利用；</p><p>指令重排序保证当前任务内排序后的结果是和原先保持一致的，但不保证多任务间数据的协调。</p></li></ul><h3 id="版本2-2"><a href="#版本2-2" class="headerlink" title="版本2.2"></a>版本2.2</h3><p>添加缓存一致性协议，来确保缓存间数据的可见性</p><p><strong>可见性</strong>就是指当一个高速缓存内的数据发生变化时，其他拥有该数据的高速缓存应该能察觉到它的变化。</p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504154702.png" alt="image-20210504154658533" style="zoom:67%;" /><h1 id="二、Java内存模型"><a href="#二、Java内存模型" class="headerlink" title="二、Java内存模型"></a>二、Java内存模型</h1><p>Java内存模型设计如下：</p><p>可以看到，它和计算机的内存模型基本一致。</p><ul><li><p>Java线程用来执行任务，每个线程都拥有工作内存；</p></li><li><p>所有的任务都必须在工作内存中执行。</p></li><li><p>所有的数据都存放在主内存中，通过<code>save</code>和<code>load</code>等操作加载到工作内存中</p></li></ul><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210504155538.png" alt="image-20210504155535163" style="zoom:67%;" /><h2 id="2-1原子操作"><a href="#2-1原子操作" class="headerlink" title="2.1原子操作"></a>2.1原子操作</h2><p>Java提供了一些原子的、不可再分的操作，如下。</p><h3 id="作用于主内存中的变量"><a href="#作用于主内存中的变量" class="headerlink" title="作用于主内存中的变量"></a>作用于主内存中的变量</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">lock</td><td align="center">加锁，标志一个变量为线程独占状态</td></tr><tr><td align="center">unlock</td><td align="center">解锁，把一个处于线程独占状态的变量释放出来</td></tr><tr><td align="center">read</td><td align="center">把变量传输到工作内存中，配合load使用</td></tr><tr><td align="center">write</td><td align="center">把工作内存传来的变量写入到主内存中，配合store使用</td></tr></tbody></table><h3 id="作用于工作内存中的变量"><a href="#作用于工作内存中的变量" class="headerlink" title="作用于工作内存中的变量"></a>作用于工作内存中的变量</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">load</td><td align="center">把主内存传来的变量放入工作内存的变量副本中</td></tr><tr><td align="center">use</td><td align="center">把变量传递给执行引擎</td></tr><tr><td align="center">assign</td><td align="center">把执行引擎传过来的变量赋值给工作内存</td></tr><tr><td align="center">store</td><td align="center">把变量传给主内存</td></tr></tbody></table><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>使用<code>read</code>和<code>load</code>组合把变量从<code>主内存</code>传递到<code>工作内存</code>，并保存在工作内存的变量副本中。</p><p>使用<code>store</code>和<code>write</code>组合把变量从<code>工作内存</code>传递到<code>主内存</code>，并写入。</p><h1 id="三、内存模型三大特征"><a href="#三、内存模型三大特征" class="headerlink" title="三、内存模型三大特征"></a>三、内存模型三大特征</h1><blockquote><p>Java内存模型以及相关指令主要是围绕<strong>如何处理并发过程中的原子性、可见性和有序性</strong>进行的。</p></blockquote><p>下面我们就来谈谈这三大特征。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><blockquote><p>原子性，指某个操作不可再分。</p></blockquote><p>上面提到的8个指令都支持原子性：</p><ul><li><p>8个指令本身都是原子性的</p><p>单个操作是原子性的，一起使用就不一定了</p></li><li><p>lock和unlock可以保证更大维度的原子性</p><p><code>synchronized</code>关键字是用字节码指令<code>monitorenter</code>和<code>monitorexit</code>实现的，这两个指令隐式的表达了<code>lock</code>和<code>unlock</code>的意思。</p></li></ul><p>所以我们可以认为：</p><ol><li><p><strong>基本数据类型的访问、读写都是具有原子性的</strong></p></li><li><p><strong><code>synchronized</code>关键字修饰的代码块是具有原子性的</strong></p></li><li><p><strong><code>volatile</code>关键字修饰的变量是不具备原子性的</strong></p><p>这个如何理解呢？</p><p>volatile修饰，只是保证了读取变量时，是最新的正确的</p><p>但是后续的更新、赋值过程，别的线程是可以修改变量，从而使当前值失效的。</p></li></ol><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><blockquote><p>可见性指<strong>volatile</strong>修饰的变量，一旦被某个线程修改，其他线程可以立刻察觉到变化。</p></blockquote><p>Java有3个关键字能实现可见性，分别是<code>volatile</code>、<code>synchronized</code>和<code>final</code></p><ul><li><p><strong>volatile</strong>，后面会介绍</p></li><li><p><strong>synchronized</strong></p><p><code>unlock</code>后必须写回到主内存，从而保证了可见性</p></li><li><p><strong>final</strong></p><p>该关键字修饰的变量，一旦完成初始化，其他线程都可见。</p></li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><blockquote><p>如果在本线程内观察，所有操作都是有序的；如果在其他线程中观察，那么观察到的都是无序的操作。</p></blockquote><p>两种方式实现有序性：</p><ul><li><p>volatile，后面介绍</p></li><li><p>synchronized</p><p>因为变量在同一时间只能被一个线程<code>lock</code>，所以代码块只能串行进入。</p></li></ul><h1 id="四、Volatile关键字"><a href="#四、Volatile关键字" class="headerlink" title="四、Volatile关键字"></a>四、Volatile关键字</h1><p><code>volatile</code>关键字用来修饰变量，它有两个作用：</p><ul><li>保证可见性</li><li>禁止指令重排序</li></ul><p>接下来我们从内存模型的角度理解一下它的实现。</p><h2 id="3-1保证可见性"><a href="#3-1保证可见性" class="headerlink" title="3.1保证可见性"></a>3.1保证可见性</h2><blockquote><p>可见性指<strong>volatile</strong>修饰的变量，一旦被某个线程修改，其他线程可以立刻察觉到变化。</p></blockquote><p>Java虚拟机通过原子操作实现了这一点</p><p>现在假设变量<code>a</code>是被volatile修饰的，那么</p><ol><li><p><code>read</code>、<code>load</code>和<code>use</code>组合使用</p><p><code>a</code>在使用时必须从主内存中读取到工作内存中，然后再传递给执行引擎</p></li><li><p><code>asign</code>、<code>store</code>和<code>write</code>组合使用</p><p><code>a</code>修改后，由执行引擎传递给工作空间，然后必须再写回主内存中。</p></li></ol><h2 id="3-2禁止指令重排序"><a href="#3-2禁止指令重排序" class="headerlink" title="3.2禁止指令重排序"></a>3.2禁止指令重排序</h2><blockquote><p>指令重排序是处理器为了高效利用资源而进行的操作</p><p>该操作不影响当前线程的最终结果</p></blockquote><p>在多线程环境下，指令重排序可能会造成访问数据错误。</p><p>虚拟机通过设置<code>内存屏障</code>的方式来禁止指令重排，具体地说，是禁止让屏障之后的指令，重排序到内存屏障的前面。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务详解</title>
      <link href="2021/05/02/MySQL/%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/02/MySQL/%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是事务"><a href="#一、什么是事务" class="headerlink" title="一、什么是事务"></a>一、什么是事务</h1><h3 id="事务定义如下："><a href="#事务定义如下：" class="headerlink" title="事务定义如下："></a>事务定义如下：</h3><blockquote><p>访问并可能更新数据库中各项数据的一个<strong>程序执行单元</strong></p></blockquote><h3 id="事务特性："><a href="#事务特性：" class="headerlink" title="事务特性："></a>事务特性：</h3><table><thead><tr><th>特性（ACID）</th><th>描述</th></tr></thead><tbody><tr><td>原子性</td><td>事务内的操作要么全部完成，要么全部失败回滚</td></tr><tr><td>一致性</td><td>依赖于开发者，来保证数据库在一个事务执行前后都处于正确状态</td></tr><tr><td>隔离性</td><td>并发事务之间相互隔离，察觉不到有其他事务在执行</td></tr><tr><td>持久性</td><td>事务一旦被提交，对数据的改变就是永久性的，即使故障也不会丢失改变的提交。</td></tr></tbody></table><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table><thead><tr><th align="center">级别\问题（是否存在）</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">读已提交</td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">可重复读</td><td align="center">否</td><td align="center">否</td><td align="center">是（MVCC时有）</td></tr><tr><td align="center">串行化</td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><h1 id="二、事务实现"><a href="#二、事务实现" class="headerlink" title="二、事务实现"></a>二、事务实现</h1><p>上面介绍的四个特性中，隔离性由锁来实现；原子性、一致性和持久性通过数据库的<code>redo log</code>和<code>undo log</code>来完成。</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p><code>redo log</code>是一种<code>物理格式</code>日志，记录了对页的修改；它实现了事务的持久性，由两部分组成：</p><ul><li>内存中的<code>重做日志缓冲</code>(redo log buffer)</li><li>操作系统缓存中的<code>重做日志文件</code>(redo log file)</li></ul><p><strong>注意，这里为什么是在操作系统中呢？因为打开日志文件时没有使用<code>O_DIRECT</code>标志位，所以不能绕过操作系统直接添加到磁盘中。</strong></p><p>所以从内存中更新数据到磁盘，经历了以下过程：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210502235152.png" alt="img"></p><p>可以看到，从操作系统缓冲写入到磁盘，需要进行<code>fsync()</code>操作；多久执行一次该操作，可以通过参数<code>innodb_flush_log_at_trx_commit</code>来决定。该参数有三个取值，分别是0，1，2。</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">表示主线程每隔一秒执行一次<strong>fsync()</strong></td><td align="center">数据库或计算机宕机时，都会丢失一部分数据</td></tr><tr><td align="center">1</td><td align="center">表示事务每提交一次，就执行一次<strong>fsync()</strong></td><td align="center">并发场景下性能较差</td></tr><tr><td align="center">2</td><td align="center">表示事务提交时，把<strong>重做日志缓冲</strong>写入到<strong>重做日志文件</strong>中</td><td align="center">数据库宕机不会影响，因为日志已经在操作系统缓冲区了；系统宕机时，会丢失一部分数据</td></tr></tbody></table><p>下面我们介绍redo log的存储结构</p><h3 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h3><p>在<code>innodb</code>存储引擎中，重做日志是以<strong>块</strong>（每块512字节）的方式存储的，重做日志缓冲和重做日志文件统称为重做日志块。</p><p>日志块结构如下，主要有三部分组成，<code>12</code>字节的头部，<code>8</code>字节的尾部和<code>492</code>字节的内容</p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210503001857.png" alt="image-20210503001857387" style="zoom:67%;" /><p>如果重做日志大于512字节，就需要多个日志块来存储。</p><p>此外，还有一些相关概念，如<code>log group</code>、<code>LSN</code>等就不再介绍，以后再补充。。。</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>undo log</code>记录的是逻辑操作，具体地说，应该是事务中每步操作的<code>逆向操作</code></p><p>例如，事务中执行了一条插入语句，那么<code>undo log</code>就会记录一次删除。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><p>回滚</p><p>在事务失败时，可以根据它回滚到事务开始前的状态。</p></li><li><p>多版本控制</p><p>在MVCC中，如果数据被其它事务占用，就可以根据<code>undo log</code>来获取之前版本的数据，避免阻塞地获取锁。</p></li></ul><h3 id="3种操作的undo-log"><a href="#3种操作的undo-log" class="headerlink" title="3种操作的undo log"></a>3种操作的undo log</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>因为事务隔离性的要求，插入数据只对当前事务可见，其他事务不应该发现。</p><p>所以它产生的undo log可以在事务提交后直接删除</p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>先执行逻辑删除，把标志位设置成删除，然后等待purge线程进行物理删除</p><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>这里分两类讨论</p><ul><li><p>不更新主键</p><p>直接更新即可，并生成undo log</p></li><li><p>更新主键</p><p>先标记删除原有主键的记录，再执行插入。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有效的括号</title>
      <link href="2021/05/02/leetcode/14_%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>2021/05/02/leetcode/14_%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一串括号序列，判断它是否可以正确闭合。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>利用栈先入后出的特点来存储左括号，遇到右括号就取出来比较。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i ++) &#123;<br>        j = handler(s.charAt(i));<br>        <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>            stack.push(j);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stack.isEmpty() || stack.poll() + j != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">handler</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (ch) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span> :<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span> :<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span> :<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span> :<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;]&#x27;</span> :<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#125;&#x27;</span> :<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表Ⅱ</title>
      <link href="2021/05/02/leetcode/15_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/"/>
      <url>2021/05/02/leetcode/15_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="环形链表Ⅱ"><a href="#环形链表Ⅱ" class="headerlink" title="环形链表Ⅱ"></a>环形链表Ⅱ</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定链表，返回链表中第一个环节点，如果无环，返回null</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题是环形链表的变形题，在原先基础上，还要找到环节点。</p><p>思路依旧是快慢指针，第一次相遇后，让快指针从头开始，一步一步走，慢指针保持不变；然后它们再次相遇时，就在环节点处。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode slow = head;<br>    ListNode fast = head;<br>    <span class="hljs-comment">// 第一次相交</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 判断是否是空</span><br>    <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125; <br>    <span class="hljs-comment">// 第二次相交</span><br>    fast = head;<br>    <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fast;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue指令学习</title>
      <link href="2021/05/01/Vue/%E6%8C%87%E4%BB%A4/"/>
      <url>2021/05/01/Vue/%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h3><blockquote><p>代码部分只展示了关键部分</p></blockquote><h5 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h5><p>通过参数来设置标签内的值</p><p>注意，会覆盖标签内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;div id&#x3D;&#39;demo&#39; v-text&#x3D;&#39;para&#39;&gt;被覆盖啦呀，真惨&lt;&#x2F;div&gt; <br></code></pre></td></tr></table></figure><h5 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h5><p>和 <code>v-text</code> 类似，区别在于 <code>v-html</code> 能解析成HTML，进行赋值</p><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><p>绑定方法，<strong>简写形式如下</strong></p><p>另外，绑定方法可以具体化，如@keyup.enter表示键盘键入回车键后，调用某方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;input id&#x3D;&#39;demo&#39; @click&#x3D;&#39;method&#39; type&#x3D;&quot;button&quot; value&#x3D;&quot;按钮&quot;&gt;&lt;&#x2F;input&gt; <br></code></pre></td></tr></table></figure><hr><h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p>用来改变元素的属性值，来使它隐藏或出现</p><p>注意，是通过修改属性的方式实现的</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;div id&#x3D;&#39;demo2&#39;&gt;<br>       &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点击改变&quot; @click&#x3D;&#39;click_it&#39;&gt; <br>       &lt;p v-show&#x3D;&quot;flag&quot;&gt;嘿嘿，会员内容哦&lt;&#x2F;p&gt;   <br>   &lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><p>同样也是用来决定元素的隐藏与出现</p><p>但是它是通过修改DOM树的方式实现的</p><h5 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h5><p>设置元素的内部属性，如src、<strong>class</strong></p><p><strong>简写形式如下</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;div id&#x3D;&#39;demo&#39; &gt;<br>        &lt;img v-bind:src&#x3D;&quot;para&quot;&gt;<br>&lt;&#x2F;div&gt;<br><br>&lt;!-- 下面的改变class属性比较重要 --&gt;<br>&lt;div id&#x3D;&#39;demo&#39; &gt;<br>        &lt;img :class&#x3D;&quot;&#123;clazz_type:isNeedToChange&#125;&quot;  v-bind:src&#x3D;&quot;para&quot;&gt;<br>&lt;&#x2F;div&gt;<br>&lt;!-- 一些参数 --&gt;<br>isNeedToChange: true<br>.clazz_type &#123; border: 1px solid red; &#125;<br></code></pre></td></tr></table></figure><hr><h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>遍历数组中的值，并利用一个模板显示出来</p><p>如下，<strong>li <strong>标签就是所谓的模板，在模板中添加</strong>遍历项student</strong>的名字和年龄</p><p>所以就会输出数组中所有学生的名字和年龄</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs vue">&lt;div id&#x3D;&#39;demo&#39; &gt;<br>       &lt;ul&gt;<br>           &lt;li v-for&#x3D;&quot;(student, index) in students&quot;&gt;<br>               第&#123;&#123; index + 1 &#125;&#125;位同学叫&#123;&#123;student.name&#125;&#125;，年龄&#123;&#123;student.age&#125;&#125;<br>           &lt;&#x2F;li&gt;<br>       &lt;&#x2F;ul&gt;<br>   &lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务并发解决方案</title>
      <link href="2021/05/01/MySQL/%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2021/05/01/MySQL/%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h1><p>关于事务的介绍，请看另一篇博客。</p><p><strong>解决并发事务访问，主要有两种方式：</strong></p><ul><li><strong>LBCC</strong>（Lock Based Concurrent Control）</li></ul><ul><li><strong>MVCC</strong>（Multi-Version Concurrent Control）</li></ul><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul><li>脏读，读到其他事务修改后未提交的数据</li><li>不可重复读，多次读数据，得到的不一致</li><li>幻读，多次读的结果不同（多了数据或少了数据）</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table><thead><tr><th align="center">级别\问题（是否存在）</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">读已提交</td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">可重复读</td><td align="center">否</td><td align="center">否</td><td align="center">是（MVCC时有）</td></tr><tr><td align="center">串行化</td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><h1 id="二、LBCC"><a href="#二、LBCC" class="headerlink" title="二、LBCC"></a>二、LBCC</h1><h2 id="2-1锁的类型"><a href="#2-1锁的类型" class="headerlink" title="2.1锁的类型"></a>2.1锁的类型</h2><p>官网链接：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">MySQL :: MySQL 8.0 Reference Manual :: 15.7.1 InnoDB Locking</a></p><p>查阅MySQL官网，得知InnoDB存储引擎提到了以下几种锁方案</p><ol><li><p>共享锁与排他锁 （行级别）</p></li><li><p>意向锁 （表级别）</p></li><li><p>记录锁</p></li><li><p>间隙锁</p></li><li><p>Next-Key 锁</p></li></ol><p>还有另外三种不做详细介绍，就简单说明一下概念</p><ol><li>插入意向锁</li><li>自增锁</li><li>预测锁</li></ol><p>下面我们将依次介绍上述5种锁的概念</p><h2 id="2-2共享锁与排他锁"><a href="#2-2共享锁与排他锁" class="headerlink" title="2.2共享锁与排他锁"></a>2.2共享锁与排他锁</h2><p>共享锁和排他锁是InnoDB实现的行级别的锁。</p><p><code>共享锁</code>又叫读锁，用来读取数据。多个共享锁可以同时存在。</p><p><code>排他锁</code>又叫写锁，用来更新或删除数据（插入呢？），不能与其他锁并存</p><p>举个简单的例子</p><p>如果事务<code>T1</code>在读表中的记录<code>r</code>，那它就对记录<code>r</code>加了读锁</p><p>这时候事务<code>T2</code>想要对记录<code>r</code>进行一些操作</p><ul><li>如果是读操作，<code>T2</code>可以直接对记录<code>r</code>加读锁</li><li>如果是写操作，<code>T2</code>必须等待<code>T1</code>释放锁之后，才能对记录<code>r</code>加写锁</li></ul><h2 id="2-3意向锁"><a href="#2-3意向锁" class="headerlink" title="2.3意向锁"></a>2.3意向锁</h2><h3 id="2-3-1为什么要有意向锁呢？"><a href="#2-3-1为什么要有意向锁呢？" class="headerlink" title="2.3.1为什么要有意向锁呢？"></a>2.3.1为什么要有意向锁呢？</h3><p>针对一个场景：</p><p>如果要对一张表加<strong>表锁</strong>，就要先确保表中的<strong>任意一行数据</strong>都没有<strong>被锁定</strong></p><p>那么就需要进行全表扫描来判断，效率十分低下</p><p><strong>而上述问题的本质，就是锁过于单一，只有读锁、写锁这些行级别锁的话，粒度较少，不具备灵活性。</strong></p><p>所以提出了意向锁的思想 。</p><h3 id="2-3-2意向锁"><a href="#2-3-2意向锁" class="headerlink" title="2.3.2意向锁"></a>2.3.2意向锁</h3><blockquote><p>意向读锁：表明一个事务<strong>想要</strong>对某行数据设置读锁。</p><p>意向写锁：表明一个事务<strong>想要</strong>对某行数据设置写锁。</p></blockquote><p>光说这个概念可能不太好理解，我们结合官网上的描述，来分析下它的主要目的、协议吧。</p><h3 id="2-3-3官方解释"><a href="#2-3-3官方解释" class="headerlink" title="2.3.3官方解释"></a>2.3.3官方解释</h3><p><strong>关于意向锁的解释</strong></p><blockquote><p><code>InnoDB</code> supports <em>multiple granularity locking</em> which permits coexistence of row locks and table locks.</p><p><code>InnoDB</code>支持多粒度的锁来保证行锁和表锁的共存。</p><p>Intention locks are <code>table-level</code> locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table. </p><p>意向锁是表级别的锁，它代表一个事务之后想要获取的是什么类型（读锁或写锁）的锁。</p><p>PS：实现了多粒度的锁。</p></blockquote><p><strong>意向锁的主要目的</strong></p><blockquote><p>Intention locks do not block anything except full table requests (for example, <code>LOCK TABLES ... WRITE</code>). The main purpose of intention locks is to show that someone is locking a row, or going to lock a row in the table.</p><p>意向锁不会阻塞除<code>全表扫描</code>外的任何请求，它的主要目的就是表明其他事务正在锁，或者说将要锁某些记录。</p><p>PS：结合上面的例子，有了意向锁之后，就不用靠全表扫描来判断当前事务是否可以加表锁</p></blockquote><p><strong>意向锁的协议</strong></p><blockquote><p>Before a transaction can acquire a shared lock on a row in a table, it must first acquire an <code>IS</code> lock or stronger on the table.</p><p>一个事务获取某行的读锁之前，必须先获取表的意向读锁。</p><p>Before a transaction can acquire an exclusive lock on a row in a table, it must first acquire an <code>IX</code> lock on the table.</p><p>一个事务获取某行的写锁之前，必须先获取表的意向写锁。</p></blockquote><h3 id="2-3-4锁的具体使用"><a href="#2-3-4锁的具体使用" class="headerlink" title="2.3.4锁的具体使用"></a>2.3.4锁的具体使用</h3><p>首先，我们要了解意向锁和读写锁的共存关系（是否兼容）</p><table><thead><tr><th align="center"></th><th align="center">IS</th><th align="center">IX</th><th align="center">S</th><th align="center">X</th></tr></thead><tbody><tr><td align="center"><strong>IS</strong></td><td align="center">是</td><td align="center">是</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center"><strong>IX</strong></td><td align="center">是</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr><tr><td align="center"><strong>S</strong></td><td align="center">是</td><td align="center">否</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center"><strong>X</strong></td><td align="center">否</td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><p><strong>分析：</strong></p><p>意向锁之间：仅仅代表一个加锁的意向，所以意向锁之间不冲突</p><p>读写锁之间：读锁与读锁不冲突，写锁与其他锁（这里只讨论读写锁）都冲突</p><p>混合：要注意有读锁的情况下，意向写锁会冲突，即不能有写的念头。</p><p><strong>用法：</strong></p><p>从官网摘录一段select的语句结构</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>...<br>[FOR &#123;UPDATE | SHARE&#125;<br>        [<span class="hljs-keyword">OF</span> tbl_name [, tbl_name] ...]<br>        [NOWAIT <span class="hljs-operator">|</span> <span class="hljs-keyword">SKIP</span> LOCKED]<br>      <span class="hljs-operator">|</span> LOCK <span class="hljs-keyword">IN</span> SHARE MODE]<br></code></pre></td></tr></table></figure><p><strong>使用意向读锁：</strong></p><p><code>select ... for share</code>或<code>select ... lock in share mode</code></p><p>两种方式来获取IS锁和对应记录的S锁，基本上是等价的</p><p>区别的话</p><ol><li><p>看上面select语句的格式，可以发现<code>for share</code>可以添加一些参数，参数在后面介绍</p></li><li><p><code>lock in share mode</code>提供向后兼容性。</p></li></ol><p><strong>使用意向写锁：</strong></p><p><code>select ... for update</code>语句会先尝试获取IX锁，然后再获取目标记录的写锁</p><p>如果获取不到，则会阻塞等待。（如果超时了就报错）</p><p><strong>参数说明：</strong></p><ul><li>nowait：不等待锁释放，立刻执行，获取不到锁就报错</li><li>skip locked：也是立刻执行，但忽略那些被加锁的数据，只操作不加锁的数据。</li></ul><p>这两个参数在基于语句复制的情况下，是不安全的（官网上提到，但我不懂…猜测一下，可能是在有主从数据库的时候，会不安全吧）</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html">如果想看更详细的，请转至官网处</a></p><hr><p>下面开始是一些具体锁的介绍，先贴一张图大致表示一下</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/20210502173400.png" alt="lock_concret"></p><h2 id="2-4记录锁（锁定记录）"><a href="#2-4记录锁（锁定记录）" class="headerlink" title="2.4记录锁（锁定记录）"></a>2.4记录锁（锁定记录）</h2><p>在进行等值查询时，锁住<strong>匹配</strong>到的记录。确切地说，应该是锁住记录的主键（或隐式主键）</p><p>例如<code>select * from table1 where id = 4 for update</code>就是锁住了<code>id = 4</code>的记录</p><h2 id="2-5间隙锁（锁定范围）"><a href="#2-5间隙锁（锁定范围）" class="headerlink" title="2.5间隙锁（锁定范围）"></a>2.5间隙锁（锁定范围）</h2><p>在查询时，锁定<strong>区间范围</strong></p><p>①<code>select * from table1 where id = 6 for update</code></p><p>②<code>select * from table1 where id &gt; 20 for update</code></p><p>假设表的记录为<strong>1，4，7，10</strong></p><p>那么语句①锁住区间（4，7）；语句②锁住区间（10，+∞）</p><p><strong>间隙锁之间并不冲突</strong></p><h2 id="2-6临界锁（锁定范围，左开右闭）"><a href="#2-6临界锁（锁定范围，左开右闭）" class="headerlink" title="2.6临界锁（锁定范围，左开右闭）"></a>2.6临界锁（锁定范围，左开右闭）</h2><p>条件：进行范围查询时，包含<strong>区间</strong>和<strong>具体记录</strong></p><p><code>select * from table where id &gt; 5 and id &lt; 9 for update</code></p><p>那么锁定的范围为(4，7] 和 (7，10]，即(4，10]</p><p>我们可以发现，<strong>临界锁 = 间隙锁 + 记录锁</strong></p><p><em><strong>而间隙锁锁住区间，不让其他事务进行插入，目的就在于避免幻读问题的出现</strong></em></p><hr><p>讲完这些锁之后，我们谈谈在<strong>不同隔离级别</strong>下<strong>锁</strong>的<strong>实现</strong>：</p><table><thead><tr><th align="center">隔离级别</th><th align="center">机制</th></tr></thead><tbody><tr><td align="center">RU</td><td align="center">不加锁</td></tr><tr><td align="center">Serializable</td><td align="center">所有select语句隐式地转化成共享锁，会与update、delete互斥</td></tr></tbody></table><table><thead><tr><th align="center">隔离级别</th><th align="center">普通select语句</th><th align="center">加锁的select和更新语句</th></tr></thead><tbody><tr><td align="center">RC</td><td align="center">MVCC</td><td align="center">记录锁</td></tr><tr><td align="center">RR</td><td align="center">MVCC</td><td align="center">记录锁、间隙锁、临界锁</td></tr></tbody></table><blockquote><p>①普通查询时，为什么RR可以解决不可重复读，而RC不可以</p><p>两者都采用MVCC，而因为RR的快照读read-view使用的是同一个，而RC是每次查询生成一次新的read-view</p></blockquote><h1 id="三、MVCC"><a href="#三、MVCC" class="headerlink" title="三、MVCC"></a>三、MVCC</h1><h2 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h2><p>用于实现数据库的并发访问的一种方法，全称为多版本并发控制。</p><h2 id="3-2前置概念"><a href="#3-2前置概念" class="headerlink" title="3.2前置概念"></a>3.2前置概念</h2><p>在学习MVCC前，需要先知道两个概念</p><ul><li><strong>当前读</strong></li></ul><p>读取记录的最新版本，读取时还要加锁，保证其他并发事务不能修改当前记录，如共享锁、排他锁都是当前读</p><ul><li><strong>快照读</strong></li></ul><p>不加锁的、非阻塞的读。快照读的实现是基于多版本并发控制的，避免加锁操作，降低开销</p><p>读到的数据不一定是最新数据，可能是历史版本</p><h2 id="3-3思想"><a href="#3-3思想" class="headerlink" title="3.3思想"></a>3.3思想</h2><blockquote><p> 维持一个数据的多个版本，使得读写操作没有冲突</p></blockquote><h2 id="3-4实现"><a href="#3-4实现" class="headerlink" title="3.4实现"></a>3.4实现</h2><p>隐式字段 + undo回滚日志 + 快照</p><ul><li><strong>隐式字段</strong></li></ul><blockquote><p>每行记录除了有用户定义的字段外，还有隐式字段，如事务id、回滚指针、自增ID</p></blockquote><p>依次解释：</p><p>事务id是指<strong>修改过</strong>当前记录的<strong>最近</strong>的一次事务id</p><p>回滚指针，指向的是回滚日志中的关于<strong>这条记录</strong>的<strong>上一个版本</strong></p><p>自增ID，当表没有设定主键时，会采用自增ID来作为主键，构建主键索引</p><ul><li><strong>undo回滚日志</strong></li></ul><p>记录每次修改的操作，可从前往后遍历来进行数据回滚</p><p>在进行<strong>修改（更新、插入、删除）</strong>操作时，mysql会生成一条日志（主键+当前事务id+回滚指针，指向前一条记录）</p><p>删除只是把标志位改为true，即逻辑删除</p><ul><li><strong>read-view</strong></li></ul><blockquote><p>read-view是事务进行快照读时产生的读视图，记录并维护了系统中当前较为活跃的事务id</p></blockquote><h2 id="3-5例子"><a href="#3-5例子" class="headerlink" title="3.5例子"></a>3.5例子</h2><p>在某次事务查询时，得到read-view 为 <strong>[100,200,300]</strong></p><p> 可以看出活跃事务中最小id为100，最大id为300</p><p>从回滚日志中依次向后遍历，假设每次遍历到的事务id为x</p><p>则有以下三种情况：</p><ol><li><p>x &lt; 100 表示此事务已提交，数据可用</p></li><li><p>x &gt; 300 表示此事务还未开始（不确定？）</p></li><li><p>在100和300中间，此时就要查看read-view，如果事务id在read-view里面，即说明此事务是活跃的，还没提交，数据不可用</p><p>否则数据就可用。</p></li></ol><h2 id="3-6RR和RC隔离级别下"><a href="#3-6RR和RC隔离级别下" class="headerlink" title="3.6RR和RC隔离级别下"></a>3.6RR和RC隔离级别下</h2><p>针对同一个事务来说，</p><ul><li><p>读已提交：每次查询都会生成新的read-view</p></li><li><p>可重复读：只用第一次查询时生成的read-view（解决了不可重复读）</p></li></ul><h1 id="四、补充问题"><a href="#四、补充问题" class="headerlink" title="四、补充问题"></a>四、补充问题</h1><h2 id="4-1死锁"><a href="#4-1死锁" class="headerlink" title="4.1死锁"></a>4.1死锁</h2><p><strong>定义</strong></p><p>这里的死锁可以理解成两个及以上的事务在共同竞争锁资源，而产生的等待现象。</p><p><strong>解决方案一</strong></p><p>设置一个超时等待时间，超时后对某个事务进行回滚，然后其他事务就可以执行下去</p><p>但是光靠超时来解决的话，可能会有大量事务要进行回滚，会非常耗时</p><p><strong>解决方案二</strong></p><p>等待图，这可以算是一种死锁检测算法。</p><p>画出各个事务之间的依赖关系，如果形成环路，说明存在死锁。</p><h2 id="4-2锁升级"><a href="#4-2锁升级" class="headerlink" title="4.2锁升级"></a>4.2锁升级</h2><p><del>知识盲区…</del></p><p>InnoDB存储引擎并不存在锁升级的情况，因为它并不是根据每个记录来产生行锁的。</p><p>它是根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/01/MySQL/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2021/05/01/MySQL/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="一、索引的类别"><a href="#一、索引的类别" class="headerlink" title="一、索引的类别"></a>一、索引的类别</h4><ol><li><strong>主键索引</strong>（非空、唯一）</li></ol><p>设定为主键后，自动建的索引</p><blockquote><p><strong>PRIMARY KEY</strong>（id）</p></blockquote><ol start="2"><li><strong>单列索引</strong>（可空，不唯一）</li></ol><blockquote><p><strong>CREATE</strong> <strong>INDEX</strong> name <strong>ON</strong> table(customer_name)</p></blockquote><ol start="3"><li><strong>唯一索引</strong>（可空）</li></ol><blockquote><p><strong>CREATE</strong> <strong>UNIQUE INDEX</strong> name <strong>ON</strong> table(customer_name)</p></blockquote><ol start="4"><li><strong>联合索引</strong></li></ol><p>多个单列索引的开销要大于复合索引，所以数据量大时，用复合索引更好。</p><h4 id="二、最左前缀，最右前缀，为什么要最左前缀"><a href="#二、最左前缀，最右前缀，为什么要最左前缀" class="headerlink" title="二、最左前缀，最右前缀，为什么要最左前缀"></a>二、最左前缀，最右前缀，为什么要最左前缀</h4><p>最左前缀匹配一般是针对联合索引来说的</p><p>例如联合索引（a，b，c），sql语句的条件要是a、ab、abc、ac时，才会触发索引。</p><p>索引在构建时，就是按照从左到右递增的顺序来的，如果查找时不按这个顺序，就只能全表扫描了。</p><h4 id="三、mysql隔离级别，默认隔离级别，底层实现（MVCC-next-key锁）"><a href="#三、mysql隔离级别，默认隔离级别，底层实现（MVCC-next-key锁）" class="headerlink" title="三、mysql隔离级别，默认隔离级别，底层实现（MVCC+next-key锁）"></a>三、mysql隔离级别，默认隔离级别，底层实现（MVCC+next-key锁）</h4><p>首先，弄清楚几个<strong>概念</strong>（事务并发情况下）</p><ol><li><strong>脏读</strong></li></ol><blockquote><p>读到了<strong>其他事务</strong>未提交的数据</p><p>未提交意味着数据可能会变化，不代表最终存储的数据</p></blockquote><ol start="2"><li><strong>可重复读</strong></li></ol><blockquote><p>在一个事务中，两次任意时刻读的数据是一致的</p></blockquote><ol start="3"><li><strong>不可重复读</strong></li></ol><blockquote><p>和可重复读相反，一次事务内，两次读到的数据不一致</p></blockquote><ol start="4"><li><strong>幻读（注意）</strong></li></ol><blockquote><p>和不可重复读类似，但是针对插入数据来说的</p><p>即前后两次查询间隔中，其他事务插入了一条符合条件的数据，导致前后查询不一致</p><p><strong>因为插入数据是对表来说的，所以行锁不能避免幻读，表锁才行</strong></p></blockquote><p>接下来介绍四种事务隔离级别：</p><table><thead><tr><th align="center">隔离级别</th><th align="center">描述</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读未提交 RU</td><td align="center">可以读到其他事务未提交的数据</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">读已提交（不可重复读）RC</td><td align="center">只能读到已经提交的数据</td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">可重复读 RR</td><td align="center">在当前事务持续时，禁止其他事务对此字段的更新</td><td align="center">否</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="center">串行化</td><td align="center">最<strong>严格</strong>，要求所有事务串行执行</td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><h4 id="四、innodb和myisam特点和区别"><a href="#四、innodb和myisam特点和区别" class="headerlink" title="四、innodb和myisam特点和区别"></a>四、innodb和myisam特点和区别</h4><table><thead><tr><th>区别\引擎</th><th>Innodb</th><th>myisam</th></tr></thead><tbody><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>数据和索引</td><td>在一起，聚簇</td><td>分离的，B+树叶子存储数据地址</td></tr><tr><td>支持锁</td><td>支持行锁和表锁</td><td>只支持表锁</td></tr></tbody></table><h4 id="五、行锁和表锁"><a href="#五、行锁和表锁" class="headerlink" title="五、行锁和表锁"></a>五、行锁和表锁</h4><p>行锁：锁一行或多行记录，行锁是基于索引加载的，加在索引匹配到的行上。</p><p>表锁 ：锁定整张表，属于全表扫描时做的。</p><p><strong>对比：</strong></p><p>行锁并发性能高，冲突率低，但会发生死锁</p><p>表锁性能低，冲突率高，锁定的范围大</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>笔记1</title>
      <link href="2021/05/01/MySQL/mysql%E7%AC%94%E8%AE%B0/"/>
      <url>2021/05/01/MySQL/mysql%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h4><ul><li><strong>定义</strong></li></ul><blockquote><p>是帮助MYSQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong></p></blockquote><ul><li><strong>那么该采用什么样的数据结构呢？</strong></li></ul><p>二叉树、红黑树（二叉平衡树）都是不错的</p><p>但数据量过大时，树高度会很大，查找数据时会经过多个节点</p><p>B+树（多叉平衡树）的话，有多个叉，因此可以有效的减小高度，所以采用<strong>B+树</strong>的结构来构建索引较合适。</p><ul><li><strong>B树和B+树的区别</strong></li></ul><p>①B树的叶子节点指针为空，而B+树的叶子节点还有双向指针指向左右两边，<strong>提高区间的访问性</strong></p><p>②B树每个节点都存放数据，B+树只有叶子节点存放了数据</p><h4 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h4><p>首先，要明确一点，存储引擎是修饰表结构的。</p><p>目前主要有两种引擎，<strong>MyISAM</strong>和<strong>InnoDB</strong>（现在流行）</p><p>他们都是用B+树的索引结构来构建表的，不同之处在于：</p><blockquote><p>MyISAM的索引和数据是分离在两个文件中的，索引结构的叶子节点存放数据所在的磁盘地址，根据地址去访问数据</p><p>InnoDB的数据就放在叶节点</p></blockquote><p><strong>为什么建议InnoDB表尽量建主键，并且要是整型自增的？</strong></p><p>因为不是自增的话，构建B+树时发生分裂和冗余的次数会增多</p><h4 id="三、联合索引"><a href="#三、联合索引" class="headerlink" title="三、联合索引"></a>三、联合索引</h4><p>即多个属性作为索引，构建树时，按照声明的属性顺序来排序</p><p><strong>索引最左前缀原则</strong></p><p>查找记录时，条件里的列属性必须是联合索引从左到右顺序的，不能跳，才会走索引来查找</p><p>例如  有联合索引(name，age，job)   查找语句 select * from table where name = 123 and age = 213 会走索引</p><p><strong>走索引</strong></p><blockquote><p>从B+树的根节点开始，向下查找</p></blockquote><p><strong>如果不走索引，会怎么查找呢？</strong></p><p>会从B+树的最左叶子节点，开始向右查找，即全表扫描。</p><p><strong>如果一个表既创建了主键索引，又创建了联合索引，那么联合索引的B+树结构是怎么样的？</strong></p><p>首先，明确一点，如果像主键索引那样建表（即索引节点+叶子节点放数据），就意味着表的数据要复制一份给联合索引，会造成数据冗余</p><p>那么可以只存放必要的数据，即联合索引的多个主键的数据，这样能保证索引到叶子，然后只要叶子节点存放对应的主键索引，就可以去主键索引里找到整条数据。</p><h4 id="五、InnoDB索引"><a href="#五、InnoDB索引" class="headerlink" title="五、InnoDB索引"></a>五、InnoDB索引</h4><p><code>InnoDB</code>把索引分为两类，<strong>聚集索引</strong>和<strong>二级索引</strong></p><blockquote><p><strong>聚集索引</strong>，就是能<strong>唯一确定</strong>数据的逻辑位置和物理位置的索引，在一个表中，只能有一个聚集索引。</p><p>除了聚集索引以外的其他索引，都是二级索引。</p></blockquote><p><strong>聚集索引选择：</strong></p><ol><li><p><code>InnoDB</code>会把主键作为聚集索引</p></li><li><p>如果一个表没有设置主键，那么它会找一个唯一且非空的字段作为聚集索引</p></li><li><p>如果找不到合适字段，就会创建一个名为<code>GEN_CLUST_INDEX</code>的隐式字段作为聚集索引。</p></li></ol><p><strong>聚集索引的好处：</strong>加快查询速度</p><p><strong>怎么加快：</strong>查询时，直接地访问到数据行</p><p><strong>二级索引和聚集索引的关系：</strong></p><p>二级索引中的每条记录都包含了聚集索引的主键列的值，也包含了二级索引定义的字段列的值</p><p>然后通过二级索引查找，最终会根据主键值到聚集索引中去查找数据。</p><p>因此，主键不要过长，不然二级索引也会占用很多空间。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>笔记2</title>
      <link href="2021/05/01/MySQL/mysql%E6%9E%B6%E6%9E%84/"/>
      <url>2021/05/01/MySQL/mysql%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/mysql-struct.png" alt="mysql-struct" style="zoom:150%;" /><h3 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h3><h4 id="一、层次划分"><a href="#一、层次划分" class="headerlink" title="一、层次划分"></a>一、层次划分</h4><p>主要分为三个层次：</p><ul><li>MySQL Server层</li><li>存储引擎层</li><li>文件系统层</li></ul><h4 id="二、MySQL-Server层"><a href="#二、MySQL-Server层" class="headerlink" title="二、MySQL Server层"></a>二、MySQL Server层</h4><p>Server层包括<strong>连接层</strong>和<strong>SQL层</strong></p><blockquote><p>注意，图上的Connectors不属于任何一层，可以将 Connectors 理解为各种客户端、应用服务，主要进行是不同语言与 SQL 的交互。</p></blockquote><p><strong>1. 连接层</strong></p><p>即<strong>Connection Pool</strong>部分，当应用程序通过接口（JDBC、ODBC）连接MySQL时，最先接触到的是连接层。</p><p>连接层包括以下三部分</p><ul><li>通信协议</li></ul><p>负责检测客户端版本是否兼容MySQL服务端</p><ul><li>线程处理</li></ul><p>对每个连接请求分配一个线程</p><ul><li>用户名密码认证</li></ul><p>验证用户的账号密码即host主机授权是否可以连接到MySQL服务器</p><p><strong>Connection Pool（连接池）</strong></p><blockquote><p>将用户连接、用户名、密码、权限校验、线程处理等需要缓存的需求缓存下来，下次可以直接用已经建立好的连接，提升服务器性能。</p></blockquote><p><strong>2. SQL层</strong></p><p>SQL 层是 MySQL 的核心，MySQL 的核心服务都是在这层实现的。主要包含<strong>权限判断、查询缓存、解析器、预处理、查询优化器、缓存和执行计划。</strong></p><ul><li><strong>权限判断</strong>可以审核用户有没有访问某个库、某个表，或者表里某行数据的权限。</li><li><strong>查询缓存</strong>通过 Query Cache 进行操作，如果数据在 Query Cache 中，则直接返回结果给客户端，不必再进行查询解析、优化和执行等过程。</li><li><strong>查询解析器</strong>针对 SQL 语句进行解析，判断语法是否正确。</li><li><strong>预处理器</strong>对解析器无法解析的语义进行处理。</li><li><strong>查询优化器</strong>对 SQL 进行改写和相应的优化，并生成最优的执行计划，就可以调用程序的 API 接口，通过存储引擎层访问数据。</li></ul><p><strong>SQL层具体内容如下：</strong></p><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Management Services &amp; Utilities</td><td align="center">MySQL 的系统管理和控制工具，包括备份恢复、MySQL 复制、集群等。</td></tr><tr><td align="center">SQL Interface</td><td align="center">用来接收用户的 SQL 命令，返回用户需要查询的结果。例如 SELECT FROM 就是调用 SQL Interface。</td></tr><tr><td align="center">Parser（查询解析器）</td><td align="center">在 SQL 命令传递到解析器的时候会被解析器验证和解析，以便 MySQL 优化器可以识别的数据结构或返回 SQL 语句的错误。</td></tr><tr><td align="center">Optimizer（查询优化器）</td><td align="center">SQL 语句在查询之前会使用查询优化器对查询进行优化，同时验证用户是否有权限进行查询，缓存中是否有可用的最新数据。它使用“选取-投影-连接”策略进行查询。  例如 <code>SELECT id, name FROM student WHERE gender = &quot;女&quot;;</code>语句中，SELECT 查询先根据 WHERE 语句进行选取，而不是将表全部查询出来以后再进行 gender 过滤。SELECT 查询先根据 id 和 name 进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</td></tr><tr><td align="center">Caches &amp; Buffers</td><td align="center">如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的，比如表缓存、记录缓存、key 缓存、权限缓存等。</td></tr></tbody></table><h4 id="三、存储引擎层"><a href="#三、存储引擎层" class="headerlink" title="三、存储引擎层"></a>三、存储引擎层</h4><p>即上图的<strong>Pluggable Storage Engines</strong></p><p>本层主要负责数据的<strong>存储和读取</strong></p><h4 id="四、文件系统层"><a href="#四、文件系统层" class="headerlink" title="四、文件系统层"></a>四、文件系统层</h4><p>功能：</p><ul><li><p>将数据存储到操作系统的文件系统内</p></li><li><p>并负责完成与存储引擎的交互</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目介绍</title>
      <link href="2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h4><h6 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h6><p>本项目旨在搭建一个交流平台，主要目标是爱好写作、分享博客的各位小伙伴们</p><p>用户可以在其中浏览文章，发布文章、发表评论等。</p><p>当遇到美文时，可以点赞，或关注作者，以及时获取其最新推送</p><h6 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2. 需求分析"></a>2. 需求分析</h6><p>用户：发布文章，修改文章，删除文章，点赞，发布评论，关注作者</p><p>系统：推送消息给用户</p><h6 id="3-模块划分"><a href="#3-模块划分" class="headerlink" title="3. 模块划分"></a>3. 模块划分</h6><p>按功能来划分，可以分成以下模块</p><ul><li>文章模块</li></ul><p>对文章进行操作，包括发布、修改、删除、点赞等</p><ul><li>评论模块</li></ul><p>用户在某一篇文章下发表评论、删除评论</p><ul><li>用户模块</li></ul><p>用户登录、注册</p><ul><li>消息模块</li></ul><p>消息推送，包括文章被读者点赞，或者是关注的作者发表了新文章</p><h6 id="4-架构及技术选型"><a href="#4-架构及技术选型" class="headerlink" title="4. 架构及技术选型"></a>4. 架构及技术选型</h6><ul><li><h6 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h6></li></ul><p>采用前后端分离的开发方式</p><ul><li>后端架构</li></ul><p>采用当前主流的基于 Spring Cloud 的微服务架构</p><p>用到的技术有：Spring Boot、Spring Cloud、MyBatis Plus、MySQL</p><p>用到的组件有：</p><table><thead><tr><th align="center">组件</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Eureka</td><td align="center">用来注册服务</td></tr><tr><td align="center">Maven</td><td align="center">管理依赖</td></tr><tr><td align="center">Feign</td><td align="center">服务间调用</td></tr><tr><td align="center">Redis</td><td align="center">缓存用户间的订阅和点赞关系</td></tr><tr><td align="center">netty</td><td align="center">异步通信，配合消息队列完成消息推送</td></tr><tr><td align="center">RabbitMQ</td><td align="center">存放通知消息</td></tr><tr><td align="center">MongoDB</td><td align="center">持久化存储评论数据（不太重要的数据）</td></tr><tr><td align="center">docker</td><td align="center">部署虚拟化容器</td></tr></tbody></table><h6 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h6><p>模块划分后，又添加了common模块和encrypt模块</p><p> <code>common</code> 用来部署一些公共部分，如状态码StatusCode，返回结果Result，分页查询结果PageResult、ID生成器IdWorker</p><p> <code>encrypt</code> 用来进行接口加密，前端用公钥对数据进行加密，后端用私钥进行解密</p><h4 id="二、难点总结"><a href="#二、难点总结" class="headerlink" title="二、难点总结"></a>二、难点总结</h4><h5 id="1-分页查询"><a href="#1-分页查询" class="headerlink" title="1. 分页查询"></a>1. 分页查询</h5><p>controller层</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;search/&#123;page&#125;/&#123;size&#125;&quot;, method = RequestMethod.POST)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">findByPage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer page,</span></span><br><span class="hljs-function"><span class="hljs-params">                         <span class="hljs-meta">@PathVariable</span> Integer size,</span></span><br><span class="hljs-function"><span class="hljs-params">                         <span class="hljs-meta">@RequestBody</span> Map&lt;String,Object&gt; map)</span> </span>&#123;      <span class="hljs-comment">// json数据转成map而不是对象，方便遍历属性</span><br>    Page&lt;Article&gt; pageData = articleService.search(map, page, size); <span class="hljs-comment">// 调用service层的方法</span><br>    PageResult&lt;Article&gt; pageResult = <span class="hljs-keyword">new</span> PageResult&lt;&gt;(               <span class="hljs-comment">// 封装成自己定义的结果类</span><br>            pageData.getTotal(), pageData.getRecords()<br>    );<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, StatusCode.OK, <span class="hljs-string">&quot;查询成功&quot;</span>, pageResult);<br>&#125;<br></code></pre></td></tr></table></figure><p>service层</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Page&lt;Article&gt; <span class="hljs-title">search</span><span class="hljs-params">(Map&lt;String, Object&gt; map, Integer page, Integer size)</span> </span>&#123;<br>    EntityWrapper&lt;Article&gt; wrapper = <span class="hljs-keyword">new</span> EntityWrapper&lt;Article&gt;();<br>    <span class="hljs-keyword">for</span> (String field : map.keySet()) &#123;<br>        wrapper.eq(<span class="hljs-keyword">null</span> != map.get(field), field, map.get(field));<span class="hljs-comment">// 不考虑字段值为空</span><br>    &#125;<br>    Page&lt;Article&gt; pageData = <span class="hljs-keyword">new</span> Page&lt;&gt;(page, size);<br>    List list = articleDao.selectPage(pageData, wrapper); <span class="hljs-comment">// 传入分页参数（Page）、查询条件（EntityWrapper）</span><br>    pageData.setRecords(list);                            <span class="hljs-comment">// 目的是找到和 map 中非空的键值对相匹配的数据</span><br>    <span class="hljs-keyword">return</span> pageData;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-使用redis"><a href="#2-使用redis" class="headerlink" title="2. 使用redis"></a>2. 使用redis</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String userKey = <span class="hljs-string">&quot;article_subscribe_&quot;</span> + userId;  <span class="hljs-comment">// 作者集合</span><br>String authorKey = <span class="hljs-string">&quot;article_author_&quot;</span> + authorId; <span class="hljs-comment">// 读者集合</span><br>Boolean flag = redisTemplate.boundSetOps(userKey).isMember(authorId);<span class="hljs-comment">// 查询该用户是否已经订阅作者</span><br><br><span class="hljs-keyword">if</span> (flag) &#123;<br>    <span class="hljs-comment">// 取消订阅</span><br>    redisTemplate.boundSetOps(userKey).remove(authorId); <span class="hljs-comment">// redis 删除指定集合的某条数据</span><br>    redisTemplate.boundSetOps(authorKey).remove(userId);<br>    <span class="hljs-comment">// 删除绑定关系</span><br>    rabbitAdmin.removeBinding(binding);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 进行订阅</span><br>    redisTemplate.boundSetOps(userKey).add(authorId);    <span class="hljs-comment">// redis 往指定集合添加一条数据</span><br>    redisTemplate.boundSetOps(authorKey).add(userId);<br>    <span class="hljs-comment">// 声明队列、添加绑定关系</span><br>    rabbitAdmin.declareQueue(queue);<br>    rabbitAdmin.declareBinding(binding);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-rabbitMQ使用"><a href="#3-rabbitMQ使用" class="headerlink" title="3.rabbitMQ使用"></a>3.rabbitMQ使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 创建管理器</span><br>RabbitAdmin rabbitAdmin = <span class="hljs-keyword">new</span> RabbitAdmin(rabbitTemplate.getConnectionFactory());<br><span class="hljs-comment">// 声明交换机，路由键为article_subscribe，消息通过交换机来发送</span><br>DirectExchange exchange = <span class="hljs-keyword">new</span> DirectExchange(<span class="hljs-string">&quot;article_subscribe&quot;</span>);<br>rabbitAdmin.declareExchange(exchange);<br><span class="hljs-comment">// 创建消息队列</span><br>Queue queue = <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;article_subscribe_&quot;</span> +  userId, <span class="hljs-keyword">true</span>);<br><span class="hljs-comment">// 绑定交换机与队列</span><br>Binding binding = BindingBuilder.bind(queue).to(exchange).with(authorId);<br><br><span class="hljs-keyword">boolean</span> flag; <span class="hljs-comment">// 获取是否订阅的关系</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br>    <span class="hljs-comment">//如果已经订阅，就取消绑定队列与交换机的绑定关系</span><br>rabbitAdmin.removeBinding(binding);    <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>rabbitAdmin.declareQueue(queue);<br>    rabbitAdmin.declareBinding(binding);<br>&#125;<br><span class="hljs-comment">//...关注作者发布文章后，生成消息推送</span><br>rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;article_subscribe&quot;</span>, userId, id);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tensquare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机使用</title>
      <link href="2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8/"/>
      <url>2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="一、记录"><a href="#一、记录" class="headerlink" title="一、记录"></a>一、记录</h4><p>账号：root</p><p>密码：itcast</p><h4 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h4><h5 id="1-启动docker"><a href="#1-启动docker" class="headerlink" title="1. 启动docker"></a>1. 启动docker</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemctl status docker<br></code></pre></td></tr></table></figure><h5 id="2-docker命令"><a href="#2-docker命令" class="headerlink" title="2. docker命令"></a>2. docker命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>查看docker可以使用的命令</p><p>例如 <code>docker images </code> 可以查看本地使用的镜像</p><h5 id="3-首次创建并启动MySQL容器"><a href="#3-首次创建并启动MySQL容器" class="headerlink" title="3. 首次创建并启动MySQL容器"></a>3. 首次创建并启动MySQL容器</h5><p>创建并启动一个名叫 <code>tensquare_mysql</code> 的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -id --name=tensquare_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7<br></code></pre></td></tr></table></figure><h5 id="4-关闭容器"><a href="#4-关闭容器" class="headerlink" title="4. 关闭容器"></a>4. 关闭容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker stop tensquare_mysql<br></code></pre></td></tr></table></figure><h5 id="5-再次启动容器"><a href="#5-再次启动容器" class="headerlink" title="5. 再次启动容器"></a>5. 再次启动容器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs linux">docker start tensquare_mysql<br></code></pre></td></tr></table></figure><h5 id="6-连接MongoDB"><a href="#6-连接MongoDB" class="headerlink" title="6. 连接MongoDB"></a>6. 连接MongoDB</h5><ul><li><p>win10进入 <code>C:\Program Files\MongoDB\Server\3.2\bin</code> 路径</p></li><li><p>打开cmd（shift + 鼠标右键打开<strong>Powershell</strong>，然后输入<code>start cmd</code>命令）</p></li><li><p>然后输入 <code>mongo 192.168.13.128</code> 连接</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> tensquare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/RabbitMQ/"/>
      <url>2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h4 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-添加配置"><a href="#2-添加配置" class="headerlink" title="2. 添加配置"></a>2. 添加配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 要添加在spring字段内</span><br><span class="hljs-attr">rabbitmq:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.13</span><span class="hljs-number">.128</span> <br></code></pre></td></tr></table></figure><h4 id="3-具体使用"><a href="#3-具体使用" class="headerlink" title="3. 具体使用"></a>3. 具体使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建管理器</span><br>RabbitAdmin rabbitAdmin = <span class="hljs-keyword">new</span> RabbitAdmin(rabbitTemplate.getConnectionFactory());<br><span class="hljs-comment">// 声明交换机</span><br>DirectExchange exchange = <span class="hljs-keyword">new</span> DirectExchange(<span class="hljs-string">&quot;article_subscribe&quot;</span>);<br>rabbitAdmin.declareExchange(exchange);<br><span class="hljs-comment">// 创建消息队列</span><br>Queue queue = <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;article_subscribe&quot;</span> +  userId, <span class="hljs-keyword">true</span>);<br><span class="hljs-comment">// 绑定交换机与队列</span><br>Binding binding = BindingBuilder.bind(queue).to(exchange).with(authorId);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tensquare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus使用</title>
      <link href="2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/Mybatis%20Plus/"/>
      <url>2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/Mybatis%20Plus/</url>
      
        <content type="html"><![CDATA[<h5 id="1-在-pom-xml-中添加依赖"><a href="#1-在-pom-xml-中添加依赖" class="headerlink" title="1. 在 pom.xml 中添加依赖"></a>1. 在 <code>pom.xml</code> 中添加依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatisplus-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatisplus-spring-boot-starter.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mybatisplus.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-在-application-yml-文件中添加配置"><a href="#2-在-application-yml-文件中添加配置" class="headerlink" title="2. 在 application.yml 文件中添加配置"></a>2. 在 <code>application.yml</code> 文件中添加配置</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">typeAliasesPackage:</span> <span class="hljs-string">com.tensquare.article.pojo</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">id-type:</span> <span class="hljs-number">1</span>  <br>    <span class="hljs-attr">db-column-underline:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">refresh-mapper:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">configuration:</span><br>      <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">cache-enabled:</span> <span class="hljs-literal">true</span> <br>      <span class="hljs-attr">lazyLoadingEnabled:</span> <span class="hljs-literal">true</span> <br>      <span class="hljs-attr">multipleResultSetsEnabled:</span> <span class="hljs-literal">true</span> <br>      <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><p>说明</p><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">typeAliasesPackage</td><td align="center">实体类所在包，多个package用逗号或者分号分隔</td></tr><tr><td align="center">id-type</td><td align="center">0表示数据库的自增ID，1表示用户输入ID</td></tr><tr><td align="center">cache-enabled</td><td align="center">缓存是否开启</td></tr><tr><td align="center">lazyLoadingEnabled</td><td align="center">懒加载是否开启</td></tr><tr><td align="center">multipleResultSetsEnabled</td><td align="center">延时加载是否开启</td></tr><tr><td align="center">log-impl</td><td align="center">打印SQL语句，用做调试</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> tensquare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB使用</title>
      <link href="2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/MongoDB/"/>
      <url>2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/MongoDB/</url>
      
        <content type="html"><![CDATA[<h5 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h5><p>在 <code>pom.xml</code> 中添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 <code>application.yml</code> 文件中添加配置（spring内）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">data:</span><br>    <span class="hljs-attr">mongodb:</span><br>      <span class="hljs-attr">database:</span> <span class="hljs-string">commentdb</span><br>      <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.13</span><span class="hljs-number">.128</span><br></code></pre></td></tr></table></figure><h5 id="2-什么是MongoDB"><a href="#2-什么是MongoDB" class="headerlink" title="2. 什么是MongoDB"></a>2. 什么是MongoDB</h5><p><strong>MongoDB</strong>是一个基于分布式文件存储的数据库，是一个介于<strong>关系型数据库</strong>和<strong>非关系型数据库</strong>之间的产品。</p><p>它支持的数据结构非常松散，是类似于JSON格式的BSON。</p><p>它是由<strong>C++编写</strong>的</p><h5 id="2-MongoDB的体系结构"><a href="#2-MongoDB的体系结构" class="headerlink" title="2. MongoDB的体系结构"></a>2. MongoDB的体系结构</h5><p>主要由<strong>文档、集合、数据库</strong>三部分组成</p><table><thead><tr><th align="center">MongoDB</th><th align="center">关系型数据库Mysql</th></tr></thead><tbody><tr><td align="center">数据库(databases)</td><td align="center">数据库(databases)</td></tr><tr><td align="center">集合(collections)</td><td align="center">表(table)</td></tr><tr><td align="center">文档(document)</td><td align="center">行(row)</td></tr></tbody></table><p>MongoDB的一个<strong>集合</strong>中存储了多条<strong>文档</strong>，文档是由多个<strong>key-value</strong>构成的</p><p>每条文档默认有个id</p>]]></content>
      
      
      <categories>
          
          <category> tensquare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目上传至GitHub</title>
      <link href="2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/Github%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/"/>
      <url>2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/Github%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="上传项目"><a href="#上传项目" class="headerlink" title="上传项目"></a>上传项目</h1><h2 id="1-先在github上新建一个仓库，记住HTTPS地址"><a href="#1-先在github上新建一个仓库，记住HTTPS地址" class="headerlink" title="1. 先在github上新建一个仓库，记住HTTPS地址"></a>1. 先在github上新建一个仓库，记住HTTPS地址</h2><h2 id="2-打开git-bash，进入到项目目录中"><a href="#2-打开git-bash，进入到项目目录中" class="headerlink" title="2. 打开git bash，进入到项目目录中"></a>2. 打开git bash，进入到项目目录中</h2><p>如果用的是<code>idea</code>之类的开发工具的话，可以在那里面打开<code>terminal</code>终端（默认会来到项目路径下）</p><p>就不用自己手动<code>cd</code>了</p><h2 id="3-依次键入以下命令"><a href="#3-依次键入以下命令" class="headerlink" title="3. 依次键入以下命令"></a>3. 依次键入以下命令</h2><p>第一次操作时：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git init<br><br>git add .<br><br>git commit -m <span class="hljs-string">&quot;first try&quot;</span><br><br>git remote add origin https://githun.com/ + ...  <span class="hljs-comment"># 这里是仓库地址</span><br><br>git push -u origin master<br></code></pre></td></tr></table></figure><h2 id="4-之后更新项目"><a href="#4-之后更新项目" class="headerlink" title="4. 之后更新项目"></a>4. 之后更新项目</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">// 添加所有文件<br>git add .<br><br>// 提交并说明<br>git commit -m <span class="hljs-string">&quot;second try&quot;</span><br><br>// push到远程仓库<br>git push<br></code></pre></td></tr></table></figure><h2 id="5-遇到问题"><a href="#5-遇到问题" class="headerlink" title="5.遇到问题"></a>5.遇到问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">OpenSSL SSL_read: Connection was reset, errno 10054<br></code></pre></td></tr></table></figure><p>使用<code>git config --global http.sslVerify &quot;false&quot;</code>命令解决</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Failed to connect to github.com port 443: Timed out<br></code></pre></td></tr></table></figure><p>检查代理是否关闭（要关闭）</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Feign使用</title>
      <link href="2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/Feign/"/>
      <url>2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/Feign/</url>
      
        <content type="html"><![CDATA[<h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>功能：用来调用<strong>其他微服务</strong>所提供的接口</p><h5 id="1-在本服务的pom-xml中添加Feign依赖，并在启动类上添加注解"><a href="#1-在本服务的pom-xml中添加Feign依赖，并在启动类上添加注解" class="headerlink" title="1. 在本服务的pom.xml中添加Feign依赖，并在启动类上添加注解"></a>1. 在本服务的<code>pom.xml</code>中添加Feign依赖，并在启动类上添加注解</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoticeApplication</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h5 id="2-在client包下创建其他微服务接口类"><a href="#2-在client包下创建其他微服务接口类" class="headerlink" title="2. 在client包下创建其他微服务接口类"></a>2. 在<code>client</code>包下创建其他微服务接口类</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;tensquare-article&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArticleClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;article/&#123;id&#125;&quot;, method = RequestMethod.GET)</span><br>    <span class="hljs-function">Result <span class="hljs-title">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口中声明要使用的方法（必须是其他微服务实现好的）</p><h5 id="3-注入Bean以调用接口"><a href="#3-注入Bean以调用接口" class="headerlink" title="3. 注入Bean以调用接口"></a>3. 注入Bean以调用接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserClient userClient;<br><span class="hljs-comment">// ...userClient.findById(&quot;123&quot;);</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tensquare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eureka使用</title>
      <link href="2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/Eureka/"/>
      <url>2021/05/01/SpringCloud%E9%A1%B9%E7%9B%AE/Eureka/</url>
      
        <content type="html"><![CDATA[<p>功能：统一管理模块</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="1-在父工程的pom-xml文件下添加依赖"><a href="#1-在父工程的pom-xml文件下添加依赖" class="headerlink" title="1. 在父工程的pom.xml文件下添加依赖"></a>1. 在父工程的<code>pom.xml</code>文件下添加依赖</h4><p>另起一块</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Greenwich.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h4 id="2-创建Eureka的微服务模块"><a href="#2-创建Eureka的微服务模块" class="headerlink" title="2. 创建Eureka的微服务模块"></a>2. 创建Eureka的微服务模块</h4><p>右键 - &gt; new module - &gt; 选择maven工程进行创建</p><p>然后在Eureka模块中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在resource目录下添加<code>application.yml</code>文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">6868</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否将自己注册到eureka中</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#是否从eureka中获取信息</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure><p>编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-将其他模块注册到Eureka中"><a href="#3-将其他模块注册到Eureka中" class="headerlink" title="3. 将其他模块注册到Eureka中"></a>3. 将其他模块注册到Eureka中</h4><p>在pom.xml中添加Eureka依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改配置文件，使用Eureka</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:6868/eureka/</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>然后在启动类中添加注解：@EnableEurekaClient</p><hr>]]></content>
      
      
      <categories>
          
          <category> tensquare </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序数组</title>
      <link href="2021/04/30/leetcode/13_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>2021/04/30/leetcode/13_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定两个<code>有序数组</code>nums1和nums2，把两个数组合并成nums1数组。</p><p>假定nums1数组容量够大</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从nums1数组的最后开始填充，并用双指针来标记取元素的位置。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 从有序数组末尾开始向前遍历</span><br>        <span class="hljs-keyword">int</span> p = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> q = n - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> end = m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (q != -<span class="hljs-number">1</span>  &amp;&amp; p != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums1[p] &lt; nums2[q]) &#123;<br>                nums1[end] = nums2[q];<br>                q --;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums1[end] = nums1[p];<br>                p --;<br>            &#125;<br>            end --;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (p != -<span class="hljs-number">1</span>) &#123;<br>            nums1[end] = nums1[p];<br>            end --;<br>            p --;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (q != -<span class="hljs-number">1</span>) &#123;<br>            nums1[end] = nums2[q];<br>            end --;<br>            q --;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网——链路层</title>
      <link href="2021/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>2021/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>结点：主机、路由器</p><p>链路：两个结点之间的物理通道</p><p>数据链路：逻辑通道，链路加上硬件软件</p><p>帧：链路层的协议数据单元，封装了网络层数据包</p><h2 id="一、封装成帧"><a href="#一、封装成帧" class="headerlink" title="一、封装成帧"></a>一、封装成帧</h2><h3 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h3><blockquote><p>在一段数据的前后添加首部和尾部，形成帧</p><p>接收方收到物理层的比特流后，可以根据首部尾部的标记，识别出帧的开始和结束位置</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/12844.png" alt="12844"></p><h3 id="2-区分帧的几种方法"><a href="#2-区分帧的几种方法" class="headerlink" title="2. 区分帧的几种方法"></a>2. 区分帧的几种方法</h3><ul><li><p><strong>字符计数法</strong></p><p>帧首部用第一个字节表示这个帧的长度</p><p>发生错误后影响之后所有的帧</p></li><li><p><strong>字符填充法</strong></p><p>特定的首部尾部来作为界限，中间如果遇到同名的，填充字节来转义</p></li><li><p><strong>零比特填充法</strong></p><p>发送方根据规则填充0，然后接收方去掉首部尾部后，对数据按规则删除0</p></li><li><p><strong>违规编码法</strong></p><p>用独特的电压来表示首部尾部</p></li></ul><h2 id="二、差错检验"><a href="#二、差错检验" class="headerlink" title="二、差错检验"></a>二、差错检验</h2><h3 id="1-错误有哪些？"><a href="#1-错误有哪些？" class="headerlink" title="1. 错误有哪些？"></a>1. 错误有哪些？</h3><ul><li>位错，比特位发生变动</li><li>帧错，帧丢失、重复、乱序等</li></ul><p>错误来源于外界的冲击噪声或者随机噪声（热噪声）。</p><h3 id="2-差错控制方法"><a href="#2-差错控制方法" class="headerlink" title="2. 差错控制方法"></a>2. 差错控制方法</h3><p>这里主要针对比特错，即位错。</p><p>相应的解决方法有两类，<strong>检错编码</strong>和<strong>纠错编码</strong>，顾名思义，一个是检查错误，一个是纠正错误。</p><h3 id="3-检错编码"><a href="#3-检错编码" class="headerlink" title="3. 检错编码"></a>3. 检错编码</h3><p>这里都用到了<code>冗余编码</code>的思想，即发送时在数据前面加上一段比特，接收方根据它来判断数据是否变化</p><p><strong>『奇偶校验码』</strong></p><p>冗余码：只使用1位，取0或1</p><p>冗余码取值：满足<code>数据+冗余码</code>中<code>1</code>的个数是奇数还是偶数（奇校验还是偶校验）</p><p>思想：约定奇或偶校验，然后发生方设置冗余码并满足校验，接收方收到后判断1的个数是否和约定的校验方式相符。</p><p>例如，现有数据编码<code>1100101</code>，采用偶校验的话，要保证添加冗余码后有偶数个1，所以冗余码选择0就可以，编码后为<code>01100101</code></p><p><strong>特点：只能检测出奇数位发生错误的情况</strong></p><p><strong>『循环冗余码CRC』</strong></p><p>冗余码：有多位，根据计算得到。</p><p>思想：</p><ol><li>约定一个多项式</li><li>数据比特在末尾添<code>阶数</code>个0</li><li>添零后的数据与多项式进行模2除法，得到冗余码并填充在末尾的0中</li><li>接收方让数据除以约定的多项式，除尽了说明没错</li></ol><p>图片描述</p><p>发送方计算冗余码</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/Snipaste_2021-04-29_22-11-00.png" alt="Snipaste_2021-04-29_22-11-00"></p><p>接收方校验</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/20210429230102.png"></p><h3 id="4-纠错编码"><a href="#4-纠错编码" class="headerlink" title="4. 纠错编码"></a>4. 纠错编码</h3><p>纠错编码介绍一个叫做<code>海明码</code>的方法。</p><blockquote><p>海明码是广泛用于内存和磁盘纠错的编码。</p></blockquote><ol><li><p><strong>首先先要知道冗余码的位数</strong></p><p>通过<code>海明不等式</code>来确定</p><p>根据  $n + r \leq\ 2^r - 1$计算得到，其中n表示数据位数，r表示冗余码位数。</p></li><li><p><strong>确定校验码和数据的位置</strong></p><p>把校验码依次放在$2^i$的位置，然后数据依次填充。</p></li><li><p><strong>计算冗余码的值</strong></p><p>需要分组，按<code>XXX1</code>、<code>XX1X</code>、<code>X1XX</code>、<code>1XXX</code>来分组</p><p>然后冗余位的取值要满足该组的1的个数为偶数</p><p>PS：冗余位取值，可以用<code>异或后结果为0</code>来计算</p></li><li><p><strong>接收方判断</strong></p><p>收到数据后，进行分组并重新计算每组的异或值</p><p>将值<code>倒序</code>排列，得到的十进制即出错的位置。</p></li></ol><h2 id="三、流量控制"><a href="#三、流量控制" class="headerlink" title="三、流量控制"></a>三、流量控制</h2><blockquote><p>思想：当发送方发送的帧太多，以致接收方来不及处理的时候，接收方就不进行回复确认，来达到<strong>控制发送方速率</strong>的目的</p></blockquote><h3 id="流量控制的方法"><a href="#流量控制的方法" class="headerlink" title="流量控制的方法"></a>流量控制的方法</h3><p>主要思想是<code>滑动窗口</code>，发送方维持一个<code>固定</code>的窗口，发送帧之后，接收方回复确认，发送方收到确认消息后，更新窗口中的帧。</p><p>与流量控制相关的协助主要有3种，分别是<strong>停止-等待协议</strong>、<strong>后退N帧协议</strong>和<strong>选择重传协议</strong>。</p><p>下面就依次介绍一下。</p><h3 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h3><p>在<code>停止-等待协议</code>中，发送方发送一个帧，就会停下来等待确认消息，收到确认后再发送下一个帧。</p><p>如果在超时时间内没有收到确认消息，就进行重传。</p><p>懂得都懂，这样做发送方大部分时间都在等待，信道利用率比较低！</p><h4 id="优化思想"><a href="#优化思想" class="headerlink" title="优化思想"></a>优化思想</h4><blockquote><p>思考：为什么要一帧一帧地发送？可以发送多个帧吗？多个帧发送，又会涉及到顺序的问题</p></blockquote><p>针对以上思考，我们提出两种优化思路：</p><ol><li>为帧添加序号</li><li>多个帧一起发送</li></ol><p>后面介绍的两种协议就采用了这些思路。</p><h3 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h3><p><strong>主要思想：发送方维持一个大于1的滑动窗口，每收到一个ACK，移动窗口；接收方维持大小为1的窗口，逐个接收</strong></p><p><strong>特点：</strong></p><ul><li><p>累计确认</p><p>一旦确认某个帧被接收，那么该帧的前面所有帧也都是确定被接收方收到的</p></li><li><p>超时重传机制</p><p>超时时发送方发送所有未确认的帧</p></li></ul><p><strong>例子：</strong>假设有编号为0~7的帧，现在发送方收到了0，2，3帧的ACK，如果这时产生了超时，要重新发送些帧</p><p><strong>答案：</strong> <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">4，5，6，7</span></span></p><p><strong>缺点：</strong>重传时，要把未确认的帧全都重新传一遍，没有必要</p><p>下一个协议就避免了这一缺点。</p><h3 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h3><p><strong>主要思想：发送方维持一个大于1的滑动窗口，每收到一个ACK，移动窗口；接收方维持同样大小的窗口，缓存接收</strong></p><p>注意，因为SR协议接收方窗口大小不为1，所以遇到不连续的数据，它是可以先缓存接收的；等到前面的数据也收到后，就形成连续的帧号，窗口就可以移动了。这和GBN只能接收当前一个帧，不连续就丢弃的情况不同。</p><h2 id="四、其他协议"><a href="#四、其他协议" class="headerlink" title="四、其他协议"></a>四、其他协议</h2><h3 id="1-ALOHA"><a href="#1-ALOHA" class="headerlink" title="1.ALOHA"></a>1.ALOHA</h3><p>想发数据就发</p><h3 id="2-CSMA"><a href="#2-CSMA" class="headerlink" title="2.CSMA"></a>2.CSMA</h3><p>先监听信道，看看拥不拥挤再发</p><h3 id="3-CSMA-CD"><a href="#3-CSMA-CD" class="headerlink" title="3.CSMA/CD"></a>3.CSMA/CD</h3><p>一边监听一边发，如果拥挤了就停下来</p><h3 id="4-CSMA-CA"><a href="#4-CSMA-CA" class="headerlink" title="4.CSMA/CA"></a>4.CSMA/CA</h3><p>先听后发，适用于传输介质为无线局域网的，所以更常用。</p><h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><p>覆盖范围从几十公里到几千公里的网络，它是通过<code>交换机</code>来交换分组的。</p><p>顺便一提，路由器是网络层的设备，也是用来进行分组交换的，两者的区别在于交换机只能在单个网络中转发分组，而路由器能在多个网络中转发分组。</p><h3 id="5-PPP协议（点对点协议）"><a href="#5-PPP协议（点对点协议）" class="headerlink" title="5.PPP协议（点对点协议）"></a>5.PPP协议（点对点协议）</h3><p>面向字节</p><p>用户使用拨号电路接入因特网时，一般使用PPP协议。</p><h3 id="6-HDLC协议"><a href="#6-HDLC协议" class="headerlink" title="6.HDLC协议"></a>6.HDLC协议</h3><p>在同步网上传输数据，面向比特的数据链路层协议</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计网——物理层</title>
      <link href="2021/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>2021/04/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91%E4%B9%8B%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="一、通信方式"><a href="#一、通信方式" class="headerlink" title="一、通信方式"></a>一、通信方式</h3><h4 id="1-单工通信"><a href="#1-单工通信" class="headerlink" title="1. 单工通信"></a>1. 单工通信</h4><p>只能从一个方向通信，并且不会有反方向的交互</p><p>只需要一条信道</p><h4 id="2-半双工通信"><a href="#2-半双工通信" class="headerlink" title="2. 半双工通信"></a>2. 半双工通信</h4><p>通信双方都可以发送或接收消息，但是一时间内只能有一个在发送，另一个在接收；任何一方都不能同时进行发送和接收。</p><p>所以需要两条信道。</p><h4 id="3-全双工通信"><a href="#3-全双工通信" class="headerlink" title="3. 全双工通信"></a>3. 全双工通信</h4><p>通信双方都可以同时发送或接受消息</p><p>需要两条信道。</p><h3 id="二、数据传输方式"><a href="#二、数据传输方式" class="headerlink" title="二、数据传输方式"></a>二、数据传输方式</h3><p>串行传输：直接传输一串比特</p><p>并行传输：把一串比特分成多份，同时传输</p><p>区别：可从<strong>成本</strong>、<strong>适用距离</strong>、<strong>速度</strong>等方面考虑</p><h3 id="三、编码与调制"><a href="#三、编码与调制" class="headerlink" title="三、编码与调制"></a>三、编码与调制</h3><p><strong>信道：</strong>信号的传输媒介</p><p>信道按传输信号不同，可分为<strong>模拟信道</strong>和<strong>数字信道</strong>，它们分别传输模拟信号（连续的）和数字信号（离散的，即0，1）</p><p><strong>编码：</strong>数字数据转变成数字信号的过程</p><p><strong>调制：</strong>数据通过调制器变为模拟信号</p><h3 id="四、传输介质"><a href="#四、传输介质" class="headerlink" title="四、传输介质"></a>四、传输介质</h3><h4 id="1-导向性传输介质"><a href="#1-导向性传输介质" class="headerlink" title="1. 导向性传输介质"></a>1. 导向性传输介质</h4><ol><li>双绞线</li><li>同轴电缆</li><li>光纤<ol><li>多模光纤</li><li>单模光纤</li></ol></li></ol><h4 id="2-非导向型传输介质"><a href="#2-非导向型传输介质" class="headerlink" title="2. 非导向型传输介质"></a>2. 非导向型传输介质</h4><ol><li>无线电波</li><li>微波</li><li>红外线、激光</li></ol><h3 id="五、物理层设备"><a href="#五、物理层设备" class="headerlink" title="五、物理层设备"></a>五、物理层设备</h3><h4 id="1-中继器"><a href="#1-中继器" class="headerlink" title="1. 中继器"></a>1. 中继器</h4><p>再生和还原信号</p><h4 id="2-集线器"><a href="#2-集线器" class="headerlink" title="2. 集线器"></a>2. 集线器</h4><p>对信号进行再生放大转发</p><hr><p>电话通信的例子：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/Snipaste_2021-04-29_20-23-34.png" alt="Snipaste_2021-04-29_20-23-34"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类加载过程</title>
      <link href="2021/04/29/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>2021/04/29/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、类加载过程"><a href="#一、类加载过程" class="headerlink" title="一、类加载过程"></a>一、类加载过程</h2><p>要把一个类的Class文件加载到Java虚拟机中，大致分为三个步骤：<strong>加载、连接和初始化</strong></p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>把字节流中的静态数据结构，加载到JVM中，形成运行时的数据结构</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接又可以细分成：验证、准备和解析。</p><h4 id="1-验证"><a href="#1-验证" class="headerlink" title="1.验证"></a>1.验证</h4><p>即验证Class文件是否符合规范，同时对语义进行确认</p><h4 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h4><p>为类级变量分配内存空间，并设置初始值。</p><p>PS：实例变量并不分配，因为它是和对象实例绑定在一起的，要在实例化对象的时候才会进行内存分配。</p><h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3.解析"></a>3.解析</h4><p>把常量池中符号引用解析成指针或者偏移量。</p><p>PS：不然光靠一个名称去找它，多累啊；还是知道准确地址好点。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>遇到四个关键字时，对类进行初始化操作。</p><h2 id="二、加载机制"><a href="#二、加载机制" class="headerlink" title="二、加载机制"></a>二、加载机制</h2><p>类的加载是通过<strong>加载器</strong>来完成的，具体的加载机制是<strong>双亲委派机制</strong></p><h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><p>Java自带的有3种，<strong>引导类加载器、扩展类加载器</strong>和<strong>应用程序类加载器</strong></p><p>这三者的关系是祖孙三代的关系，来张图表示下吧</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/classloader.png" alt="classloader_WPS图片" style="zoom:67%;" /><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>双亲委派机制，就是指要加载某个类时，向上传递请求，一直到启动类加载器</p><p>然后依次判断能不能加载，不能的话再往下传。</p><h3 id="为什么要这样做呢？"><a href="#为什么要这样做呢？" class="headerlink" title="为什么要这样做呢？"></a>为什么要这样做呢？</h3>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP连接</title>
      <link href="2021/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E8%BF%9E%E6%8E%A5/"/>
      <url>2021/04/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h1><h2 id="一、三次握手"><a href="#一、三次握手" class="headerlink" title="一、三次握手"></a>一、三次握手</h2><blockquote><p>三次握手的目的在于交换初始序列号，从而建立通信双方可靠稳定的连接。</p></blockquote><h3 id="1-符号说明"><a href="#1-符号说明" class="headerlink" title="1.符号说明"></a>1.符号说明</h3><p>介绍下3种标志</p><ul><li>ACK：确认标志，请求连接时为0，连接建立后所有发送的报文的ACK必须为1</li><li>SYN：同步序列号，只在三次握手建立连接时有效</li><li>ISN ：初始序列号，由生成器生成一个32位的ISN，生成器用32位长的时钟，每隔一段时间增长一次，大约<strong>5小时</strong>会重新循环。而数据包的默认最大寿命<strong>MSL</strong>为<strong>2分钟</strong>，所以可以认为初始序列号是唯一的</li></ul><h3 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2.建立连接"></a>2.建立连接</h3><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/tcp_1.png" alt="tcp_1" style="zoom: 80%;" /><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收机制</title>
      <link href="2021/04/27/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>2021/04/27/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><h2 id="一、垃圾"><a href="#一、垃圾" class="headerlink" title="一、垃圾"></a>一、垃圾</h2><h3 id="1-1-什么是垃圾"><a href="#1-1-什么是垃圾" class="headerlink" title="1.1 什么是垃圾"></a>1.1 什么是垃圾</h3><p>在Java中，没有被任何一个对象引用的实例，就会被当作垃圾来回收</p><h3 id="1-2-怎样判断垃圾"><a href="#1-2-怎样判断垃圾" class="headerlink" title="1.2 怎样判断垃圾"></a>1.2 怎样判断垃圾</h3><p>有两种方式来判断</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><blockquote><p>每有一个对象引用该实例，它的值就加1</p><p>当值为0时，说明没有对象引用它，就可以确认为垃圾。</p></blockquote><p>但是它存在一个缺陷，即无法判断<strong>循环引用</strong>的垃圾</p><p>因此，往往需要考虑许多额外的情况，才能让这个算法正确运行。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote><p>从GC Roots的根对象开始向下搜索，如果某个实例没有和GC Roots相连，就表明它是垃圾</p></blockquote><p>在这种算法中，如何选择<code>GC Roots</code>就是很关键的一点。</p><p>Java中固定可作为GC Roots的有以下几项：</p><ol><li>虚拟机栈中引用的对象</li><li>方法区中常量、静态变量引用的对象</li><li>本地方法栈中<code>native</code>方法引用的对象</li><li>虚拟机内部的引用，包括基本数据类型的Class对象，常驻的异常对象等</li><li>被同步锁持有的对象</li></ol><p>除了固定的<code>GC Roots</code>集合外，可以根据用户所选择的垃圾回收器及当前回收的区域不同，而”临时性”地加入一些其他对象。</p><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>在JDK1.2以前，引用是非常传统的定义，即</p><blockquote><p>reference类型的数据中存储的数值代表是另一块内存的地址，就称该reference是代表某块内存、某个对象的引用</p></blockquote><p>而这样简单的定义，又无法来表示那些<code>食之无味，弃之可惜</code>的对象</p><p>因此，JDK1.2以后，Java的引用扩充成了4种，主要有：</p><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ul><p>它们各自的表现如下</p><table><thead><tr><th align="center">引用名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">强引用</td><td align="center">符合传统定义</td></tr><tr><td align="center">软引用</td><td align="center">内存快溢出时，进行回收</td></tr><tr><td align="center">弱引用</td><td align="center">下一次垃圾回收时必定回收</td></tr><tr><td align="center">虚引用</td><td align="center">最弱，目的只是为了让这个对象在被回收时，能收到一个系统通知</td></tr></tbody></table><h4 id="只有一次的复活甲"><a href="#只有一次的复活甲" class="headerlink" title="只有一次的复活甲"></a>只有一次的复活甲</h4><p>当一个对象被发现时没有与<code>GC Roots</code>相连，它就会被认定为是垃圾</p><p>但是它还有一次复活的机会，那这个机会在哪里呢？让我们慢慢道来</p><pre class="mermaid">graph LR  A[垃圾] --> B{执行过finalize};  B -->|Y| C[等死];  B -->|N| D[丢到队列中执行finalize];  D --> E{还没执行就被引用};  E -->|Y| F[直接复活];  E -->|N| G[继续等死];</pre><h2 id="二、基本回收算法"><a href="#二、基本回收算法" class="headerlink" title="二、基本回收算法"></a>二、基本回收算法</h2><p>最基础的回收算法有三种，它们各有特色。</p><h3 id="1-标记-清除"><a href="#1-标记-清除" class="headerlink" title="1. 标记-清除"></a>1. 标记-清除</h3><p>描述：标记垃圾，然后统一清除</p><p>缺点：</p><ol><li>产生碎片</li><li>标记清除的过程效率低</li></ol><h3 id="2-标记-复制"><a href="#2-标记-复制" class="headerlink" title="2. 标记-复制"></a>2. 标记-复制</h3><p>描述：内存分半，标记时把所有存活对象复制到另一半，然后直接清空当前这一半</p><p>缺点：空间浪费</p><p>特点：</p><ol><li><p>存活对象较少时，复制消耗少，运行高效</p></li><li><p>避免碎片化</p></li></ol><p><strong>因为新生代存活对象较少，所以适合标记-复制算法。</strong></p><h3 id="3-标记-整理"><a href="#3-标记-整理" class="headerlink" title="3. 标记-整理"></a>3. 标记-整理</h3><p>描述：标记时把存活对象移动到一起，然后统一清除剩余部分</p><p>特点：</p><ol><li>性能较差</li><li>避免碎片化</li></ol><h2 id="三、分代"><a href="#三、分代" class="headerlink" title="三、分代"></a>三、分代</h2><p><strong>为什么要分代？</strong></p><p>因为对象有两类，有的存活时间长，有的存活时间短</p><p>把他们分开来，用不同的回收算法来处理，就可以做到时间和空间的高效利用。</p><p><strong>怎么分代呢？</strong></p><p>首先把<code>堆空间</code>按1：2分为新生代和老年代</p><p>新生代又基于<code>大部分对象都活的不久</code>的事实，按8：1：1分为伊甸区、两个存活区。</p><p>其中新生代大部分都是要回收的垃圾</p><h2 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h2><p>在分代时期，新生代和老年代各有3种垃圾收集器</p><p>如果没有具体介绍回收算法，那么新生代统一使用<code>标记-复制</code>算法，老年代统一使用<code>标记-整理</code>算法。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>用单一线程来执行垃圾回收，且回收时用户线程必须暂停</p><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p><code>Serial</code>的多线程版本，一般用来和<code>CMS</code>合作进行</p><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>也是多线程进行回收，但是它的关注点不同。</p><p>其他的垃圾收集器关注用户线程的停顿时间，以保证用户交互的质量；</p><p>而<code>Parallel Scavenge</code>更加关注吞吐量，即用户线程运行时间与总时间的比值，适合后台运算而非交互，</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>老年代版的单线程回收方式。</p><h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>老年代版的多线程回收。</p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>CMS全称为concurrent mark sweep，即并发标记清除，所以它是一种基于标记清除的算法，只不过实现得更加复杂。</p><p>主要分为四个过程：</p><ol><li><p><strong>初始标记</strong></p><p>暂停用户线程，由GC线程记录与GC Root相连的对象</p></li><li><p><strong>并发标记</strong></p><p>用户线程和GC线程一起运行，GC线程从第一步发现的对象开始，往下搜索，记录可达对象</p></li><li><p><strong>重新标记</strong></p><p>暂停用户线程，GC查看上一步标记过程中标记发生变化的区域，进行修正</p></li><li><p><strong>并发清除</strong></p><p>开启用户线程，同时GC线程对未标记的区域进行清扫</p></li></ol><p>缺点：</p><ol><li>因为是基于标记清除算法的，所以会有碎片</li><li>并发操作时占用CPU资源</li><li>清除时用户线程也在执行，所以需要预留空间，即提前进行回收。</li></ol><h2 id="五、G1收集器"><a href="#五、G1收集器" class="headerlink" title="五、G1收集器"></a>五、G1收集器</h2><p>自G1收集器开始，分代的概念越来越淡。</p><p>它的主要思想是<strong>局部收集</strong>和<strong>独立分区</strong>。</p><ul><li><p><strong>局部收集</strong></p><p>指进行垃圾回收时，选择性价比最高的一些区域进行回收</p></li><li><p><strong>独立分区</strong></p><p>新生代和老年代不再是固定的了，它将堆内存分为多个大小相等的区域，然后每个区域根据需要，可以扮演原先分代中各区的角色。</p></li></ul><p><strong>过程：</strong></p><ol><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初学JVM</title>
      <link href="2021/04/27/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E6%80%BB%E8%A7%88/"/>
      <url>2021/04/27/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E6%80%BB%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h3><p>JVM全称是<em><strong>Java Virtual Machine</strong></em>，即<strong>java虚拟机</strong>。</p><p>那么虚拟机又是什么呢</p><blockquote><p>虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p></blockquote><p>在学习Java之初，老师就强调了Java是门跨平台的语言，那么，它究竟是怎么跨平台的呢？</p><p>首先，我们运行Java程序，就是把Java文件编译成class字节码文件<br>然后JVM上的解释器获取字节码文件，把它解释成机器码<br>而机器码就可以跑在计算机上了</p><p>简而言之，JVM就是运行在操作系统上的一个进程，它通过解释器把class文件（即字节码）解释成<strong>特定机器</strong>上的机器码，以此来执行程序。这也正是Java可以<strong>跨平台运行</strong>的原因。</p><h3 id="二、JVM为什么好"><a href="#二、JVM为什么好" class="headerlink" title="二、JVM为什么好"></a>二、JVM为什么好</h3><p>了解了JVM大概是什么之后，我们来看下JVM的优点。</p><ul><li>跨平台<ul><li>上面提到了Java程序可以运行在虚拟机上，以此做到跨平台</li></ul></li><li>垃圾回收机制<ul><li>自动进行垃圾回收，实现对象内存的管理和释放</li></ul></li></ul><p><del>实在编不出来了</del></p><h3 id="三、怎么学JVM"><a href="#三、怎么学JVM" class="headerlink" title="三、怎么学JVM"></a>三、怎么学JVM</h3><p>既然JVM有这么多好处，那怎么学习？</p><p>那肯定要总揽全局，先看看JVM有哪些内容，然后分模块地学习，最后把所有模块联系在一起。</p><p>首先来看下JVM里主要的几个部分：</p><ol><li><em>JVM内存结构</em></li><li><em>Java类加载机制</em></li><li><em>JVM垃圾回收机制</em>（GC）</li><li><em>调优常用命令</em>（偏应用向）</li></ol><h3 id="四、大致流程"><a href="#四、大致流程" class="headerlink" title="四、大致流程"></a>四、大致流程</h3><p>先了解JVM内部的结构，分成哪几个部分啥的；<br>然后一个Java类要执行，它是怎么加入到内存结构中的，即JVM是怎样分配内存的；<br>如果这个类一直在运行，Java是怎么回收那些没被使用的对象的<br>怎样使用命令去查看JVM-GC的具体细节</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p><del>白嫖一下别人的总结</del></p><ol><li><p>虚拟机并不神秘，在操作系统的角度看来，它只是一个普通<strong>进程</strong>。</p></li><li><p>这个叫做虚拟机的进程比较特殊，它能够加载我们编写的class文件。如果把JVM比作一个人，那么class文件就是我们吃的食物。</p></li><li><p>加载class文件的是一个叫做类加载器的子系统。就好比我们的嘴巴，把食物吃到肚子里。</p></li><li><p>虚拟机中的执行引擎用来执行class文件中的字节码指令。就好比我们的肠胃，对吃进去的食物进行消化。</p></li><li><p>虚拟机在执行过程中，要分配内存创建对象。当这些对象过时无用了，必须要自动清理这些无用的对象。清理对象回收内存的任务由垃圾收集器负责。就好比人吃进去的食物，在消化之后，必须把废物排出体外，腾出空间可以在下次饿的时候吃饭并消化食物。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存结构</title>
      <link href="2021/04/27/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>2021/04/27/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM——内存结构"><a href="#JVM——内存结构" class="headerlink" title="JVM——内存结构"></a>JVM——内存结构</h1><p>JVM把它内部分成了好几块内存区域，每个区域存放不同的<em>东西</em>（<del>emmm，想不出叫啥，就姑且叫做东西吧</del>）</p><p>总体的结构如下：</p><p>可以看到，运行时数据区主要分为两类，一类是<strong>线程私有</strong>的，另一类是<strong>线程共享</strong>的</p><p>下面我们也会按类别来进行介绍。</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/jvm_str.jpg" alt="jvm_str" style="zoom: 67%;" /><hr><h2 id="一、线程私有"><a href="#一、线程私有" class="headerlink" title="一、线程私有"></a>一、线程私有</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>是当前线程所执行的字节码的<strong>行号指示器</strong></p><p>看了书之后，介绍下它的作用</p><blockquote><p>因为Java是多线程的，它的多线程是通过线程轮流切换、分配处理器执行时间来实现的。<br>那么每次切换完线程后，如果想回到之前的一个线程，就需要一个行号指示器，指向上个线程所执行的地方。<br>所以程序计数器就实现了这个功能，另外，这也说明了程序计数器是每个线程私有的，只有这样才能满足线程之间的切换。</p></blockquote><p>有两个注意点</p><ol><li>是唯一一个不会产生内存溢出的区域</li><li>正在执行java方法的话，计数器记录的是当前指令的地址；如果是Native方法，则为null。</li></ol><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈和线程的生命周期相同</p><p>每个方法在执行的同时，会创建一个栈帧，用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息</p><blockquote><p>其中局部变量表比较重要，里面存放了编译器可知的基本数据类型、对象引用和返回地址。<br>这些数据类型在表中是以变量槽（slot）的形式表示的，long和double占两个槽，其他都占一个槽。</p></blockquote><p>方法从调用到执行完成，对应了栈帧在虚拟机栈中的入栈与出栈</p><p>注意，虚拟机栈会报StackOverflowError和OutOfMemoryError这两种<em><strong>异常</strong></em></p><ol><li>前者是因为线程请求的栈的深度大于虚拟机所允许的深度</li><li>后者是因为栈动态扩展的时候申请不到足够的内存</li></ol><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>为本地方法服务，在HotSpot中，本地方法栈和虚拟机栈<strong>合二为一</strong>了</p><hr><h2 id="二、线程共享"><a href="#二、线程共享" class="headerlink" title="二、线程共享"></a>二、线程共享</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p>堆是JVM内存中最大的一块区域。笼统来说，堆唯一的目的就是存放对象<strong>实例</strong>，所以垃圾回收也主要在这里进行。</p></blockquote><p>堆中可以划分出多个TLAB（线程私有的分配缓冲区），以提升对象分配时的效率。</p><p>当堆没有内存可供分配，且也无法请求更多的内存来扩展，就会报OutOfMemoryError异常</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote><p>方法区存储的是被JVM加载的<strong>类型信息、常量、静态变量</strong>、即时编译器编译后的代码缓存等数据。</p></blockquote><p>方法区的实现很有意思</p><ol><li>在jdk8之前，它是用堆中永久代来实现的</li><li>jdk8及以后，采用元空间</li><li>另外，在jdk7时，HotSpot就已经将原本放在方法区的<strong>字符串常量池</strong>和<strong>静态变量</strong>移到了堆中。</li></ol><p>方法区也是要进行垃圾回收的，不过它回收目标主要是针对常量池的回收和对类型的卸载。</p><p><strong>运行时常量池</strong></p><p>如果看过之前那篇Class文件结构的博客，可能还记得Class文件中有一个叫做<code>常量池</code>的表</p><p>里面主要存放了<code>字面量</code>和<code>符号引用</code>（可以理解成一些类信息的字符串，如类名、方法名等）</p><p>这些是在<strong>类加载后</strong>存放到方法区的<strong>运行时常量池</strong>的</p><p><strong>特征</strong></p><p><code>运行时常量池</code>和字节码文件中的常量池相比，有一个很大的特征，即<code>动态性</code></p><p>因为常量并不是只在编译时产生，程序运行时也可能产生新的常量，这时候就会动态添加到常量池中。</p><hr><h2 id="三、直接内存"><a href="#三、直接内存" class="headerlink" title="三、直接内存"></a>三、直接内存</h2><blockquote><p>不是JVM运行时数据区的一部分，但也会频繁地调用</p></blockquote><p><a href="https://imgchr.com/i/DmDHbQ"><img src= "/img/loading.gif" data-lazy-src="https://s3.ax1x.com/2020/11/18/DmDHbQ.png" alt="DmDHbQ.png"></a>    </p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树最近公共祖先</title>
      <link href="2021/04/27/leetcode/12_%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>2021/04/27/leetcode/12_%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h1 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h1><p>题目请看这里：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></p><p>思路参考了大佬的题解：<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/">后序遍历 DFS ，清晰图解</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定两个节点p，q，在它们的公共祖先中找出最近的一个（包含自己）。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/Snipaste_2021-04-27_11-23-17.png"></p><p>这类题可以用递归方式求解，那么具体怎么递归呢？</p><p>我们可以先处理左右子节点，然后根据左右子节点的情况，递推到父节点，这就是<code>后序遍历</code>的思想</p><p><strong>现在假设root是当前节点，left是子节点，right是右节点</strong></p><p><strong>递归终止条件：</strong></p><ul><li>遍历到叶子节点</li><li>遇到目标节点</li></ul><p><strong>递归过程：</strong></p><p>对<code>left</code>和<code>right</code>采取递归，得到返回值</p><p><strong>递归返回值（核心）：</strong></p><ul><li><code>left</code>为空且<code>right</code>为空，说明当前节点的子树不存在目标节点，返回<code>null</code></li><li><code>left</code>不为空且<code>right</code>不为空，说明目标节点分布在子树两侧，返回<code>root</code></li><li><code>left</code>和<code>right</code>只有一个不为空，返回不为空的那个</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root == p || root == q) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode left = lowestCommonAncestor(root.left, p, q);<br>        TreeNode right = lowestCommonAncestor(root.right, p, q);<br> <br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树锯齿形遍历</title>
      <link href="2021/04/26/leetcode/11_%E4%BA%8C%E5%8F%89%E6%A0%91%E9%94%AF%E9%BD%BF%E5%BD%A2%E9%81%8D%E5%8E%86/"/>
      <url>2021/04/26/leetcode/11_%E4%BA%8C%E5%8F%89%E6%A0%91%E9%94%AF%E9%BD%BF%E5%BD%A2%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树锯齿形遍历"><a href="#二叉树锯齿形遍历" class="headerlink" title="二叉树锯齿形遍历"></a>二叉树锯齿形遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>给定一颗二叉树，按照从左到右，再从右到左的层序进行遍历。</p><p>在层序遍历基础上，需要更改遍历的方向，因此一个普通的队列满足不了，需要双端队列来存储。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;<br>        Deque&lt;TreeNode&gt; dQueue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    <span class="hljs-comment">// 初始化一些数据</span><br>        dQueue.addFirst(root);<br>        <span class="hljs-keyword">int</span> size;<br>        List&lt;Integer&gt; tmp;<br>        <span class="hljs-keyword">boolean</span> isCurLeft = <span class="hljs-keyword">true</span>;<span class="hljs-comment">// 表示当前一层是否是从左到右遍历的</span><br><span class="hljs-comment">// 队列为空时，完成遍历</span><br>        <span class="hljs-keyword">while</span> (!dQueue.isEmpty()) &#123;<br>            tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-comment">// 按照size来对这一层完成遍历</span><br>            size = dQueue.size();<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 从左往右遍历时，操作与层序遍历的一致</span><br>                <span class="hljs-keyword">if</span> (isCurLeft) &#123;<br>                    root = dQueue.removeFirst();<br>                    tmp.add(root.val);<br>                    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;<br>                        dQueue.addLast(root.left);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;<br>                        dQueue.addLast(root.right);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 从右往左时，需要从后面开始读元素，并且按先右后左的顺序添加到队列头部</span><br>                    root = dQueue.removeLast();<br>                    tmp.add(root.val);<br>                    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;<br>                        dQueue.addFirst(root.right);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;<br>                        dQueue.addFirst(root.left);<br>                    &#125;<br>                &#125;<br>                size --;<br>            &#125; <br>            <span class="hljs-comment">// 把这一层遍历的结果添加到最终数组里</span><br>            result.add(tmp);<br>            isCurLeft = !isCurLeft;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树层序遍历</title>
      <link href="2021/04/26/leetcode/10_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>2021/04/26/leetcode/10_%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定一个二叉树，返回按<strong>层序遍历</strong>得到的值</p><p>我们可以使用一个队列来存储每次遍历到的元素</p><p>因为队列先进先出的性质，它就维持了按层遍历的特点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java">  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>      Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>      List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-comment">// 如果根节点为空，直接返回空数组</span><br>      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> result;<br>      &#125;<br><span class="hljs-comment">// 做一些初始化的准备</span><br>      queue.offer(root);<br>      List&lt;Integer&gt; tmp;<br><br>      <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>          tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>          <span class="hljs-comment">// 通过size来确认一层一层遍历</span><br>          <span class="hljs-keyword">int</span> size = queue.size();<br>          <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>              root = queue.poll();<br>              tmp.add(root.val);<br>              <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;<br>                  queue.offer(root.left);<br>              &#125;<br>              <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;<br>                  queue.offer(root.right);<br>              &#125;<br>              size --;<br>          &#125;<br>          result.add(tmp);<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节码指令</title>
      <link href="2021/04/26/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/"/>
      <url>2021/04/26/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><h2 id="一、结构"><a href="#一、结构" class="headerlink" title="一、结构"></a>一、结构</h2><h3 id="1-1-简单定义"><a href="#1-1-简单定义" class="headerlink" title="1.1 简单定义"></a>1.1 简单定义</h3><blockquote><p>Java虚拟机的指令是由<strong>一个字节长度</strong>的、<strong>代表着某种特定操作</strong>含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。</p></blockquote><p>简单来说，指令就是由一个字节的<strong>操作码</strong>和若干个<strong>参数</strong>构成。</p><p>另外， 因为Java虚拟机采用的是<strong>面向操作数栈</strong>的架构，所以大多数指令只有一个操作码，而操作数被放在了操作数栈中。</p><h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><p>从上面的定义中，我们可以发现，</p><ul><li><p>操作码总数不能超过256</p><p>既然操作码只占了一个字节，那么<code>1字节 = 8比特，2^8 = 256</code>，即最多能表示<code>256</code>条指令</p></li><li><p>编译后Class文件中代码的操作数长度不对齐</p></li></ul><p>这种字节码结构有着明显的优势和劣势：</p><ul><li><p>优势</p><p>省略了大量的填充和间隔符号，编译代码更加精简</p></li><li><p>劣势</p><p>处理超过一个字节的数据时，会因为重建而损失性能</p></li></ul><h3 id="1-3-执行模型"><a href="#1-3-执行模型" class="headerlink" title="1.3 执行模型"></a>1.3 执行模型</h3><p>不考虑异常处理的话，可以用以下代码来表示Java虚拟机的解释器的执行过程</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span> &#123;<br>自动计算PC寄存器的值加<span class="hljs-number">1</span><br>根据PC寄存器指示的位置，从字节码流中取出操作码<br><span class="hljs-keyword">if</span> (字节码存在操作数) &#123;<br>从字节码流中取出操作数<br>&#125;<br>执行操作码所定义的操作<br>&#125; <span class="hljs-keyword">while</span> (字节码流的长度 &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="二、类别"><a href="#二、类别" class="headerlink" title="二、类别"></a>二、类别</h2><p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。</p><p>前面我们知道了指令集不能超过256条，而Java的数据类型有很多，如果针对每一种类型，都划分出专门的指令去操作它，可能就会溢出。</p><p>那么Java虚拟机是怎么做的呢？</p><p>在将这些之前，我们先要了解两个概念。</p><h3 id="2-1-符号扩展和零位扩展"><a href="#2-1-符号扩展和零位扩展" class="headerlink" title="2.1 符号扩展和零位扩展"></a>2.1 符号扩展和零位扩展</h3><ul><li><p>符号扩展，扩展时，前面全部补上符号位</p></li><li><p>零位扩展，扩展时前面全部补零</p></li></ul><p>我们用一个例子来表示说明一下这两个概念，假设现在有两个数<code>+3</code>和<code>-3</code></p><p>它们用8位的原码表示分别是<code>00000011</code>和<code>10000011</code></p><p>现在我们要把它扩展到用16位来表示，就会产生如下结果</p><table><thead><tr><th align="center">数字</th><th align="center">符号扩展</th><th align="center">零位扩展</th></tr></thead><tbody><tr><td align="center">+3</td><td align="center">0000000000000011</td><td align="center">0000000000000011</td></tr><tr><td align="center">-3</td><td align="center">1111111110000011</td><td align="center">0000000010000011</td></tr></tbody></table><p>我们可以看到，对于正数而言，符号扩展和零位扩展是没有区别的；而负数的话就是扩展的数字不同。</p><p>这两个概念和我们所说的溢出又有什么关系呢？</p><p><strong>其实设计者为了让指令集不会溢出（或者说，复用一些指令），就让编译器在编译或运行时期，把byte和short类型的数据带符号扩展为int类型，把boolean和char类型数据零位扩展成int类型。</strong></p><p>这样就不必对这四个类型单独再分配一些指令来处理了。</p><h3 id="2-2-加载和存储指令"><a href="#2-2-加载和存储指令" class="headerlink" title="2.2 加载和存储指令"></a>2.2 加载和存储指令</h3><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。例如：</p><ul><li>把一个局部变量加载到操作栈中：iload，fload，dload</li><li>把一个数值从操作数栈存储到局部变量表中：istore，lstore</li><li>把一个常量加载到操作数栈：bipush，sipush</li></ul><h3 id="2-3-运算指令"><a href="#2-3-运算指令" class="headerlink" title="2.3 运算指令"></a>2.3 运算指令</h3><p>算术指令用于对操作数栈上的两个值进行某种特定运算，并把结果重新存入到操作栈顶。</p><p>这里有两个<strong>注意点</strong>，</p><p><strong>一是之前提过的byte，short，char，boolean是用int类型指令操作的</strong></p><p><strong>二是计算浮点数时，会碰到取舍的问题</strong></p><p>先介绍下<strong>两种舍入模式</strong>：</p><ol><li>向最接近数舍入</li><li>向零舍入</li></ol><p>浮点数之间的计算，采用第一种向最接近数舍入，如果是浮点数转整型，采用向零舍入模式</p><p>我们可以回想下，Java中浮点数之间计算后，结果并不是严格准确的；浮点数转整型，会丢弃小数部分；</p><p>这些都和舍入模式相匹配。</p><h3 id="2-4-类型转换指令"><a href="#2-4-类型转换指令" class="headerlink" title="2.4 类型转换指令"></a>2.4 类型转换指令</h3><p>用于对类型的<strong>显式转换</strong>；如果是隐式的（如int转long）就不用这些指令，因为虚拟机直接支持。</p><p>注意，转换时可能会出现不同的正负号，因为long转int是简单的丢弃多余的高位部分，所以如果原来是负数，转换后可能就是正数了。</p><p>对于浮点型的转换，</p><ul><li>如果是NaN，则转成int或long的0</li><li>如果不是无穷大，则按向零舍入来取整<ul><li>如果取整后在范围内，则直接用</li><li>如果不在范围内，根据符号取边界值</li></ul></li></ul><h3 id="2-5-对象创建与访问指令"><a href="#2-5-对象创建与访问指令" class="headerlink" title="2.5 对象创建与访问指令"></a>2.5 对象创建与访问指令</h3><p>Java中的对象包括类实例和数组，创建他们所采用的字节码并不同。</p><p>对象创建完毕后，可以通过访问指令来获取对象实例（或数组实例）中的字段（或数组元素）。</p><h3 id="2-6-操作数栈管理指令"><a href="#2-6-操作数栈管理指令" class="headerlink" title="2.6 操作数栈管理指令"></a>2.6 操作数栈管理指令</h3><p>用于管理操作数栈中的元素</p><h3 id="2-7-控制转移指令"><a href="#2-7-控制转移指令" class="headerlink" title="2.7 控制转移指令"></a>2.7 控制转移指令</h3><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令的下一条指令继续执行程序。</p><h3 id="2-8-方法调用和返回指令"><a href="#2-8-方法调用和返回指令" class="headerlink" title="2.8 方法调用和返回指令"></a>2.8 方法调用和返回指令</h3><p>方法调用（分派、执行过程）将会在以后介绍。</p><p>方法调用有一系列以”invoke”开头的指令</p><p>返回有一系列以“return”结尾的指令</p><h3 id="2-9-异常处理指令"><a href="#2-9-异常处理指令" class="headerlink" title="2.9 异常处理指令"></a>2.9 异常处理指令</h3><p>关于异常，有三种来源：</p><ul><li>Java程序显式抛出，由athrow指令实现</li><li>Java程序try catch处理，用<code>异常表</code>来完成</li><li>程序发生异常状况，自动抛出</li></ul><h3 id="2-10-同步指令"><a href="#2-10-同步指令" class="headerlink" title="2.10 同步指令"></a>2.10 同步指令</h3><p>Java虚拟机支持两种同步：<strong>方法级的同步</strong>和方法内部<strong>一段指令序列</strong>的同步。</p><p>这两种同步都是靠管程（或者说锁）来实现的</p><h4 id="对于方法级的同步"><a href="#对于方法级的同步" class="headerlink" title="对于方法级的同步"></a>对于方法级的同步</h4><p>它是隐式的，不用字节码指令来控制</p><p>因为方法的访问标志里如果声明了<code>ACC_SYNCHRONIZED</code>，就能够表示它是同步方法</p><p>然后在方法<strong>执行线程</strong>就要<strong>先获取管程，才能执行方法</strong>，方法结束后就会释放管程</p><h4 id="对于指令序列的同步"><a href="#对于指令序列的同步" class="headerlink" title="对于指令序列的同步"></a>对于指令序列的同步</h4><p>它通常是由<code>synchronized</code>关键字声明的</p><p>Java虚拟机的指令集中有<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持<code>synchronized</code></p><p><strong>实现<code>synchronized</code>指令，是<code>Javac编译器</code>和<code>Java虚拟机</code>共同协作的结果</strong></p><p>怎么理解这句话呢？</p><p>这就要谈谈这两个指令的用法了，这<strong>两条指令</strong>是加在同步指令序列的<strong>两端</strong>（开始和结束处），来<strong>保证同步性</strong>。</p><p><strong>如果指令正常执行，毫无疑问能配对成功。</strong></p><p><strong>如果执行到一般发生异常了，这时候被迫跳出同步指令序列，即只执行了<code>monitorenter</code>，而没有执行到<code>monitorexit</code></strong></p><p>那怎么办呢？这就要看编译器了</p><blockquote><p>在编译时，为了保证方法异常时，monitorenter和monitorexit指令仍能够配对，编译器自动生成一个异常处理程序，声明可处理所有的异常，然后只要在monitorexit后面再来条相同的指令，就能成功配对了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类文件结构</title>
      <link href="2021/04/25/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>2021/04/25/Java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>我们所写的程序想要被计算机执行，有两种方式，第一种是<strong>编译成由0和1组成的二进制格式，让计算机执行。</strong></p><p>而随着虚拟机的蓬勃发展，大量的程序语言建立在虚拟机的基础上，所以产生了第二种编译方式，即：</p><p><strong>编译成与操作系统和机器指令集无关的、平台中立的文件存储格式</strong></p><p>这也正是<code>字节码</code>文件的由来。</p><h3 id="二、介绍"><a href="#二、介绍" class="headerlink" title="二、介绍"></a>二、介绍</h3><p>Java文件通过编译器编译，得到**Class文件(字节码文件)**，然后再通过JVM来执行。</p><p>但是为了让虚拟机知道这是字节码文件，就需要严格定义字节码文件的格式</p><p>因此在Class文件中，它的每个数据项的顺序和数量，甚至存储的字节序（统一使用Big Endian），都是被严格限定的。</p><p>下面我们将介绍字节码文件的具体结构。</p><h3 id="三、文件格式"><a href="#三、文件格式" class="headerlink" title="三、文件格式"></a>三、文件格式</h3><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p><strong>「Class文件」</strong>采用一种类似于C语言结构体的伪结构来存储数据。</p><p>数据类型只有两种，「无符号数」和「表」</p><ul><li><p>无符号数</p><p>用<code>u1,u2,u4,u8</code>分别来表示<code>1，2，4，8</code>个字节</p><p>可以用来描述<strong>数字、索引引用、数量值或UTF-8编码的字符串值</strong></p></li><li><p>表</p><p>由多个无符号数或表构成的复合数据类型</p><p>为便于区分，表名一般以<code>_info</code>结尾</p></li></ul><p>因为存在同一类型但数量不确定的数据，所以一般会用一个前置的容量计数器来表示数量。</p><h3 id="四、详细介绍"><a href="#四、详细介绍" class="headerlink" title="四、详细介绍"></a>四、详细介绍</h3><h5 id="①魔数"><a href="#①魔数" class="headerlink" title="①魔数"></a>①魔数</h5><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">u4</td><td align="center">magic</td><td align="center">1</td></tr></tbody></table><p>Class文件的头四个字节称为<strong>Magic Number</strong>，用来<strong>确认文件是否是JVM所能接收的Class文件</strong></p><p>使用魔数的方式来区分文件类型，这种方式在GIF和JPEG中也可以看到。</p><p>至于使用头字节而不是文件的扩展名来判断文件类型，主要还是为了安全考虑，毕竟啥文件改了后缀也能变成Class文件。</p><p>Class文件魔数的具体取值为<code>0xCAFEBABE</code>，即咖啡宝贝</p><h5 id="②主版本号和次版本号"><a href="#②主版本号和次版本号" class="headerlink" title="②主版本号和次版本号"></a>②主版本号和次版本号</h5><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">minor_version</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">major_version</td><td align="center">1</td></tr></tbody></table><p>紧跟着魔数的四个字节分别表示<strong>Minor Version</strong>和<strong>Major Version</strong></p><p>JDK1.1以后，每个大版本都会让主版本号加一。</p><p>高版本的JDK能向下兼容低版本的Class文件，但是版本比它高的Class就不行，因为《Java虚拟机规范》要求了虚拟机必须拒绝执行超过其版本号的Class文件。</p><h5 id="③常量池"><a href="#③常量池" class="headerlink" title="③常量池"></a>③常量池</h5><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">constant_pool_count</td><td align="center">1</td></tr><tr><td align="center">cp_info</td><td align="center">constant_pool</td><td align="center">constant_pool_count - 1</td></tr></tbody></table><p>由<code>constant_pool_count</code>和<code>constant_pool</code>构成。</p><p><strong>constant_pool_count（u2类型）</strong></p><p>因为常量池的容量是不固定的，所以入口处有u2类型的数据，来表示「常量池的容量」。</p><p>注意，它是从1开始计数的，所以常量数量为$count - 1$</p><p>这样做的原因，据设计者说，是为了<strong>能够让以后某些指向常量池的索引值的数据表达“不引用任何一个常量池项目”的含义。</strong></p><p><strong>constant_pool（cp_info类型）</strong></p><p>常量池中主要存放两大类常量：<strong>字面量</strong>和<strong>符号引用</strong></p><ul><li><p><strong>字面量</strong></p><p>文本字符串，声明为final的常量值等</p></li><li><p><strong>符号引用</strong></p><p>类、接口的全限定名</p><p>字段的名称和描述符</p><p>方法的名称和描述符等</p></li></ul><p>常量池中的每个常量都是一个表，截至JDK13，共有17种不同类型的常量。</p><p>这17类表有一个共同特点，即<strong>第一个字节都表示tag标志位，代表当前常量属于哪个常量表</strong>，后面的字节根据不同的表而变化。</p><h5 id="④访问标志"><a href="#④访问标志" class="headerlink" title="④访问标志"></a>④访问标志</h5><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">access_flags</td><td align="center">1</td></tr></tbody></table><p>常量池结束之后的两个字节，用来表示类或接口的访问标志</p><p>可以取的值有：public、final、super、interface等共9个</p><h5 id="⑤索引集合"><a href="#⑤索引集合" class="headerlink" title="⑤索引集合"></a>⑤索引集合</h5><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">this_class</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">super_class</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">interfaces_count</td><td align="center">1</td></tr><tr><td align="center">u2</td><td align="center">interfaces</td><td align="center">interfaces_count</td></tr></tbody></table><p>类索引和父类索引都占两个字节，而接口索引是一组数据的集合。</p><p>这些索引用来确认类的全限定名、父类的全限定名以及实现的接口的名称。</p><p><strong>具体确认过程如下：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/Snipaste_2021-04-25_17-01-01.png" alt="Snipaste_2021-04-25_17-01-01"></p><h5 id="⑥字段表集合"><a href="#⑥字段表集合" class="headerlink" title="⑥字段表集合"></a>⑥字段表集合</h5><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">fields_count</td><td align="center">1</td></tr><tr><td align="center">field_info</td><td align="center">fields</td><td align="center">fields_count</td></tr></tbody></table><p>包含了类或接口声明的类级变量（static）和实例变量，但不包含方法内的局部变量。</p><p>我们可以先思考下，一个字段拥有什么属性？</p><ul><li>修饰符，public、static、volatile等</li><li>名称，字段名</li><li>类型，是什么数据类型</li><li>属性，如果是集合类型，里面包含的其他属性</li></ul><p>根据上面罗列出来的信息，我们可以总结出字段表的内部结构</p><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">access_flags</td><td align="center">1</td><td align="center">字段修饰符</td></tr><tr><td align="center">u2</td><td align="center">name_index</td><td align="center">1</td><td align="center">简单名称</td></tr><tr><td align="center">u2</td><td align="center">descriptor_index</td><td align="center">1</td><td align="center">描述符</td></tr><tr><td align="center">u2</td><td align="center">attributes_count</td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">attribute_info</td><td align="center">attributes</td><td align="center">attributes_count</td><td align="center"></td></tr></tbody></table><p>这里解释下前面提到过的三个名词，全限定名、简单名称和描述符。</p><ul><li><p><strong>全限定名</strong></p><p>com/edu/neu/TestApplication;</p><p>代表类的全限定名</p></li><li><p><strong>简单名称</strong></p><p>sort：sort()方法的简单名称</p><p>arr：arr字段的简单名称</p></li><li><p><strong>描述符</strong></p><p>描述符和上述两者相比更加复杂一些。它是用来描述<strong>字段的数据类型</strong>、<strong>方法的参数列表</strong>和<strong>返回值</strong>。</p></li></ul><p><strong>描述字段时</strong></p><table><thead><tr><th align="center">标识字符</th><th align="center">含义</th><th align="center">标识字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">B</td><td align="center">基本类型byte</td><td align="center">J</td><td align="center">基本类型long</td></tr><tr><td align="center">C</td><td align="center">基本类型char</td><td align="center">S</td><td align="center">基本类型short</td></tr><tr><td align="center">D</td><td align="center">基本类型double</td><td align="center">Z</td><td align="center">基本类型boolean</td></tr><tr><td align="center">F</td><td align="center">基本类型float</td><td align="center">V</td><td align="center">特殊类型void</td></tr><tr><td align="center">I</td><td align="center">基本类型int</td><td align="center">L</td><td align="center">对象类型，如Ljava/lang/Object;</td></tr></tbody></table><p><strong>基本数据类型和void都用大写字母来表示，对象类型则用L加上对象的全限定名来表示，数组类型在最前面加上若干个[</strong></p><p>对于<code>java.lang.String[][]</code>类型，它的描述符将是<code>[[Ljava/lang/String;</code></p><p>对于<code>int[]</code>，它的描述符将是<code>[I</code></p><p><strong>描述方法时</strong></p><p>按照<strong>先参数列表</strong>、<strong>后返回值</strong>的顺序进行描述，参数列表要放在<code>()</code>中。</p><p>对于<code>int indexOf(char[] source, int srcOffset, int srcCount, char[] target, int tarOffset, int tarCount, int fromIndex)</code>，描述符将是<code>([CII[CIII)I</code></p><h5 id="⑦方法表集合"><a href="#⑦方法表集合" class="headerlink" title="⑦方法表集合"></a>⑦方法表集合</h5><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">methods_count</td><td align="center">1</td></tr><tr><td align="center">method_info</td><td align="center">methods</td><td align="center">methods_count</td></tr></tbody></table><p>方法表和上述字段表集合几乎一致，所以关于表结构这部分不再介绍。</p><p>但是如果只是和字段一样的话，那么它的代码怎么保存呢？</p><p>事实上，方法体经过编译器编译成字节码指令后，存放在方法的属性表集合中一个名为<code>Code</code>的属性里，我们在将属性表时，会介绍这些。</p><h5 id="⑧属性表集合"><a href="#⑧属性表集合" class="headerlink" title="⑧属性表集合"></a>⑧属性表集合</h5><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">attributes_count</td><td align="center">1</td></tr><tr><td align="center">attribute_info</td><td align="center">attributes</td><td align="center">attributes_count</td></tr></tbody></table><p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序。</p><p>在最新的《Java虚拟机规范》的JavaSE12版本中，预定义属性达到29项。可想而知，它的内容非常多。</p><p>下面我们介绍下属性表的基本结构</p><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">u2</td><td align="center">attribute_name_index</td><td align="center">1</td></tr><tr><td align="center">u4</td><td align="center">attribute_length</td><td align="center">1</td></tr><tr><td align="center">u1</td><td align="center">info</td><td align="center">attribute_length</td></tr></tbody></table><p>一个符合规范的属性表，它的属性名应该从常量池中引用<code>CONSTANT_Utf8_info</code>类型的常量来表示，而属性值的结构是完全自定义的，只需要通过一个<code>u4</code>长度属性去说明属性值所占用的位数即可。</p><p>至于具体的属性值结构，可参考《深入理解Java虚拟机》P233。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83/"/>
      <url>2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h2 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h2>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82/"/>
      <url>2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82/</url>
      
        <content type="html"><![CDATA[<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>提供统一的接口来访问子系统中的一群接口</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/f9978fa6-9f49-4a0f-8540-02d269ac448f.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式</title>
      <link href="2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0/"/>
      <url>2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>为对象动态地添加功能。</p><p><strong>主要元素</strong></p><ul><li><p><strong>组件</strong></p><p>接口，提供简单方法</p></li><li><p><strong>装饰者</strong></p><p>抽象类，实现组件接口，<strong>可以不实现接口方法</strong></p></li><li><p><strong>具体装饰者</strong></p><p>继承装饰者类，并提供额外方法（和组件方法相比）</p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/6b833bc2-517a-4270-8a5e-0a5f6df8cd96.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88/"/>
      <url>2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>把对象组合成树形结构，表示整体和部分，从而能够处理单独一个对象或者是一个组合对象。</p><p><strong>主要元素</strong></p><ul><li><p><strong>组件</strong></p><p>父类，提供抽象方法</p></li><li><p><strong>组合</strong></p><p>子类，拥有多个组件对象，表示整体</p></li><li><p><strong>叶子</strong></p><p>子类，表示部分</p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/2b8bfd57-b4d1-4a75-bfb0-bcf1fba4014a.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5/"/>
      <url>2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>把对象的实现和抽象分离开来。</p><p>方式就是有两个抽象类，其中一个类中存有另一个类的对象，然后又带有该抽象类的方法</p><p><strong>主要对象</strong></p><ul><li><p><strong>Abstraction</strong></p><p>抽象类，带有另一个抽象类的对象和方法</p></li><li><p><strong>RedinedAbstraction</strong></p></li><li><p><strong>Implementor</strong></p><p>实现接口类，另一个类所持有</p></li><li><p><strong>ConcreteImplementor</strong></p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/2a1f8b0f-1dd7-4409-b177-a381c58066ad.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>当需要让一个对象的方法模仿成另一个对象的方法时，我们可以让第一个对象中持有第二个对象</p><p>然后调用具体方法时，调用第二个对象的方法。</p><p><strong>主要元素</strong></p><ul><li><p><strong>Target</strong></p><p>客户期望得到的接口</p></li><li><p><strong>Adaptee</strong></p><p>已经存在的，需要适配的类</p></li><li><p><strong>Adapter</strong></p><p>把源接口转化成目标接口</p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/image-20201117020248795.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>空对象模式</title>
      <link href="2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A9%BA%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A9%BA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>当某个方法返回<code>null</code>值时，我们可以把原返回对象的类，封装成抽象类的子类，而<code>null</code>值也可以看作是该抽象类的子类，只是什么都不做。</p><p><strong>主要元素</strong></p><ul><li><p><strong>AbstractOperation</strong></p><p>抽象类，提供抽象的操作方法</p></li><li><p><strong>RealOperation</strong></p><p>子类，实现具体操作</p></li><li><p><strong>NullOperation</strong></p><p>子类，什么都不做，即null</p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/22870bbe-898f-4c17-a31a-d7c5ee5d1c10.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>访问者模式</title>
      <link href="2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85/"/>
      <url>2021/04/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>顾客去点餐，需要点多个项目，而服务员就相当于Visitor，最后统计用ConcreteVisitor类</p><p>Element可以看作是顾客、点餐和具体菜品，统一接受服务员的服务。</p><p><strong>主要元素</strong></p><ul><li>Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作</li><li>ConcreteVisitor：具体访问者，存储遍历过程中的累计结果</li><li>ObjectStructure：对象结构，可以是组合结构，或者是一个集合。</li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/79c6f036-bde6-4393-85a3-ef36a0327bd2.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>复用相同的操作，父类把不同的操作抽象化，让子类去具体实现</p><p><strong>主要元素</strong></p><ul><li><p><strong>AbstractClass</strong></p><p>抽象类，提供模板方法，把其中不同的操作提取出来，变为抽象方法，由子类实现</p></li><li><p><strong>ConcreteClass</strong></p><p>具体方法类，继承父类，实现抽象方法</p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/ac6a794b-68c0-486c-902f-8d988eee5766.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>封装多个算法，并根据需要进行更改算法</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/cd1be8c2-755a-4a66-ad92-2e30f8f47922.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。</p><p><strong>主要元素</strong></p><ul><li><p>Context</p><p>拥有多个具体状态对象和一个当前状态对象，在调用状态对象的方法时，如果状态发生改变，则修改当前状态对象。</p></li><li><p>State</p><p>状态接口</p></li><li><p>ConcreteState</p><p>具体的状态对象</p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/79df886f-fdc3-4020-a07f-c991bb58e0d8.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p><p>主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。</p><p><strong>主要元素</strong></p><ul><li><p><strong>Subject</strong></p><p>主题接口</p></li><li><p><strong>ConcreteSubject</strong></p><p>实现父类方法，并拥有观察者的集合，可以直接通知观察者</p></li><li><p><strong>Observer</strong></p><p>观察者接口</p></li><li><p><strong>ConcreteObserver</strong></p><p>具体观察者，实现了接口的方法</p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/a8c8f894-a712-447c-9906-5caef6a016e3.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>通过另一个对象来存放当前对象的一些状态，然后在需要时，可以从备份中恢复到上一个状态</p><p><strong>相关元素</strong></p><ul><li>Originator：原始对象</li><li>Caretaker：负责保存好备忘录</li><li>Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。</li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/50678f34-694f-45a4-91c6-34d985c83fee.png" alt="img"></p><p><strong>例子：</strong>计算器保存上一次的两个数到备忘录中，在需要时可以直接回滚。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85/</url>
      
        <content type="html"><![CDATA[<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>把多个对象之间复杂的依赖关系，转化为统一对一个对象的依赖。</p><p>把对象都集中在中介者这里，通过它来调用相应方法。</p><p><strong>主要元素</strong></p><ul><li><p><strong>Mediator</strong></p><p>抽象的中介者类</p></li><li><p><strong>ConcreteMediator</strong></p><p>中介者子类，带有<code>ConcreteColleague</code>对象，通过这些对象来调用方法</p></li><li><p><strong>Colleague</strong></p><p>抽象的同事类</p></li><li><p><strong>ConcreteColleagur</strong></p><p>同事子类，重写具体方法</p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/30d6e95c-2e3c-4d32-bf4f-68128a70bc05.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。</p><p><strong>主要元素</strong></p><ul><li><p><strong>Aggregate</strong></p><p>提供接口创建迭代器</p></li><li><p><strong>ConcreteAggregate</strong></p><p>实现接口方法，创建一个<code>ConcreteIterator</code>对象</p></li><li><p><strong>Iterator</strong></p><p>迭代器接口，拥有<code>next()</code>和<code>hasNext()</code>方法</p></li><li><p><strong>ConcreteIterator</strong></p><p>实现迭代器的<code>next()</code>和<code>hasNext()</code>方法</p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/image-20201102012333804.png" alt="image-20191130164425351"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解释器模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>为语言创建解释器，通常由语言的语法和语法分析来定义。</p><p><strong>主要元素</strong></p><ul><li><p><strong>AbstractExpression</strong></p><p>抽象类，提供抽象方法<code>interpret()</code></p></li><li><p><strong>TerminalExpression</strong></p><p>终止符表达式，真正用来解释的</p></li><li><p><strong>NonTerminalExpression</strong></p><p>非终止符表达式，可以用来构建解析树，然后让终止符表达式来解释。</p></li></ul><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/2b125bcd-1b36-43be-9b78-d90b076be549.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>将命令封装成对象中，具有以下作用：</p><ul><li>使用命令来参数化其它对象</li><li>将命令放入队列中进行排队</li><li>将命令的操作记录到日志中</li><li>支持可撤销的操作</li></ul><p><strong>主要对象</strong></p><ul><li><strong>Command</strong></li></ul><p>命令接口，提供<code>execute()</code>方法</p><ul><li><strong>ConcreteCommand</strong></li></ul><p>实现类，实现<code>execute()</code>来表示具体的命令</p><ul><li><strong>Invoker</strong></li></ul><p>调用器，相当于遥控器，里面有着命令的集合，通过它来调用命令</p><ul><li><strong>Client</strong></li></ul><p>通过Invoker来调用命令</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/c44a0342-f405-4f17-b750-e27cf4aadde2.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。</p><p>将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。</p><p><strong>主要对象</strong></p><ul><li><strong>Handler</strong></li></ul><p>处理请求的接口，并且携带有下一个Handler</p><p>提供抽象的处理方法，供子类实现</p><ul><li><strong>ConcreteHandler</strong></li></ul><p>实现具体的处理请求方法，如果不能处理，则提交给下一个Handler</p><ul><li><strong>Client</strong></li></ul><p>客户端，调用Handler来处理请求</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/ca9f23bf-55a4-47b2-9534-a28e35397988.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。</p><p><strong>主要元素：</strong></p><ul><li>Client</li></ul><p>通过原型类的复制，来创建新对象</p><ul><li>Prototype</li></ul><p>抽象的原型类，提供抽象的克隆方法供子类实现</p><ul><li>ConcretePrototype</li></ul><p>实现父类的克隆方法，在里面创建新对象</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/b8922f8c-95e6-4187-be85-572a509afb71.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生成器模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>封装一个对象的构造过程，并允许分步骤来进行构造</p><p><strong>主要对象有：</strong></p><ol><li>Director</li></ol><p>指示器，指导Builder对象该怎样进行构造</p><ol start="2"><li>Builder</li></ol><p>建造者父类，提供多个抽象方法，来构造产品不同部分</p><ol start="3"><li>ConcreteBuilder</li></ol><p>建造者子类，实现具体的构造</p><ol start="4"><li>Product</li></ol><p>产品类，分解成多个属性，供建造者来建造</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/db5e376d-0b3e-490e-a43a-3231914b6668.png" alt="img"></p><p>具体代码可查看<code>StringBuilder</code>类，它便是采用了生成器模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/40c0c17e-bba6-4493-9857-147c0044a018.png" alt="img"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct1();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct2();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProduct();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SimpleFactory simpleFactory = <span class="hljs-keyword">new</span> SimpleFactory();<br>        Product product = simpleFactory.createProduct(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>把简单工厂中的<strong>产品类</strong>和<strong>工厂类</strong>都封装成父类，并提供抽象方法供子类去实现。</p><p>然后通过不同的工厂来获得不同产品。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/f4d0afd0-8e78-4914-9e60-4366eaf065b5.png" alt="img"></p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>在一个工厂中提供多个抽象方法，创建多个产品</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/e2190c36-8b27-4690-bde5-9911020a1294.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/"/>
      <url>2021/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>确保类只有一个实例</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/eca1f422-8381-409b-ad04-98ef39ae38ba.png" alt="img"></p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><h5 id="版本1：普通单例"><a href="#版本1：普通单例" class="headerlink" title="版本1：普通单例"></a>版本1：普通单例</h5><p>把构造方法变为私有，通过静态方法来获取静态对象实例。</p><p>只有在用到对象时，才进行创建，节省了资源。</p><p><strong>但是，多个线程同时进入判断后，会实例化多个对象，所以线程不安全。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="版本2：无脑加锁"><a href="#版本2：无脑加锁" class="headerlink" title="版本2：无脑加锁"></a>版本2：无脑加锁</h5><p>对获取对象的方法进行<strong>加锁</strong>，使同一时间只能有一个线程访问该方法</p><p>其他线程想要调用该方法，就得等待，因此等待时间会变长，性能较差，不推荐。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span>  Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="版本3：双重校验锁"><a href="#版本3：双重校验锁" class="headerlink" title="版本3：双重校验锁"></a>版本3：双重校验锁</h5><p>我们可以只对判断语句内部加锁，这样只有对象还没被实例化过，才会进行加锁并创建对象。</p><p>如果对象被实例化过，其他线程就不会阻塞，直接得到对象。</p><p><strong>注意</strong></p><p><strong>1.这里要用到两个if判断，如果只有外层一个判断，仍然会有多个线程进入判断内部，依次执行实例化操作</strong></p><p><strong>2.uniqueInstance使用volatile修饰，防止指令重排序</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>        uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>    &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="版本4：静态内部类"><a href="#版本4：静态内部类" class="headerlink" title="版本4：静态内部类"></a>版本4：静态内部类</h5><p>加载外部类时，内部类并不会被加载到内存中。</p><p>只有调用<code>getUniqueInstance()</code>，触发了<code>SingletonHolder.INSTANCE</code>后，才会加载内部类，并实例化对象。</p><p>这种实现不仅具有延迟初始化，还利用了JVM提供对线程安全的支持。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="版本5：枚举类"><a href="#版本5：枚举类" class="headerlink" title="版本5：枚举类"></a>版本5：枚举类</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    INSTANCE;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>Singleton firstSingleton = Singleton.INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>上面线程不安全的原因，在于多个线程同时进入判断后，会实例化多个对象</p><p>所以可以直接把对象实例化，但这样丢失了节省资源的好处。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker使用</title>
      <link href="2021/04/21/docker/docker/"/>
      <url>2021/04/21/docker/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在传统项目中，开发和运维的对接往往会出现环境不一致的问题，即使能够统一环境，也需要进行很多配置，非常麻烦。</p><p>所以人们就提出一种方式，即</p><blockquote><p>把开发时的环境抽离并保存下来，当其他地方需要运行项目时，直接拉取这个环境，就省去了麻烦的配置过程。</p></blockquote><p>这也就是docker的思想。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><p> docker采用容器的思想，把镜像配置在容器中，当其他人需要运行项目时，只需要从docker仓库中拉去相应的镜像，即可解决环境冲突问题。</p></blockquote><blockquote><p>轻巧，和VM相比，他只需要几兆空间，因为只用到了核心命令等</p></blockquote><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><blockquote><p>官网：<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p></blockquote><h3 id="1-检查环境"><a href="#1-检查环境" class="headerlink" title="1.检查环境"></a>1.检查环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">uname -r              <span class="hljs-comment"># 查看内核版本，需要3.1及以上</span><br>cat /etc/os-release   <span class="hljs-comment"># 查看CentOS版本，需要7以上</span><br></code></pre></td></tr></table></figure><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.install </span><br>yum install -y yum-utils<br><br><span class="hljs-comment"># 2.set repository  not sure</span><br>yum-config-manager \<br>--add-repo \<br>http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo <br><br><span class="hljs-comment"># 3.update index</span><br>yum makecache fast<br><br><span class="hljs-comment"># 4.install docker-ce</span><br>yum install docker-ce docker-ce-cli containerd.io<br><br><span class="hljs-comment"># 5.start docker</span><br>systemctl start docker<br><span class="hljs-comment"># sure</span><br>docker version<br><br><br></code></pre></td></tr></table></figure><h2 id="三、docker组件介绍"><a href="#三、docker组件介绍" class="headerlink" title="三、docker组件介绍"></a>三、docker组件介绍</h2><p><strong>docker的核心三大组件为：镜像、容器和仓库</strong></p><p>三者的关系如下所示：</p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/docker_component.png" alt="docker_component" style="zoom: 67%;" /><p>在谈这些之前，我们先要了解下Linux相关的一些基础知识。</p><p>Linux操作系统分为两部分，<strong>内核与用户空间</strong>。Linux真正<strong>核心</strong>部分在于内核，而<strong>用户空间</strong>只是各大厂商在内核基础上添加自己的软件与工具集形成的发布版本。</p><p><strong>镜像</strong></p><blockquote><p>docker镜像实际上是由一层一层的系统文件组成，这种层级的文件系统被称为UnionFS( Union file system  统一文件系统)，镜像可以基于dockerfile构建，dockerfile是一个描述文件，里面包含了若干条密令，每条命令都会对基础文件系统创建新的层次结构。</p></blockquote><p><strong>镜像仓库</strong></p><p>镜像仓库顾名思义便是用来存放镜像的，docker提供了一个注册服务器（register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像，docker运作中使用的默认仓库是docker hub公共仓库。</p><p><strong>容器</strong></p><p>docker容器是由docker镜像创建的运行实例。</p><p>docker容器类似虚拟机，可以执行包含启动，停止，删除等。每个容器间是相互隔离的。</p><p>容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件，因此可以看作是一个简易版的Linux环境（包含root用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序。</p><h2 id="四、常用命令"><a href="#四、常用命令" class="headerlink" title="四、常用命令"></a>四、常用命令</h2><h3 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1.帮助命令"></a>1.帮助命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker version<br>docker info    <span class="hljs-comment"># 显示系统信息，包括容器和镜像</span><br>docker 命令 --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h3 id="2-镜像命令"><a href="#2-镜像命令" class="headerlink" title="2.镜像命令"></a>2.镜像命令</h3><h5 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看本地主机上的所有镜像</span><br>docker images  <br><br><span class="hljs-comment"># 可选项</span><br>- a <span class="hljs-comment"># all</span><br>- q <span class="hljs-comment"># 只显示镜像id</span><br></code></pre></td></tr></table></figure><h5 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在docker hub中搜索镜像</span><br>docker search mysql<br><br><span class="hljs-comment"># 可选项</span><br>--filter<span class="hljs-comment"># 搜索过滤 如 --filter=STARS=3000</span><br></code></pre></td></tr></table></figure><h5 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker pull mysql<br><span class="hljs-comment"># 拉取结果分析，待补充</span><br><br><span class="hljs-comment"># 指定版本，注意，版本必须是存在的</span><br>docker pull mysql:5.7<br></code></pre></td></tr></table></figure><h5 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 全部删除</span><br>docker rmi -f $(docker images -aq)<br><br><span class="hljs-comment"># 指定id或名称</span><br>docker rmi -f id或name<br><br></code></pre></td></tr></table></figure><h3 id="3-容器命令"><a href="#3-容器命令" class="headerlink" title="3.容器命令"></a>3.容器命令</h3><p>首先，需要一个镜像才能运行容器。</p><h5 id="拉取cent-OS镜像"><a href="#拉取cent-OS镜像" class="headerlink" title="拉取cent OS镜像"></a>拉取cent OS镜像</h5><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">docker pull centOS<br></code></pre></td></tr></table></figure><h5 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run [可选参数] image<br><span class="hljs-comment"># 参数</span><br> --name=<span class="hljs-string">&quot;Name&quot;</span> 用来区分容器<br> -d 后台运行<br> -it 启动并进入容器<br> -p 绑定端口，有多种方式<br> -p ip:主机端口:容器端口<br> -p 主机端口:容器端口(最常用)<br> -p 容器端口<br> 容器端口<br> -P 随机指定端口 <br></code></pre></td></tr></table></figure><h5 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看正在运行的容器</span><br>docker ps<br><span class="hljs-comment"># 查看正在运行和历史运行的容器</span><br>docker ps -a<br><span class="hljs-comment"># 只显示id</span><br>docker ps -q<br></code></pre></td></tr></table></figure><h5 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果在创建容器时加上了 -it，就会直接进入到容器中</span><br><br><span class="hljs-comment"># 1.退出，但是容器也会停止</span><br><span class="hljs-built_in">exit</span><br><br><span class="hljs-comment"># 2.退出，容器不停止</span><br>ctrl + p + q<br></code></pre></td></tr></table></figure><h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker rm 容器id<br><br>docker rm -f $(docker ps -aq)<br><br>docker ps -aq | xargs docker rm<br></code></pre></td></tr></table></figure><h5 id="启动和停止容器"><a href="#启动和停止容器" class="headerlink" title="启动和停止容器"></a>启动和停止容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker start   <span class="hljs-comment"># 启动</span><br>docker stop    <span class="hljs-comment"># 停止</span><br>docker <span class="hljs-built_in">kill</span>    <span class="hljs-comment"># 强制停止</span><br>docker restart <span class="hljs-comment"># 重启</span><br></code></pre></td></tr></table></figure><h3 id="4-其他命令"><a href="#4-其他命令" class="headerlink" title="4.其他命令"></a>4.其他命令</h3><h5 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -d 镜像名<br><span class="hljs-comment"># 发现容器停止了</span><br><span class="hljs-comment"># 因为docker必须要有一个前台进程运行着才行</span><br></code></pre></td></tr></table></figure><h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看指定id的10条日志</span><br>docker logs -tf --tail 10 容器id<br><br></code></pre></td></tr></table></figure><h5 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker top 容器id<br></code></pre></td></tr></table></figure><h5 id="查看镜像元数据"><a href="#查看镜像元数据" class="headerlink" title="查看镜像元数据"></a>查看镜像元数据</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker inspect 容器id<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟机相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环形链表</title>
      <link href="2021/04/15/leetcode/9_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>2021/04/15/leetcode/9_%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">题目请看这里</a></p><p>给定链表，判断是否有环</p><h2 id="二、思路及代码"><a href="#二、思路及代码" class="headerlink" title="二、思路及代码"></a>二、思路及代码</h2><ul><li>思路1</li></ul><p>可以用set把遍历过的节点存起来，如果遇到重复的，即有环</p><p>缺点：使用了额外的空间</p><ul><li>思路2</li></ul><p>用快慢指针的方式，当两个指针再次重合时，说明有环存在</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    ListNode fast = head.next;<br>    ListNode slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 - 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票的最佳时机</title>
      <link href="2021/04/15/leetcode/8_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>2021/04/15/leetcode/8_%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">题目请看这里</a></p><p>给定股票价格的数组，选择一天买入，之后某一天卖出，求最大利润</p><h2 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h2><p>用贪心的思想，尽量让每次都取到最大利润</p><p>记录最小值和最大利润，每次遍历时，求出<code>最小值买入，当前价格卖出</code>的利润，并与最大利润比较</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; ++ i) &#123;<br>        ans = Math.max(ans, prices[i] - min);<br>        min = Math.min(min, prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>核心功能——配置文件</title>
      <link href="2021/04/14/SpringBoot/4_yaml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>2021/04/14/SpringBoot/4_yaml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="YAML配置文件"><a href="#YAML配置文件" class="headerlink" title="YAML配置文件"></a>YAML配置文件</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>yaml是一种比<code>xml</code>更便捷的文件格式</p><p>主要表现在格式整齐、书写方便、占用内容少</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>采用键值对的形式，key: value</p><ul><li>一般形式<ul><li><code>key: value</code></li></ul></li><li>数组、队列、集合<ul><li><code>key: [v1,v2,v3]</code></li></ul></li><li>Map、对象<ul><li><code>key: &#123;k1:v1,k2:v2,k3:v3&#125;</code></li></ul></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> Boolean boss;<br>    <span class="hljs-keyword">private</span> Date birth;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Pet pet;<br>    <span class="hljs-keyword">private</span> String[] interests;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; animal;<br>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; score;<br>    <span class="hljs-keyword">private</span> Set&lt;Double&gt; salarys;<br>    <span class="hljs-keyword">private</span> Map&lt;String, List&lt;Pet&gt;&gt; allPets;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Double weight;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span><br><span class="hljs-attr">userName:</span> <span class="hljs-string">whz</span><br><span class="hljs-attr">boss:</span> <span class="hljs-string">whz</span><br><span class="hljs-attr">birth:</span> <span class="hljs-number">1999</span><span class="hljs-string">/10/04</span><br><span class="hljs-attr">age:</span> <span class="hljs-number">21</span><br><span class="hljs-attr">pet:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">cc</span><br><span class="hljs-attr">weight:</span> <span class="hljs-number">20</span><br><span class="hljs-attr">interests:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">eat</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">drink</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">play</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">happy</span><br><span class="hljs-attr">animal:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">a</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">b</span><br><span class="hljs-attr">score:</span><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门——开发小技巧</title>
      <link href="2021/04/14/SpringBoot/3_%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>2021/04/14/SpringBoot/3_%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="一、lombok"><a href="#一、lombok" class="headerlink" title="一、lombok"></a>一、lombok</h2><p>该插件可以让我们不用再写<code>setter</code>和<code>getter</code>等方法</p><p>只需要添加注解就可以在编译时生成对应代码</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="IDEA安装lombok插件"><a href="#IDEA安装lombok插件" class="headerlink" title="IDEA安装lombok插件"></a>IDEA安装lombok插件</h3><p>在market中搜索插件并安装</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>@Data<ul><li>setter和getter</li></ul></li><li>@NoArgsConstructor<ul><li>无参构造器</li></ul></li><li>@AllArgsConstructor<ul><li>全参构造器</li></ul></li><li>@ToString<ul><li>toString()</li></ul></li><li>@EqualsAndHashCode<ul><li>equals()和hashCode()</li></ul></li><li>@Slf4j<ul><li>日志</li><li>在注解的类中，可直接用<code>log.info()</code>等方法输出日志</li></ul></li></ul><h2 id="dev-tools"><a href="#dev-tools" class="headerlink" title="dev-tools"></a>dev-tools</h2><p>热部署工具，这是重新启动</p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="使用快捷键ctrl-F9来刷新"><a href="#使用快捷键ctrl-F9来刷新" class="headerlink" title="使用快捷键ctrl + F9来刷新"></a>使用快捷键<code>ctrl + F9</code>来刷新</h3><h2 id="Spring-Initializr"><a href="#Spring-Initializr" class="headerlink" title="Spring Initializr"></a>Spring Initializr</h2><p>快速创建SpringBoot项目</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>String、StringBuffer</title>
      <link href="2021/04/14/Java/Java%E5%9F%BA%E7%A1%80/String%E4%B8%8EStringBuffer/"/>
      <url>2021/04/14/Java/Java%E5%9F%BA%E7%A1%80/String%E4%B8%8EStringBuffer/</url>
      
        <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>最近在做算法题时用到了StringBuffer的一些方法</p><p>所以特地来了解一下String类与StringBuffer类的一些原理及操作</p><h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>在学Java之初，我们就已经知道String是不可变的</p><blockquote><p>什么是不可变呢？</p><p>例如对一个String类型的对象进行修改时，每次得到的都是新的String对象</p><p>而原来的String对象是是一直不变的</p></blockquote><p>但它究竟是怎么实现的呢</p><p>我们先来看下String的源码，可以看到</p><ul><li><strong>final关键字修饰了类和字符数组</strong><ul><li>禁止继承，避免子类继承后，修改内容</li></ul></li><li><strong>字符数组还是private的</strong><ul><li>一定程度上防止外界访问到字符数组</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br></code></pre></td></tr></table></figure><p>但是只靠这样，就能保证String的不可变性吗</p><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><strong>首先，我们可以知道一点，用final关键字修饰的变量，一旦被创建就无法再修改</strong></p><p>所以下面将<code>tmp</code>的引用赋值给<code>arr</code>，会提示错误</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>arr = tmp;<br></code></pre></td></tr></table></figure><p>但是arr数组在内存中其实是分为两部分的，即<strong>引用</strong>和<strong>数组本体</strong></p><p><strong>引用放在Stack中，而数组本体在Heap中</strong></p><p>如果我们直接去修改堆中的数组，是否会造成改变呢</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 输出 10，2，3</span><br><span class="hljs-comment">// 可以final数组改变了</span><br></code></pre></td></tr></table></figure><p>由此我们知道用<code>final</code>关键字修饰，还是无法避免数组内容的修改</p><h2 id="replace-源码分析"><a href="#replace-源码分析" class="headerlink" title="replace()源码分析"></a>replace()源码分析</h2><p>那么该怎样避免这种情况呢，我们很容易就能想到，当然是依赖于具体方法的实现。</p><p>就以<code>replace(oldChar, newChar)</code>为例，我们先来分析下大致逻辑</p><ul><li>在$oldChar != newChar$时</li><li>然后在原数组中找到第一个oldChar</li><li>如果存在oldChar<ul><li>创建新数组</li><li>oldChar之前的字符直接复制到新数组</li><li>oldChar及以后的字符，边复制边判断</li><li>如果等于oldChar，就替换成newChar</li></ul></li><li>如果$oldChar==newChar$或者原数组中没有oldChar，就直接返回原数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">char</span> oldChar, <span class="hljs-keyword">char</span> newChar)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (oldChar != newChar) &#123;<br>        <span class="hljs-keyword">int</span> len = value.length;<br>        <span class="hljs-keyword">int</span> i = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">char</span>[] val = value; <span class="hljs-comment">/* avoid getfield opcode */</span><br><br>        <span class="hljs-keyword">while</span> (++i &lt; len) &#123;<br>            <span class="hljs-keyword">if</span> (val[i] == oldChar) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt; len) &#123;<br>            <span class="hljs-keyword">char</span> buf[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                buf[j] = val[j];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i &lt; len) &#123;<br>                <span class="hljs-keyword">char</span> c = val[i];<br>                buf[i] = (c == oldChar) ? newChar : c;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buf, <span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看完逻辑之后，我们发现当存在oldChar时，他会创建一个新的数组，替换oldChar并返回</p><p>也许在这之前，我们会好奇它为什么要创建新的数组</p><p><strong>但今天我们很容易就联想到，它的这个操作正是为了防止原数组被修改，从而保证了String的不可变性</strong></p><h2 id="不可变的作用"><a href="#不可变的作用" class="headerlink" title="不可变的作用"></a>不可变的作用</h2><p>从上面我们大概可以推断出，String类的设计者在类的方法中尽力避免原数组的修改，来保证其不可变性</p><p>那不可变究竟有什么用呢？</p><ul><li>最重要的一点，就是安全<ul><li>String不可变，可以避免将String对象作为传参时，被用户不小心修改的情况</li><li>在并发场景下，因为String的不可写（写了之后变成新对象，没有意义），所以是线程安全的</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>String的各种方法都避免对原数组进行修改，这才是String不可变性的主要实现方式</p><p>String类用final关键字修饰</p><ul><li>防止子类继承，去破坏它的不可变性</li><li>String类本身已经很完美了，无需其他类继承它</li></ul><h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><p>当需要修改字符串内容时，我们一般采用<code>StringBuffer</code>类</p><p>既然如此，就来看下StringBuffer的实现吧</p><h2 id="StringBuffer结构"><a href="#StringBuffer结构" class="headerlink" title="StringBuffer结构"></a>StringBuffer结构</h2><p><strong>类结构如下</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/images/sb_1.PNG"></p><p>可以看到，StringBuffer类中有一个字符数组<code>toStringCache</code>，注释表明</p><blockquote><p>该数组存放的是由最近一次toString()方法返回的值</p><p>并且当StringBuffer发生变化时，它会被清空</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringBuffer</span></span><br><span class="hljs-class">   <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractStringBuilder</span></span><br><span class="hljs-class">   <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">CharSequence</span> </span>&#123; <br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A cache of the last value returned by toString. Cleared</span><br><span class="hljs-comment">     * whenever the StringBuffer is modified.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">char</span>[] toStringCache;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="append-String"><a href="#append-String" class="headerlink" title="append(String)"></a>append(String)</h2><p><strong>再来看看常用的append方法</strong></p><p><strong>正如上面所说，在StringBuffer添加字符串时，会把toStringCache清空。</strong>清空的原因在看到toString()时再讲</p><p>而且它调用了父类的append方法进行添加字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    toStringCache = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">super</span>.append(str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是<code>AbstractStringBuilder</code>这个抽象类提供的append方法</p><p>主要逻辑如下：</p><ul><li>判断传入的String是否为空<ul><li>为空，调用<code>appendNull()</code></li><li>非空，确保数组容量</li><li>再把字符串添加到字符数组中</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> appendNull();<br>    <span class="hljs-keyword">int</span> len = str.length();<br>    ensureCapacityInternal(count + len);<br>    str.getChars(<span class="hljs-number">0</span>, len, value, count);<br>    count += len;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br></code></pre></td></tr></table></figure><p>上面主要用到了三个方法<code>appendNull()</code>、<code>ensureCapacityInternal()</code>和<code>getChars()</code></p><p>下面依次分析</p><h2 id="ensureCapacityInternal-int"><a href="#ensureCapacityInternal-int" class="headerlink" title="ensureCapacityInternal(int)"></a>ensureCapacityInternal(int)</h2><p>为什么要先分析这个方法呢，因为appendNull()里面也用到了。。</p><p>如果我们之前看过<code>ArrayList</code>相关的源码，对这类方法应该不陌生了吧</p><ul><li>方法形参为<strong>minimumCapacity</strong><ul><li>从上面append中，可以发现实参是$count+len$</li><li>即插入<code>str</code>后的数组长度，暂时把它叫做<strong>最小容量</strong>吧</li></ul></li><li>方法内部就是把最小容量与数组当前的长度进行比较<ul><li>如果$minimumCapacity &gt; value.length$</li><li>则要进行扩容，调用Arrays.copyOf()，这个方法可太熟了，就不再赘述</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        value = Arrays.copyOf(value,<br>                newCapacity(minimumCapacity));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不会以为到这儿就结束了吧，我们还有一点没讲，就是扩容的大小选择</p><p>那就来看看**newCapacity(int)**方法</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回顾下参数：</span><br><span class="hljs-comment">// minCapacity: 插入元素后的数组长度，即最小容量</span><br><span class="hljs-comment">// newCapacity: 原数组长度 * 2 + 2，即新容量</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">newCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>   <span class="hljs-comment">// 如果新容量小于最小容量，就把新容量设置成最小容量</span><br>    <span class="hljs-keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>        newCapacity = minCapacity;<br>    &#125;<br>    <span class="hljs-comment">// 经过上述判断后的新容量</span><br>    <span class="hljs-comment">// 如果小于0（整型溢出） 或 大于最大数组容量（定义的Integer.MAX_VALUE - 8）</span><br>    <span class="hljs-comment">// 就让新容量为最大数组容量</span><br>    <span class="hljs-comment">// 否则就不变，直接返回</span><br>    <span class="hljs-keyword">return</span> (newCapacity &lt;= <span class="hljs-number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="hljs-number">0</span>)<br>        ? hugeCapacity(minCapacity)<br>        : newCapacity;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// overflow</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>    &#125;<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)<br>        ? minCapacity : MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="appendNull"><a href="#appendNull" class="headerlink" title="appendNull()"></a>appendNull()</h2><p>如果append(String)传入null，就会进入这个方法</p><p>方法内只做了两件事</p><ol><li>判断要不要扩容</li><li>在数组中添加“null”字符串</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> AbstractStringBuilder <span class="hljs-title">appendNull</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = count;<br>    ensureCapacityInternal(c + <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] value = <span class="hljs-keyword">this</span>.value;<br>    value[c++] = <span class="hljs-string">&#x27;n&#x27;</span>;<br>    value[c++] = <span class="hljs-string">&#x27;u&#x27;</span>;<br>    value[c++] = <span class="hljs-string">&#x27;l&#x27;</span>;<br>    value[c++] = <span class="hljs-string">&#x27;l&#x27;</span>;<br>    count = c;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="getChars"><a href="#getChars" class="headerlink" title="getChars()"></a>getChars()</h2><p>该方法是由<strong>String类</strong>提供的</p><p>忽略那些判断，主要是调用<strong>System.arraycopy()把调用方法的String对象的部分字符拷贝到目的数组中</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getChars</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcBegin, <span class="hljs-keyword">int</span> srcEnd, <span class="hljs-keyword">char</span> dst[], <span class="hljs-keyword">int</span> dstBegin)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (srcBegin &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(srcBegin);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (srcEnd &gt; value.length) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(srcEnd);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (srcBegin &gt; srcEnd) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);<br>    &#125;<br>    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>分析完StringBuffer的append()后，我们再来看下它如何返回得到字符串</p><p>主要是把<code>Arrays.copyOfRange</code>返回的字符数组，赋值给toStringCache</p><p>然后再通过String类构造器创建一个String对象</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-keyword">null</span>) &#123;<br>        toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(toStringCache, <span class="hljs-keyword">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>copyOfRange()</strong></p><p>我们发现内部是创建了新数组来存放元素</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] copyOfRange(<span class="hljs-keyword">char</span>[] original, <span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to) &#123;<br>    <span class="hljs-keyword">int</span> newLength = to - from;<br>    <span class="hljs-keyword">if</span> (newLength &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(from + <span class="hljs-string">&quot; &gt; &quot;</span> + to);<br>    <span class="hljs-keyword">char</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[newLength];<br>    System.arraycopy(original, from, copy, <span class="hljs-number">0</span>,<br>                     Math.min(original.length - from, newLength));<br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们解释下append方法中为什么要把toStringCache设置为null</p><blockquote><p>1.当StringBuffer对象发生变化时，通过调用toString会得到一个新的toStringCache，保证了旧的一个不会再发生变化</p><p>2.当StringBuffer对象没有发生变化时，多次调用toString不会产生重复的字符串</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三数之和</title>
      <link href="2021/04/13/leetcode/7_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2021/04/13/leetcode/7_%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定数组<code>nums</code>， 找出所有<strong>不重复</strong>的三元组$(a,b,c)$，满足$a+b+c=0$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接硬找肯定不行，可以先对他进行排序，这样至少看起来好了很多</p><p>然后再想想，题目要求找三个数之和等于0的，那么如果遍历到大于0的数字，是不是之后就不用再看了，这样范围又缩小了</p><p>然后我们考虑从头开始遍历的话，每次遍历到元素<code>a</code>，只要再从后面找到<code>b</code>和<code>c</code>满足条件即可</p><p>找<code>b</code>和<code>c</code>我们可以使用双指针来进行移动</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>逻辑</strong></p><ul><li>对数组排序</li><li>从头开始遍历<ul><li>通过判断<code>i</code>与<code>i-1</code>来进行去重</li><li>定义双指针，令指针向中间移动，直到<code>left</code>越过<code>right</code><ul><li>求和并判断</li><li>如果大于0，$right-1$</li><li>如果小于0，$left+1$</li><li>如果等于0，则记录答案，去重，更新指针</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; nums[i] &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>] ) ++i;<span class="hljs-comment">//注意点1 与前一个进行比较</span><br>        <span class="hljs-keyword">int</span> left = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> right = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">// 求和</span><br>            <span class="hljs-keyword">int</span> sum = nums[i] + nums[left] + nums[right];<br>            <span class="hljs-comment">// 判断</span><br>            <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) --right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) ++left;<br>            <span class="hljs-keyword">else</span> &#123;<br>                List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                tmp.add(nums[i]);<br>                tmp.add(nums[left]);<br>                tmp.add(nums[right]);<br>                ans.add(tmp);<br>                <span class="hljs-comment">//注意点2 先去重，再更新</span><br>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="hljs-number">1</span>]) --right;<br>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="hljs-number">1</span>]) ++left;<br>                ++left;<br>                --right;   <br>            &#125;<br>        &#125;<br>        i ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>去重注意点</strong></p><ul><li><strong>去重应该等元素判断过后，再去重，否则该元素就被忽视了</strong></li><li><strong><code>i</code>的去重可以是与前一个进行比较，以保证<code>i</code>一定被处理过</strong></li><li><strong><code>left</code>和<code>right</code>应该在找到目标后，再进行去重，然后更新下标</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大字序和</title>
      <link href="2021/04/13/leetcode/6_%E6%9C%80%E5%A4%A7%E5%AD%97%E5%BA%8F%E5%92%8C/"/>
      <url>2021/04/13/leetcode/6_%E6%9C%80%E5%A4%A7%E5%AD%97%E5%BA%8F%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="最大字序和"><a href="#最大字序和" class="headerlink" title="最大字序和"></a>最大字序和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定数组<code>nums</code>，找到具有<strong>最大和</strong>的<strong>连续</strong>子数组，并返回最大和</p><p>这道题我们很容易就想到动态规划，然后一般状态定义有两种方式，$dp[i]$可以表示为</p><ul><li>长度为 $i+1$ 的数组中连续子数组的最大和</li><li>以 $nums[i]$ 结尾的连续子数组的最大和</li></ul><p>我们可以发现，第二种定义更适合状态转移</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> ans = dp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++ i) &#123;<br>        dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>] + nums[i], nums[i]);<br>        ans = Math.max(ans, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>空间优化</strong></p><p>注意，因为数组中可能存在负数</p><p>所以如果想要从下标0开始遍历，就要让 <code>cur</code> 和 <code>ans</code> 的初始值为<code>Integer.MIN_VALUE</code>，这样会出现越界！</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    <span class="hljs-keyword">int</span> cur = nums[<span class="hljs-number">0</span>];<br>   <br>    <span class="hljs-keyword">int</span> ans = cur;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++ i) &#123;<br>        cur = Math.max(cur + nums[i], nums[i]);<br>        ans = Math.max(ans, cur);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K个一组翻转链表</title>
      <link href="2021/04/13/leetcode/5_K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>2021/04/13/leetcode/5_K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">题目请看这里</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定K值，然后依次对链表的k个元素进行翻转</p><p>如果剩余不满K个，则不进行翻转</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据翻转链表的思路，再进行计数，每遇到k个元素，就翻转一次</p><p>思路并不算复杂，主要是编码较困难</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>封装翻转链表的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 初始化</span><br>        ListNode dummyHead = <span class="hljs-keyword">new</span> ListNode();<br>        dummyHead.next = head;<br>        ListNode cur = head;<br>        ListNode tail = dummyHead;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (count == k) &#123;<br>                ListNode next = cur.next;<br>                cur.next = <span class="hljs-keyword">null</span>;<br>                tail = reverseList(tail.next, tail, next);<br>                count = <span class="hljs-number">1</span>;<br>                cur = next;           <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count ++;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 举例：如果链表为 1-&gt; 2-&gt;3 -&gt;4 ，要翻转 2-&gt;3</span><br><span class="hljs-comment">    * @description    返回翻转后的尾部，或者说翻转前的头部2    </span><br><span class="hljs-comment">    * @param head     要翻转部分的头节点2</span><br><span class="hljs-comment">    * @param preHead  翻转链表外的头部1</span><br><span class="hljs-comment">    * @param preTail  翻转链表外的尾部4</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head, ListNode preHead, ListNode preTail)</span> </span>&#123;<br>        ListNode cur = head;<br>        ListNode tmp = cur.next;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            tmp = cur.next;<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">break</span>;<br>            cur.next = preTail;<br>            preTail = cur;<br>            cur = tmp;    <br>        &#125;<br>        cur.next = preTail;<br>        preHead.next = cur;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门——自动装配</title>
      <link href="2021/04/12/SpringBoot/2_%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%8E%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
      <url>2021/04/12/SpringBoot/2_%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E4%B8%8E%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、依赖管理"><a href="#一、依赖管理" class="headerlink" title="一、依赖管理"></a>一、依赖管理</h1><h2 id="关于父工程的依赖"><a href="#关于父工程的依赖" class="headerlink" title="关于父工程的依赖"></a>关于父工程的依赖</h2><p>当我们创建了Spring Boot项目后，我们会发现<code>pom.xml</code>文件中，默认有个父工程</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>进入之后发现他还有个父工程</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后我们来到了名为<strong>spring-boot-dependencies</strong>的工程</p><p>发现他里面添加了开发中常用依赖的版本，配置在<strong>properties</strong>标签中</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activemq.version</span>&gt;</span>5.15.13<span class="hljs-tag">&lt;/<span class="hljs-name">activemq.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">antlr2.version</span>&gt;</span>2.7.7<span class="hljs-tag">&lt;/<span class="hljs-name">antlr2.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appengine-sdk.version</span>&gt;</span>1.9.81<span class="hljs-tag">&lt;/<span class="hljs-name">appengine-sdk.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artemis.version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">artemis.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aspectj.version</span>&gt;</span>1.9.6<span class="hljs-tag">&lt;/<span class="hljs-name">aspectj.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">assertj.version</span>&gt;</span>3.16.1<span class="hljs-tag">&lt;/<span class="hljs-name">assertj.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">atomikos.version</span>&gt;</span>4.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">atomikos.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">awaitility.version</span>&gt;</span>4.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">awaitility.version</span>&gt;</span><br>  &lt;-! ......省略-&gt;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">webjars-locator-core.version</span>&gt;</span>0.45<span class="hljs-tag">&lt;/<span class="hljs-name">webjars-locator-core.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">wsdl4j.version</span>&gt;</span>1.6.3<span class="hljs-tag">&lt;/<span class="hljs-name">wsdl4j.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xml-maven-plugin.version</span>&gt;</span>1.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">xml-maven-plugin.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xmlunit2.version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">xmlunit2.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>而如果我们想要自己来选择版本的话，就可以在pom.xml中的properties标签中添加对应依赖的版本</strong></p><h2 id="starter场景启动器"><a href="#starter场景启动器" class="headerlink" title="starter场景启动器"></a>starter场景启动器</h2><p>关于<code>spring-boot-starter-web</code>的依赖如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>我们进入它（或者是其他starter）的内部，发现所有类似的starter都有这样一段依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这说明了只要引用了<code>spring-boot-starter-xxx</code>，就会自动引入该场景（例子中是web）的所有常规依赖</p><h1 id="二、自动配置"><a href="#二、自动配置" class="headerlink" title="二、自动配置"></a>二、自动配置</h1><p><strong>Spring Boot的自动配置如下</strong></p><ol><li>配置Tomcat</li><li>配置SpringMVC</li><li>配置Web常用功能，如字符编码等</li><li>默认包结构</li></ol><p><strong>主启动类路径下的文件都会被扫描到</strong></p><p><strong>如果想要改变扫描路径，可以通过</strong></p><ul><li><p>@SpringBootApplication(scanBasePackages=”com.edu.neu”)</p></li><li><p>或者@ComponentScan(“com.edu.neu”)</p></li></ul><p>特点：按需加载配置项</p><h1 id="三、组件注册"><a href="#三、组件注册" class="headerlink" title="三、组件注册"></a>三、组件注册</h1><h2 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1.Spring"></a>1.Spring</h2><p>spring是采用在xml配置文件中写标签的方式来注册组件，<del>但不知为啥没注册成功。。</del>原来还要@ImportResource才行</p><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cola&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.edu.neu.learning.entity.Cola&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;price&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-SpringBoot-Configuration"><a href="#2-SpringBoot-Configuration" class="headerlink" title="2.SpringBoot @Configuration"></a>2.SpringBoot @Configuration</h2><p>spring boot可以不用再通过<code>xml</code>文件来注册组件了，而是使用<code>@Configuration</code>注解，来表示这是<strong>配置类</strong></p><p>然后在<strong>配置类</strong>中通过<code>@Bean</code>的方式把组件注册到容器中。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColaConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Cola <span class="hljs-title">myCola</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cola();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们进入到@Configuration注解中，可以发现它定义了一个布尔型的变量，默认是true</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">proxyBeanMethods</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;<br></code></pre></td></tr></table></figure><p><strong>proxyBeanMethods直译过来就是是否要代理组件方法</strong>，那么我们可以理解成</p><ul><li>true，由容器来代理组件方法</li><li>false，容器不进行代理</li></ul><p><strong>那这有什么用呢？</strong>就写一段代码试试看吧</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java">ColaConfig bean = run.getBean(ColaConfig.class); <span class="hljs-comment">// 得到配置类的实例对象</span><br><span class="hljs-comment">// 通过配置类的方法来获取Cola对象</span><br>      Cola cola1 = bean.myCola();<br>      Cola cola2 = bean.myCola();<br><span class="hljs-comment">// 如果是代理，则    cola1 == cola2</span><br><span class="hljs-comment">// 如果不采用代理，则 cola1 != cola2</span><br></code></pre></td></tr></table></figure><p><strong>这说明当配置类采取代理组件方法时，它会先从容器中获得对象。容器没有的话，再调用真正的方法去创建对象并注册到容器中。</strong></p><p>之后如果还想要获取对象，就会直接返回容器中存在的对象，不用重复创建。</p><p><strong>这样看来代理是不是还挺好的，但是存在一个问题，如果每次都要从容器中寻找对象，就会造成不必要的开销，特别是本来就不用组件依赖的时候，直接创建对象也可以用，就不用再去容器中寻找，所以选择不代理的情况也是存在的</strong></p><p><strong>所以基于他们耗时、开销的多少，我们常常把采用代理称为Full模式，不用代理形容成Light（轻量级）模式</strong></p><p>总结一下，如下</p><ul><li>配置类的组件之间无依赖关系，就用轻量级模式加速容器的启动过程，减少判断</li><li>配置类的组件之间存在依赖，就要用Full模式，让被调用方法返回之前存在的容器</li></ul><h2 id="3-Import"><a href="#3-Import" class="headerlink" title="3.@Import"></a>3.@Import</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a><strong>描述</strong></h3><p>用来在容器中注册全类名的组件</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a><strong>用法</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Import(&#123;Person.class, DBHelper.class&#125;)</span><br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColaConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Conditional"><a href="#4-Conditional" class="headerlink" title="4.@Conditional"></a>4.@Conditional</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a><strong>描述</strong></h3><p>表示在条件满足时再注册组件</p><p>它有很多子类，例如ConditionalOnBean、ConditionalOnProperty、ConditionalOnMissingBean等</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a><strong>用法</strong></h3><p>如下，当容器中存在myPerson组件时，myCola组件才会注册到容器中</p><p><strong>注意，这两个方法的先后顺序是有影响的！下面这样子的结果是myCola被注册到容器了，如果这俩方法换个顺序，myCola就不会被注册进容器！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">myPerson</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(name = &quot;myPerson&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Cola <span class="hljs-title">myCola</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cola();<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，如果@Conditional注解加在类上，那么会决定整个类中的组件是否会被注册进容器。</p><h2 id="5-ImportResource"><a href="#5-ImportResource" class="headerlink" title="5.@ImportResource"></a>5.@ImportResource</h2><p>用来注册<code>xml</code>文件中配置的组件</p><p>例如，下面的<code>beans.xml</code>是上文提到的，在这里引入后，就能注册在容器中</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration(proxyBeanMethods = true)</span><br><span class="hljs-meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColaConfig</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><h2 id="6-ConfigurationProperties"><a href="#6-ConfigurationProperties" class="headerlink" title="6.@ConfigurationProperties"></a>6.@ConfigurationProperties</h2><p>通过<code>application.properties</code>文件来配置组件的一些信息</p><p><strong>注意，组件类必须在容器中才能进行属性绑定</strong></p><p><strong>所以要么在组件类中添加@Component注册它，要么就用配置类去注册它。</strong></p><p><strong>然后在组件类上方添加@ConfigurationProperties，完成属性绑定</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br> <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>在<code>application.properties</code>中设置组件类的属性</p><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">person.id</span>=<span class="hljs-string">123</span><br><span class="hljs-meta">person.name</span>=<span class="hljs-string">whz</span><br></code></pre></td></tr></table></figure><h2 id="7-EnableConfigurationProperties"><a href="#7-EnableConfigurationProperties" class="headerlink" title="7.@EnableConfigurationProperties"></a>7.@EnableConfigurationProperties</h2><p>和⑥相比，把该注解用在注册组件的配置类中，组件类就不用再使用@Component注解了</p><p><strong>这是防止引用第三方的包时，其组件类没有@Component而产生无法进行属性绑定的问题</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = true)</span><br><span class="hljs-meta">@EnableConfigurationProperties(Person.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColaConfig</span> </span>&#123; <span class="hljs-comment">// ... &#125;</span><br><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123; <span class="hljs-comment">// ... &#125;</span><br>    <br></code></pre></td></tr></table></figure><h1 id="四、按需进行自动配置"><a href="#四、按需进行自动配置" class="headerlink" title="四、按需进行自动配置"></a>四、按需进行自动配置</h1><p>上面我们提到了许多用来注册组件的注解</p><p>那么SpringBoot究竟是怎么把这些东西注册进容器的呢，SpringBoot程序的运行离不开主启动类，这个启动类也许包含了更多的信息。</p><p>让我们来研究下主启动类的注解吧。</p><p>首先，<code>@SpringBootApplication</code>内部涉及三个注解，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;@Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="hljs-meta">), @Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)&#125;</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure><ul><li>SpringBootConfiguration<ul><li>内部就是Configuration</li><li>说明主启动类也注册到容器中</li></ul></li><li>ComponentScan<ul><li>用于包扫描</li><li>更多信息可上网查找</li></ul></li><li>EnableAutoConfiguration<ul><li>其中有两个注解比较重要，分别是用来自动配置组件和批量导入组件</li><li>@AutoConfigurationPackage</li><li>@Import({ AutoConfigurationImportSelector.class })</li></ul></li></ul><h2 id="Registrar"><a href="#Registrar" class="headerlink" title="Registrar"></a><strong>Registrar</strong></h2><p>类中的注册组件方法如下：</p><p>通过<code>metadate</code>得到<code>packageNames</code>，然后对一群组件进行注册</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>    AutoConfigurationPackages.register(registry, (String[])(<span class="hljs-keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a><strong>AutoConfigurationImportSelector</strong></h2><p>可以看到，该类中使用<code>getAutoConfigurationEntry()</code>来返回批量的组件信息</p><p>方法内部又调用了<code>getCandidateConfigurations()</code>，而这个方法是通过<code>SpringFactoriesLoader</code>来获得配置</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AutoConfigurationImportSelector.<span class="hljs-function">AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;<br>    <span class="hljs-comment">// 1.判断SpringBoot的自动装配是否打开</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>            <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 2.读取EnableAutoConfiguration注解中的exclude和excludeName</span><br>            AnnotationAttributes attributes = <span class="hljs-keyword">this</span>.getAttributes(annotationMetadata);<br>            <span class="hljs-comment">// 3.读取所有需要自动装配的配置类，在META-INF/spring.factories中</span><br>            List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>            <span class="hljs-comment">// 4.删去不满足条件的</span><br>            configurations = <span class="hljs-keyword">this</span>.removeDuplicates(configurations);                <br>            Set&lt;String&gt; exclusions = <span class="hljs-keyword">this</span>.getExclusions(annotationMetadata, attributes);<br>            <span class="hljs-keyword">this</span>.checkExcludedClasses(configurations, exclusions);<br>            configurations.removeAll(exclusions);<br>            configurations = <span class="hljs-keyword">this</span>.getConfigurationClassFilter().filter(configurations);<br>            <span class="hljs-keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);<br>        &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用Spring的工厂加载器来获取配置</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;<br>        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="hljs-keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-keyword">this</span>.getBeanClassLoader());<br>        Assert.notEmpty(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);<br>        <span class="hljs-keyword">return</span> configurations;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们来到SpringFactoriesLoader类中，可以看到它的核心方法loadSpringFactories()</strong></p><p>分析一下该方法</p><ol><li>判断cache是否是null</li><li>如果cache存在，就直接返回，因为配置项已经加载过</li><li>如果不存在，就从<code>META-INF/spring.factories</code>文件中<strong>读取并加载所有的配置</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;<br>    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Enumeration&lt;URL&gt; urls = classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>);<br>            LinkedMultiValueMap result = <span class="hljs-keyword">new</span> LinkedMultiValueMap();<br><br>            <span class="hljs-keyword">while</span>(urls.hasMoreElements()) &#123;<br>                URL url = (URL)urls.nextElement();<br>                UrlResource resource = <span class="hljs-keyword">new</span> UrlResource(url);<br>                Properties properties = PropertiesLoaderUtils.loadProperties(resource);<br>                Iterator var6 = properties.entrySet().iterator();<br><br>                <span class="hljs-keyword">while</span>(var6.hasNext()) &#123;<br>                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();<br>                    String factoryTypeName = ((String)entry.getKey()).trim();<br>                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());<br>                    <span class="hljs-keyword">int</span> var10 = var9.length;<br><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> var11 = <span class="hljs-number">0</span>; var11 &lt; var10; ++var11) &#123;<br>                        String factoryImplementationName = var9[var11];<br>                        result.add(factoryTypeName, factoryImplementationName.trim());<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            cache.put(classLoader, result);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var13) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>但我们可能会有疑问，如果一次性把所有组件都注册进容器中，会不会多余？并且影响启动的性能</p><p>这时候我们就要用到前面提过的<strong>条件注解</strong>了</p><p><strong>只要我们在组件类中添加相应的条件配置，如<code>@ConditionalOnClass</code>，这样只有引入某个包时，对应的组件才会真正被注册到容器中。</strong></p><h2 id="定制化配置"><a href="#定制化配置" class="headerlink" title="定制化配置"></a>定制化配置</h2><p>如果我们对SpringBoot的默认配置不满意呢，该怎样做到修改它的默认配置</p><p>以下提供了两种方法</p><ol><li>注册自己的Bean，取代默认组件</li><li>通过配置文件<code>application.properties</code>来设置</li></ol><h2 id="定制化配置的实现方式"><a href="#定制化配置的实现方式" class="headerlink" title="定制化配置的实现方式"></a>定制化配置的实现方式</h2><p>我们查看Spring Boot默认加载的组件，会发现以下注解</p><p>就以<code>HttpEncodingAutoConfiguration</code>为例</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span><br></code></pre></td></tr></table></figure><p>这个注解我们之前了解过</p><p>即：该组件把<code>ServerProperties</code>类注册到容器中，同时读取<code>application.properties</code>中对应的属性来赋值。</p><p>所以我们只要直接修改配置文件，就能够使用自己的配置</p><h2 id="查看自动配置"><a href="#查看自动配置" class="headerlink" title="查看自动配置"></a>查看自动配置</h2><p>在<code>application.properties</code>中设置<code>debug=true</code>来开启调试</p><p>这样运行项目后会打印出配置项(<code>positive matches </code>或<code>negative matches</code>)</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门——HelloWorld</title>
      <link href="2021/04/12/SpringBoot/1_HelloWorld/"/>
      <url>2021/04/12/SpringBoot/1_HelloWorld/</url>
      
        <content type="html"><![CDATA[<h3 id="编写Hello-World"><a href="#编写Hello-World" class="headerlink" title="编写Hello World"></a>编写Hello World</h3><ol><li>创建Spring Boot项目</li><li>编写启动类和Controller</li><li>启动项目，访问<code>localhost:8080/hello</code>页面</li></ol><p>即可看到Hello World</p><h3 id="尝试打包"><a href="#尝试打包" class="headerlink" title="尝试打包"></a>尝试打包</h3><ol><li><p>在右侧maven栏中依次选择<code>clean</code>和<code>package</code></p></li><li><p>然后可以在<code>target</code>目录下中看到<code>jar</code>包</p></li><li><p>在该路径下打开cmd（文件路径栏直接输入cmd即可），输入<code>java -jar xxx.jar</code></p></li></ol><p>即运行成功</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序数组</title>
      <link href="2021/04/12/leetcode/3_%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>2021/04/12/leetcode/3_%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h1><p><a href="https://leetcode-cn.com/problems/sort-an-array/">题目请看这里</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>对给定数组进行排序</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用排序算法</p><p>如<strong>归并排序、快速排序、堆排序</strong>等</p><h2 id="代码1：归并排序"><a href="#代码1：归并排序" class="headerlink" title="代码1：归并排序"></a>代码1：归并排序</h2><p>主要过程</p><ol><li>对数组进行划分</li><li>划分到长度小于等于7时，用插入排序</li><li>然后对两个排序好的数组，进行合并</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArray(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, temp);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (right - left &lt; <span class="hljs-number">7</span>) &#123;<br>            insertSort(nums, left, right);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = (right + left) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        mergeSort(nums, left, mid, temp);<br>        mergeSort(nums, mid + <span class="hljs-number">1</span>, right, temp);<br>        <span class="hljs-comment">// 判断划分完毕的数组是否已经有序</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[mid+<span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        merge(nums, left, right, mid, temp);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; ++ i) &#123;<br>            <span class="hljs-keyword">int</span> tmp = nums[i];<br>            <span class="hljs-keyword">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &gt; left &amp;&amp; tmp &lt; nums[j-<span class="hljs-number">1</span>]) &#123;<br>                nums[j] = nums[j-<span class="hljs-number">1</span>];<br>                j--;<br>            &#125;<br>            nums[j] = tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br>        System.arraycopy(nums, left, temp, left, right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> i = left;<br>        <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; ++ k) &#123;<br>            <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>) &#123;<br>                nums[k] = temp[j];<br>                j ++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == right + <span class="hljs-number">1</span> || temp[i] &lt;= temp[j]) &#123;<br>                nums[k] = temp[i];<br>                i ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums[k] = temp[j];<br>                j ++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码2：快速排序"><a href="#代码2：快速排序" class="headerlink" title="代码2：快速排序"></a>代码2：快速排序</h2>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中的逆序对</title>
      <link href="2021/04/12/leetcode/4_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>2021/04/12/leetcode/4_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>逆序</code>即前面的元素大于后面的元素</p><p><strong>求给定数组中逆序对的个数</strong>，注意，可以是不连续的</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>归并排序在合并的过程中，利用两个指针，依次比较得到较小值，插入到数组中</p><p>这一过程正好比较了所有逆序对</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果不熟悉归并排序，建议先了解下归并排序。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<br>        mergeSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, temp, ans);<br>       <br>        <span class="hljs-keyword">return</span> ans[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp, <span class="hljs-keyword">int</span>[] ans)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt;= right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        mergeSort(nums, left, mid, temp, ans);<br>        mergeSort(nums, mid + <span class="hljs-number">1</span>, right, temp, ans);<br><br>        merge(nums, left, right, mid, temp, ans);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span>[] temp, <span class="hljs-keyword">int</span>[] ans)</span> </span>&#123;<br>        System.arraycopy(nums, left, temp, left, right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> i = left;<br>        <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; ++ k) &#123;<br>            <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>) &#123;<br>                nums[k] = temp[j];<br>                j ++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == right + <span class="hljs-number">1</span> || temp[i] &lt;= temp[j]) &#123;<br>                ans[<span class="hljs-number">0</span>] += j - mid - <span class="hljs-number">1</span>;<br>                nums[k] = temp[i];<br>                i ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// temp[i] &gt; temp[j]</span><br>                nums[k] = temp[j];<br>                j ++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的各种概念</title>
      <link href="2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
      <url>2021/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h4 id="一、满二叉树"><a href="#一、满二叉树" class="headerlink" title="一、满二叉树"></a>一、满二叉树</h4><blockquote><p>从根节点到每一个叶子节点，所经过的路径数是相同的</p></blockquote><p>简单来说，就是二叉树是满的</p><h4 id="二、完全二叉树"><a href="#二、完全二叉树" class="headerlink" title="二、完全二叉树"></a>二、完全二叉树</h4><p>除了最后一层，其他都是满的</p><p>而且最后一层的节点必须靠左边</p><h4 id="三、二叉搜索树"><a href="#三、二叉搜索树" class="headerlink" title="三、二叉搜索树"></a>三、二叉搜索树</h4><blockquote><p>1.是一颗二叉树</p><p>2.任意节点的左子树上的节点一定小于该节点，右子树上的节点一定大于该节点</p></blockquote><p>这种树结构适合查找</p><h4 id="四、二叉平衡树"><a href="#四、二叉平衡树" class="headerlink" title="四、二叉平衡树"></a>四、二叉平衡树</h4><p>二叉平衡树又叫做<strong>AVL树</strong></p><p><strong>二叉搜索树在极端情况下会退化成链表，为了防止这种情况出现，提出了平衡树的概念</strong></p><blockquote><p>平衡树是指任意节点的左右子树高度不超过1</p></blockquote><p><strong>这样，我们就可以把二叉搜索树优化成平衡的二叉搜索树。</strong></p><p>注意：二叉平衡树是更加严格的搜索数。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原码、反码和补码</title>
      <link href="2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/"/>
      <url>2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p><strong>符号位 + 数值</strong></p><p>例如：</p><p>+3的原码为<code>00000011</code></p><p>-3的原码为<code>10000011</code></p><p>其中第一位表示<strong>符号位</strong>，0为正，1为负；后面表示<strong>真值的绝对值</strong></p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p><strong>正数：和原码一致，保持不变</strong></p><p><strong>负数：符号位不变，其余位取反</strong></p><p>例如：</p><p>+3的反码为<code>00000011</code></p><p>-3的反码为<code>11111100</code></p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p><strong>正数：和原码一致，保持不变</strong></p><p><strong>负数：反码基础上+1，或者说，符号位不变，其余位取反后，末位加1</strong></p><p>例如：</p><p>+3的补码为<code>00000011</code></p><p>-3的补码为<code>11111101</code></p><h4 id="为什么要有补码？"><a href="#为什么要有补码？" class="headerlink" title="为什么要有补码？"></a>为什么要有补码？</h4><p>首先，看完上面三个概念，我们应该最容易理解原码</p><p><strong>而对计算机来说，还要在最前面判断符号位是一件挺麻烦的事，既耗时又浪费了符号所在位的空间。</strong></p><p>于是人们开始思考能让符号也参与到运算中来，而不是在计算前就要判断正负</p><p><strong>那么先来看看正数和负数的原码相加会有什么结果</strong></p><p>00000011</p><p>10000011</p><p>得到 10000100，这个值转换为十进制就是<code>-4</code></p><p>而<code>+3</code>与<code>-3</code>相加，答案理应是<code>0</code>才对</p><p><strong>原码不行，那么我们再来试试反码</strong></p><p>00000011</p><p>11111100</p><p>得到11111111，注意这是反码表示的，把结果转换成原码就是<code>10000000</code>，即<code>-0</code></p><p>但是这样还是有个问题，即计算结果的符号位没有意义</p><p><strong>于是补码就出现了</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记录</title>
      <link href="2021/04/09/%E5%B7%A5%E5%85%B7/%E8%AE%B0%E5%BD%95/"/>
      <url>2021/04/09/%E5%B7%A5%E5%85%B7/%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>有时候学着学着想起了或者遇到了知识盲区，怕之后忘记，于是就记在这儿</p><ul><li><p><input disabled="" type="checkbox">  堆结构、堆排序</p></li><li><p><input disabled="" type="checkbox">  优先级队列</p></li><li><p><input checked="" disabled="" type="checkbox">  快排</p></li><li><p><input checked="" disabled="" type="checkbox">  归并排序</p></li><li><p><input checked="" disabled="" type="checkbox">  加密算法（MD5，加盐…）</p></li><li><p><input checked="" disabled="" type="checkbox">  原码、反码、补码</p></li><li><p><input disabled="" type="checkbox">  Spring</p><ul><li><input disabled="" type="checkbox"> AOP</li><li><input disabled="" type="checkbox"> IOC</li></ul></li><li><p><input disabled="" type="checkbox">  SpringBoot</p><ul><li><input checked="" disabled="" type="checkbox"> 自动装配</li><li><input disabled="" type="checkbox"> 切面</li><li><input disabled="" type="checkbox"> …</li></ul></li><li><p><input disabled="" type="checkbox">  SpringCloud</p><ul><li><input disabled="" type="checkbox"> …</li></ul></li><li><p><input disabled="" type="checkbox">  transient</p></li><li><p><input disabled="" type="checkbox">  并查集</p></li><li><p><input disabled="" type="checkbox">  线段树</p></li><li><p><input disabled="" type="checkbox">  kmp算法</p></li><li><p><input disabled="" type="checkbox">  看人月神话</p></li><li><p><input disabled="" type="checkbox">  浮点数表示及计算</p></li><li><p><input disabled="" type="checkbox">  图片压缩（博客放图片）</p></li><li><p><input disabled="" type="checkbox">  base64长链转短链</p></li><li><p><input disabled="" type="checkbox">  JVM</p><ul><li><input disabled="" type="checkbox"> 垃圾回收器CMS、G1、ZGC区别、优化</li><li><input disabled="" type="checkbox"> Java工作内存模型</li></ul></li><li><p><input disabled="" type="checkbox">  redis</p><ul><li><input disabled="" type="checkbox"> sortedset</li><li><input disabled="" type="checkbox"> 自增id</li></ul></li><li><p><input disabled="" type="checkbox">  MongDB</p></li><li><p><input disabled="" type="checkbox">  RabbitMQ</p></li><li><p><input disabled="" type="checkbox">  docker</p></li><li><p><input disabled="" type="checkbox">  操作系统</p><ul><li><input disabled="" type="checkbox"> 死锁</li><li><input disabled="" type="checkbox"> 段页式作用</li></ul></li><li><p><input disabled="" type="checkbox">  nginx</p><ul><li><input disabled="" type="checkbox"> 稍微了解一些即可</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子序列</title>
      <link href="2021/04/09/leetcode/2_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2021/04/09/leetcode/2_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">题目请看这里</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长<strong>公共子序列</strong>的长度。</p><p>如果不存在公共子序列，返回 0 。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划，因为存在两个字符串，所以定义二维数组$dp[i][j]$</p><ul><li><strong>当i、j所在位置的字符相等时</strong></li></ul><p>$dp[i][j] = dp[i-1][j-1] + 1$</p><ul><li><strong>不相等时</strong></li></ul><p>$dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])$</p><p><strong>为了方便状态转移，我们定义数组为$dp[n+1][m+1]$，这样$dp[0][j]和dp[i][0]$都是表示空字符串和其他字符串的公共子序列，必定为0</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len1 = text1.length();<br>        <span class="hljs-keyword">int</span> len2 = text2.length();<br>        <span class="hljs-comment">// dp[i][j] 表示下标从[0:i-1]和[0:j-1]的最长公共子序列</span><br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1+<span class="hljs-number">1</span>][len2+<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; ++ j) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i-<span class="hljs-number">1</span>) == text2.charAt(j-<span class="hljs-number">1</span>)) &#123;<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>空间优化</strong></p><p>每次状态转移只和<strong>当前行</strong>、<strong>前一行</strong>相关，所以可以用<strong>两个一维数组</strong>代替二维数组</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len1 = text1.length();<br>        <span class="hljs-keyword">int</span> len2 = text2.length();<br>        <span class="hljs-comment">// dp[i][j] 表示下标从[0:i-1]和[0:j-1]的最长公共子序列</span><br>        <span class="hljs-comment">// 空间优化</span><br>        <span class="hljs-keyword">int</span>[] pre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len2 + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span>[] cur = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len2 + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len1; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= len2; ++ j) &#123;<br>                <span class="hljs-keyword">if</span> (text1.charAt(i-<span class="hljs-number">1</span>) == text2.charAt(j-<span class="hljs-number">1</span>)) &#123;<br>                    cur[j] = pre[j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    cur[j] = Math.max(pre[j], cur[j-<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>            pre = cur.clone();<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur[len2];<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven问题和解决方案记录</title>
      <link href="2021/04/08/%E5%B7%A5%E5%85%B7/maven%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/"/>
      <url>2021/04/08/%E5%B7%A5%E5%85%B7/maven%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一、无脑配镜像"><a href="#一、无脑配镜像" class="headerlink" title="一、无脑配镜像"></a>一、无脑配镜像</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// tmd啥镜像都不用配</span><br></code></pre></td></tr></table></figure><h3 id="二、删除lastupdated文件"><a href="#二、删除lastupdated文件" class="headerlink" title="二、删除lastupdated文件"></a>二、删除lastupdated文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listDirectory</span><span class="hljs-params">(File dir)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">if</span> (!dir.exists())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;目录：&quot;</span> + dir + <span class="hljs-string">&quot;不存在.&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!dir.isDirectory()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(dir + <span class="hljs-string">&quot; 不是目录。&quot;</span>);<br>    &#125;<br>    File[] files = dir.listFiles();<br>    <span class="hljs-keyword">if</span> (files != <span class="hljs-keyword">null</span> &amp;&amp; files.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (File file : files) &#123;<br>            <span class="hljs-keyword">if</span> (file.isDirectory())<br>                <span class="hljs-comment">//递归</span><br>                listDirectory(file);<br>            <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 删除以 lastUpdated 结尾的文件</span><br>                String fileName = file.getName();<br>                <span class="hljs-keyword">boolean</span> isLastupdated = fileName.toLowerCase().endsWith(<span class="hljs-string">&quot;lastupdated&quot;</span>);<br>                <span class="hljs-keyword">if</span> (isLastupdated)&#123;<br>                    <span class="hljs-keyword">boolean</span> is_delete = file.delete();<br>                    System.out.println(<span class="hljs-string">&quot;删除的文件名 =&gt; &quot;</span> + file.getName() + <span class="hljs-string">&quot;  || 是否删除成功？ ==&gt; &quot;</span> + is_delete);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-comment">// 指定maven的本地仓库</span><br>    listDirectory(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;E:\\programs\\mvnrepository&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h3><h5 id="描述1："><a href="#描述1：" class="headerlink" title="描述1："></a>描述1：</h5><blockquote><p>Could not transfer artifact xxx from/to xxx解决方案</p></blockquote><h5 id="解决方案1："><a href="#解决方案1：" class="headerlink" title="解决方案1："></a>解决方案1：</h5><ol><li>用上述工具类删除下载失败的文件</li><li>在<code>pom.xml</code>文件中，右键-&gt;Maven-&gt;reload project</li><li>完美运行</li></ol><h5 id="解决方案2："><a href="#解决方案2：" class="headerlink" title="解决方案2："></a>解决方案2：</h5><p>删除文件不用多说</p><p>然后在终端输入以下命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mvn clean &amp;&amp; mvn compile -Dmaven.wagon.http.ssl.insecure=<span class="hljs-literal">true</span> -Dmaven.wagon.http.ssl.allowall=<span class="hljs-literal">true</span> -Dmaven.wagon.http.ssl.ignore.validity.dates=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>然后刷新试试（注意，maven没有配置镜像，裸连）</p><hr><h5 id="描述2："><a href="#描述2：" class="headerlink" title="描述2："></a>描述2：</h5><p>出现SSL证书问题</p><h5 id="解决方案2：-1"><a href="#解决方案2：-1" class="headerlink" title="解决方案2："></a>解决方案2：</h5><p>最简单粗暴的，在终端输入</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mvn clean &amp;&amp; mvn compile -Dmaven.wagon.http.ssl.insecure=<span class="hljs-literal">true</span> -Dmaven.wagon.http.ssl.allowall=<span class="hljs-literal">true</span> -Dmaven.wagon.http.ssl.ignore.validity.dates=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>如果显示<strong>无法识别mvn命令</strong>，那就是<strong>环境变量</strong>没配置对，重新去配下maven的环境变量</p><p><a href="https://blog.csdn.net/qq_22041375/article/details/103491941">剩余方法参考这里</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摆动序列</title>
      <link href="2021/04/08/leetcode/1_%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
      <url>2021/04/08/leetcode/1_%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h1><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">题目请看这里</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>连续数字的差在正数和负数之间交替，则数字序列就称为<strong>摆动序列</strong></p></blockquote><p>给定整数序列，返回其摆动序列的最长长度。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>[1,7,4,9,2,5]是长度为6的摆动序列</p><h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>定义两种状态，分别为up[i]和down[i]</p><p>遍历时分别进行状态转移，最后返回两者中的较大值。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><span class="hljs-keyword">int</span> len = nums.length;<br><span class="hljs-keyword">int</span>[] up = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br><span class="hljs-keyword">int</span>[] down = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br><span class="hljs-comment">// init</span><br>up[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; down[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[i-<span class="hljs-number">1</span>]) &#123;<br>            up[i] = up[i-<span class="hljs-number">1</span>];<br>            down[i] = down[i-<span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i-<span class="hljs-number">1</span>]) &#123;<br>            down[i] = down[i-<span class="hljs-number">1</span>];<br>            up[i] = Math.max(down[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, up[i-<span class="hljs-number">1</span>]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            up[i] = up[i-<span class="hljs-number">1</span>];<br>            down[i] = Math.max(up[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, down[i-<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.max(up[len-<span class="hljs-number">1</span>], down[len-<span class="hljs-number">1</span>]);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>空间优化</strong></p><p>因为每次状态转移只和上一次相关，所以可以用变量代替数组</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> up = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> down = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; ++ i) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i-<span class="hljs-number">1</span>]) &#123;<br>        up = down + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i-<span class="hljs-number">1</span>]) &#123;<br>        down = up + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> Math.max(up, down);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="解法二：贪心"><a href="#解法二：贪心" class="headerlink" title="解法二：贪心"></a>解法二：贪心</h2><p>忽略谷和峰之间的数字，每次发生摆动时，才进行加一</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> len = nums.length;<br>      <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> len;<br><span class="hljs-comment">// 从头开始，找到前后不相同的元素</span><br>      <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (index &lt; len &amp;&amp; nums[index] == nums[index-<span class="hljs-number">1</span>]) index ++;<br>      <span class="hljs-keyword">if</span> (index == len) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 初始化</span><br>      <span class="hljs-keyword">boolean</span> isUp = nums[index] - nums[index-<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">int</span> count = <span class="hljs-number">2</span>;<br>      <span class="hljs-comment">// 开始计数</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = index + <span class="hljs-number">1</span>; i &lt; len; ++ i) &#123;<br>          <span class="hljs-keyword">if</span> ((nums[i] &gt; nums[i-<span class="hljs-number">1</span>] &amp;&amp; !isUp) || (nums[i] &lt; nums[i-<span class="hljs-number">1</span>] &amp;&amp; isUp)) &#123;<br>              count ++;<br>              isUp = !isUp;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> count;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(四).阻塞队列介绍</title>
      <link href="2021/04/07/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
      <url>2021/04/07/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="一、回顾"><a href="#一、回顾" class="headerlink" title="一、回顾"></a>一、回顾</h3><p>从上一篇笔记中，我们了解了线程池对线程的复用机制，就让我们再好好回顾下吧。</p><blockquote><p>Executor中的线程在执行完自己的任务后，还会通过getTask()方法主动向阻塞队列获取任务</p><p>对于核心线程来说，它是用take()来阻塞地获取任务</p><p>而非核心线程是通过poll()来获取任务，如果超时，则放弃获取</p></blockquote><p>正是这样的机制，才使得核心线程一直存在于线程池中，而非核心线程空闲到了存活时间就会被销毁。</p><h3 id="二、架构分析"><a href="#二、架构分析" class="headerlink" title="二、架构分析"></a>二、架构分析</h3><p>上面还涉及到了一个很重要的问题，就是从阻塞队列获取任务。</p><p><strong>那么阻塞队列是怎样设计的呢？就让我们来看看它的结构吧</strong></p><h4 id="1-BlockingQueue"><a href="#1-BlockingQueue" class="headerlink" title="1.BlockingQueue"></a>1.BlockingQueue</h4><p>可以看到，它继承了Queue接口，那肯定少不了队列的一些常规方法</p><p>但我们要看的是阻塞队列提供的一些其他方法，下面一一介绍</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BlockingQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//省略队列的一些常规方法，如add()、offer()等</span><br>    <br>    <span class="hljs-comment">// 放入元素，会阻塞</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-comment">// 放入元素，超时后放弃</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <br>    <span class="hljs-comment">// 获取元素,会阻塞</span><br><span class="hljs-function">E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;   <br>    <span class="hljs-comment">// 获取元素，超时后放弃</span><br>    <span class="hljs-function">E <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <br>    <span class="hljs-comment">// 返回队列剩余大小 </span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remainingCapacity</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 删除队列中的所有元素，并移动到指定集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">drainTo</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">super</span> E&gt; c)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">方法</th><th align="center">类型</th><th align="center">策略</th></tr></thead><tbody><tr><td align="center">put</td><td align="center">+</td><td align="center">阻塞</td></tr><tr><td align="center">offer</td><td align="center">+</td><td align="center">超时机制</td></tr><tr><td align="center">take</td><td align="center">-</td><td align="center">阻塞</td></tr><tr><td align="center">poll</td><td align="center">-</td><td align="center">超时机制</td></tr></tbody></table><p>上面的<strong>BlockingQueue</strong>只是定义了接口，那么我们看看它是具体怎么实现的吧</p><p>从下图中我们发现有许多队列实现了<strong>BlockingQueue</strong>，下面我们挑几个讲讲</p><p><img src= "/img/loading.gif" data-lazy-src="/images/blocking_queue_1.PNG"></p><hr><h4 id="2-ArrayBlockingQueue"><a href="#2-ArrayBlockingQueue" class="headerlink" title="2.ArrayBlockingQueue"></a>2.ArrayBlockingQueue</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(capacity, <span class="hljs-keyword">false</span>);<span class="hljs-comment">// 默认创建的锁是非公平的</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123; <span class="hljs-comment">// fair表示锁是否公平</span><br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>    <span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> Object[capacity];<br>    lock = <span class="hljs-keyword">new</span> ReentrantLock(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair,</span></span><br><span class="hljs-function"><span class="hljs-params">                          Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(capacity, fair);<br><br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;                 <span class="hljs-comment">// 把给定集合中的元素添加到数组中</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (E e : c) &#123;<br>                checkNotNull(e);<br>                items[i++] = e;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        &#125;<br>        count = i;<br>        putIndex = (i == capacity) ? <span class="hljs-number">0</span> : i;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a><strong>成员变量</strong></h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 用数组来存放元素</span><br><span class="hljs-keyword">final</span> Object[] items;<br><br><span class="hljs-comment">// 表示队列头部的下标，每次取元素时用。</span><br><span class="hljs-comment">// take, poll, peek or remove</span><br><span class="hljs-keyword">int</span> takeIndex;<br><br><span class="hljs-comment">// 表示插入新元素所在的下标</span><br><span class="hljs-comment">// put, offer, or add</span><br><span class="hljs-keyword">int</span> putIndex;<br><br><span class="hljs-keyword">int</span> count;<br><br><br><span class="hljs-comment">/** 使用经典的教科书式的 two-condition 算法 | 但我不会啊，我又没看过  */</span><br><br><span class="hljs-keyword">final</span> ReentrantLock lock;<br><span class="hljs-comment">// 取元素时的条件</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><span class="hljs-comment">// 放元素时的条件</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br><br><span class="hljs-comment">// 当前迭代器的共享状态</span><br><span class="hljs-keyword">transient</span> Itrs itrs = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p><strong>首先，对外的添加元素方法有</strong></p><ol><li>add(E) </li><li>offer(E) </li><li>put(E)</li><li>offer(E, long, TimeUnit)</li></ol><p><strong>而这些方法内部实际都用调用enqueue(E)</strong></p><p>那么就先来看看enqueue方法，大致思路还是很简单的，如下：</p><blockquote><p>在指定位置放入元素，然后<strong>putIndex</strong>加一</p><p>当<strong>putIndex</strong>等于数组长度时，令它为0，从头开始添加元素</p><p>最后唤醒一个在<strong>notEmpty</strong>的等待队列中的线程（删除元素的线程，因为阻塞队列为空，所以等在notEmpty的队列中）</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E x)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;<br>    items[putIndex] = x;<br>    <span class="hljs-keyword">if</span> (++putIndex == items.length)<br>        putIndex = <span class="hljs-number">0</span>;<br>    count++;<br>    notEmpty.signal();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接下来看看put(E)和offer(E, long, TimeUnit)</strong></p><p>put()的思路也很清晰：</p><ol><li>进行非空判断后，加锁</li><li>然后判断队列是否满，如果满了就让当前线程进入notFull的等待队列中</li><li>如果没有满，则添加元素</li><li>解锁</li></ol><p>和put()相比，offer()在循环体中加入了是否超时的判断</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            notFull.await(); <br>        enqueue(e); <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e, <span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    checkNotNull(e);<br>    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout); <span class="hljs-comment">// 根据超时的时间长度和单位，换算成纳秒级别</span><br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == items.length) &#123;<br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)             <span class="hljs-comment">// 判断是否超时</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            nanos = notFull.awaitNanos(nanos);<br>        &#125;<br>        enqueue(e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><p>老规矩，先介绍下对外方法</p><ol><li>peek()</li><li>remove(Object)</li><li>poll()</li><li>poll(long, TimeUnit)</li><li>take()</li></ol><p>peek()返回<strong>takeIndex</strong>所在位置的元素，不作删除</p><p>remove(Object)从<strong>takeIndex</strong>开始向<strong>putIndex</strong>遍历，找到第一个匹配的元素，删除掉，然后更新元素位置</p><p>后面三个方法都用到了<strong>dequeue()</strong></p><p><strong>那来看看这个方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>  <br>    <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    E x = (E) items[takeIndex]; <br>    items[takeIndex] = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (++takeIndex == items.length)<br>        takeIndex = <span class="hljs-number">0</span>;<br>    count--;<br>    <span class="hljs-keyword">if</span> (itrs != <span class="hljs-keyword">null</span>)<br>        itrs.elementDequeued();<br>    notFull.signal();<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接下来看看poll(), take(), poll(long, TimeUnit)方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> (count == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">null</span> : dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果阻塞队列为空，就把当前线程加入到notEmpty的等待队列中，等待唤醒</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>            notEmpty.await();<br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在take()的基础上添加了超时判断</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">long</span> nanos = unit.toNanos(timeout);<br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            nanos = notEmpty.awaitNanos(nanos);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dequeue();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="3-DelayQueue"><a href="#3-DelayQueue" class="headerlink" title="3.DelayQueue"></a>3.DelayQueue</h4><h5 id="构造方法及属性"><a href="#构造方法及属性" class="headerlink" title="构造方法及属性"></a>构造方法及属性</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelayQueue</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelayQueue</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.addAll(c);<br>&#125;<br><span class="hljs-keyword">private</span> Thread leader = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;E&gt;();<br></code></pre></td></tr></table></figure><p>可以发现，<strong>DelayQueue</strong>的一些特点</p><ul><li>使用Java的<strong>优先级队列</strong>来存储元素</li><li>使用<strong>Leader-Follower</strong>模式处理任务</li></ul>]]></content>
      
      
      <categories>
          
          <category> 线程和线程池 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速导航</title>
      <link href="2021/04/07/%E5%B7%A5%E5%85%B7/%E5%AF%BC%E8%88%AA/"/>
      <url>2021/04/07/%E5%B7%A5%E5%85%B7/%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<h4 id="导航链接"><a href="#导航链接" class="headerlink" title="导航链接"></a>导航链接</h4><ul><li><a href="https://mermaid-js.github.io/mermaid/#/">美人鱼</a></li></ul><p>可以方便地在博客中绘制类图、甘特图、时序图等</p><ul><li><a href="https://console.leancloud.app/apps">LeanCloud</a></li></ul><p>管理发布的说说</p><ul><li><p><a href="https://www.jianshu.com/p/e74eb43960a1">MarkDown数学公式</a></p></li><li><p><a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-source.md">SpringCloud中文文档</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>养眼</title>
      <link href="2021/04/07/%E5%B7%A5%E5%85%B7/%E5%85%BB%E7%9C%BC/"/>
      <url>2021/04/07/%E5%B7%A5%E5%85%B7/%E5%85%BB%E7%9C%BC/</url>
      
        <content type="html"><![CDATA[<div class="justified-gallery"><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg"><br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg"><br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg"><br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg"><br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg"><br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg"><br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg"><br><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg"></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>I/O模型</title>
      <link href="2021/04/06/TODO/IO%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/04/06/TODO/IO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="1-传统IO模型"><a href="#1-传统IO模型" class="headerlink" title="1. 传统IO模型"></a>1. 传统IO模型</h4><p>是阻塞式的，服务器监听客户端的请求</p><p>每来一个连接请求，服务器就创建一个线程去执行该请求</p><p>当请求数量较大时，需要创建非常多的线程，资源耗费大</p><p>而且它使用字节流的形式传输数据，效率不高</p><h4 id="2-NIO模型"><a href="#2-NIO模型" class="headerlink" title="2. NIO模型"></a>2. NIO模型</h4><p>又叫做非阻塞式IO，由<strong>信道、选择器、缓冲区</strong>构成</p><ul><li>Channel</li></ul><p>是传统 IO Stream 流的升级版，支持双向传输</p><ul><li>Selector</li></ul><p>从线程池中选择线程，来执行多个注册在它上的信道。</p><p>通过一定的选择机制，实现了IO多路复用</p><ul><li>Buffer</li></ul><p>缓冲可以看作一块内存区域，先写入，后读取</p><h4 id="3-NIO的优势"><a href="#3-NIO的优势" class="headerlink" title="3. NIO的优势"></a>3. NIO的优势</h4><ol><li>IO是面向流的，只能按字节读取数据，并且只能从一端读到另一端，不能前后移动流中的数据</li></ol><p>而NIO是面向缓冲区的，可以读取一块区域</p><ol start="2"><li>IO是阻塞的，这意味着，当一个线程读取数据或写数据时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，在此期间该线程不能干其他任何事情。而NIO是非阻塞的，不需要一直等待操作完成才能干其他事情，而是在等待的过程中可以同时去做别的事情，所以能最大限度地使用服务器的资源。</li><li>NIO引入了IO多路复用器selector。selector是一个提供channel注册服务的线程，可以同时对接多个Channel，并在线程池中为channel适配、选择合适的线程来处理channel。由于NIO模型中线程数量大大降低，线程切换效率因此也大幅度提高。</li></ol>]]></content>
      
      
      <categories>
          
          <category> todolist </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/06/HelloWorld/"/>
      <url>2021/04/06/HelloWorld/</url>
      
        <content type="html"><![CDATA[<h1 id="记录博客用法"><a href="#记录博客用法" class="headerlink" title="记录博客用法"></a>记录博客用法</h1><h2 id="一、按钮"><a href="#一、按钮" class="headerlink" title="一、按钮"></a>一、按钮</h2><h3 id="1-描述"><a href="#1-描述" class="headerlink" title="1.描述"></a>1.描述</h3><blockquote><p>点击按钮后，显示隐藏的内容</p></blockquote><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">&#123;% hideInline content,display,bg,color %&#125;<br></code></pre></td></tr></table></figure><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h3><p>哪个英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">C(因为西装裤)</span></span></p><h2 id="二、文章front-matter"><a href="#二、文章front-matter" class="headerlink" title="二、文章front-matter"></a>二、文章front-matter</h2><h3 id="1-描述-1"><a href="#1-描述-1" class="headerlink" title="1.描述"></a>1.描述</h3><p>用来表示文章的一些信息，如标题、类别、tag和封面等</p><h3 id="2-用法-1"><a href="#2-用法-1" class="headerlink" title="2.用法"></a>2.用法</h3><table><thead><tr><th align="center">键</th><th align="center">值（例子）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">Hello World</td><td align="center">文章标题</td></tr><tr><td align="center">categories</td><td align="center">线程池</td><td align="center">文章类别所属</td></tr><tr><td align="center">tags</td><td align="center">-tag: 源码</td><td align="center">文章标签，可包含多个</td></tr><tr><td align="center">cover</td><td align="center"><a href="https://gitee.com/aurora1004/pictures/raw/master/wps.jpg">https://gitee.com/aurora1004/pictures/raw/master/wps.jpg</a></td><td align="center">文章外封面</td></tr><tr><td align="center">top_img</td><td align="center"><a href="https://gitee.com/aurora1004/pictures/raw/master/wps.jpg">https://gitee.com/aurora1004/pictures/raw/master/wps.jpg</a></td><td align="center">文章内部，顶部图片</td></tr><tr><td align="center">top</td><td align="center">100</td><td align="center">权重值，越大越容易置顶</td></tr></tbody></table><h2 id="三、代码配色修改"><a href="#三、代码配色修改" class="headerlink" title="三、代码配色修改"></a>三、代码配色修改</h2><h3 id="1-描述-2"><a href="#1-描述-2" class="headerlink" title="1.描述"></a>1.描述</h3><p>通过引入外部css文件来修改代码配色</p><h3 id="2-用法-2"><a href="#2-用法-2" class="headerlink" title="2.用法"></a>2.用法</h3><p>1.选择一个想要的样式文件，网址：<a href="https://github.com/highlightjs/highlight.js/tree/main/src/styles">代码配色相关css</a></p><p>2.在<code>\butterfly\source\self</code>路径下新建一个<code>css</code>文件（如<code>code1.css</code>），复制第一步中选择的<code>css代码</code></p><p>3.<code>code1.css</code>文件中添加以下代码</p><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 颜色可自己设置 */</span><br><span class="hljs-selector-pseudo">:root</span> &#123;<br>  --hl-<span class="hljs-attribute">color</span>: <span class="hljs-number">#d3af86</span>;<br>  --hl-bg: <span class="hljs-number">#221a0f</span>;<br>  --hltools-bg: <span class="hljs-number">#321a0f</span>;<br>  --hltools-<span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  --hlnumber-bg: <span class="hljs-number">#221a0f</span>;<br>  --hlnumber-<span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  --hlscrollbar-bg: <span class="hljs-number">#d3af86</span>;<br>  --hlexpand-bg: <span class="hljs-number">#d3af86</span>;<br>&#125; <br><br><span class="hljs-comment">/* 更改的內容 把.hljs改為 #article-container figure.highlight .hljs */</span><br>进行更改！！！！！<br></code></pre></td></tr></table></figure><p>4.在butterfly主题的配置文件中引入该css文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># ...</span><br><span class="hljs-attr">inject:</span><br>  <span class="hljs-attr">head:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&lt;link</span> <span class="hljs-string">rel=&quot;stylesheet&quot;</span> <span class="hljs-string">href=&quot;/self/code1.css&quot;&gt;</span>    <br></code></pre></td></tr></table></figure><h2 id="四、hexo相关命令"><a href="#四、hexo相关命令" class="headerlink" title="四、hexo相关命令"></a>四、hexo相关命令</h2><h3 id="1-本地启动博客"><a href="#1-本地启动博客" class="headerlink" title="1.本地启动博客"></a>1.本地启动博客</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hexo s<br></code></pre></td></tr></table></figure><h3 id="2-上传GitHub"><a href="#2-上传GitHub" class="headerlink" title="2.上传GitHub"></a>2.上传GitHub</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><h3 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h3><p>如果遇到如下报错</p><blockquote><p>OpenSSL SSL_read: Connection was reset, errno 10054</p></blockquote><p>则在bash中输入以下代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git config --global http.sslVerify <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure><p>然后重新来一遍即可。</p><h3 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">fatal: unable to access <span class="hljs-string">&#x27;https://github.com/Aurora-Ze/Aurora-Ze.github.io.git/&#x27;</span>: Failed to connect to github.com port 443: Timed out<br><br>err: Error: Spawn failed<br></code></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><ol><li>删除<code>.deploy_git</code>文件夹</li><li>执行命令<code>git config --global core.autocrlf false</code></li><li>重新来一套部署命令</li></ol><h2 id="五、常用数学公式"><a href="#五、常用数学公式" class="headerlink" title="五、常用数学公式"></a>五、常用数学公式</h2><h3 id="1-上标下标"><a href="#1-上标下标" class="headerlink" title="1.上标下标"></a>1.上标下标</h3><p>上标用<code>^</code>表示，下标用<code>_</code>表示；例如，$2^3_3$</p><h3 id="2-大于等于……"><a href="#2-大于等于……" class="headerlink" title="2.大于等于……"></a>2.大于等于……</h3><p>大于等于用<code>\geq\</code>；例如$4 \geq\ 3$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>(二).线程的返回结果</title>
      <link href="2021/04/05/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/"/>
      <url>2021/04/05/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>严肃脸.jpg</strong>: Java实现线程三种方式是哪三种？</p><p><strong>答</strong>: Thread、Runnable、Callable</p><p>其中Runnable接口定义的run方法是没有返回参数的，那么这样看来：</p><p><strong>Java的线程想要返回结果，就需要用到实现Callable接口的对象。</strong></p><p>那我们来看看这个接口</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> computed result</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception if unable to compute a result</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>里面只定义了一个call()方法，返回的是泛型。</p><p>注释里提到，既可以是<strong>返回结果</strong>，也可以是<strong>抛出异常</strong></p><hr><p><img src= "/img/loading.gif" data-lazy-src="/images/executor_1.PNG"></p><p><strong>上面这张图能够方便我们了解线程池各类的关系。</strong></p><p>另外，我们一般是用线程池的方式来创建线程执行任务。</p><p><strong>所以再来看看线程池提供的方法吧</strong></p><p>如果看过上一篇笔记，我们就可以知道：线程池提供了submit()方法</p><ul><li>它是由<strong>ExecutorService</strong>接口定义的具有返回值的方法</li><li>并且返回值是<strong>Future</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java">&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span></span>;<br><br>&lt;T&gt; <span class="hljs-function">Future&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(Runnable task, T result)</span></span>;<br><br>Future&lt;?&gt; submit(Runnable task);<br></code></pre></td></tr></table></figure><p>如上所示，该接口定义了三个submit()方法</p><p>有没有发现特别的地方，就是它居然能传进来<strong>Runnable</strong>对象！而我们之前所了解到的是Runnable对象是无法返回结果的。</p><p><strong>那么它是怎么做到的呢？</strong></p><p>那就要来到<strong>ExecutorService</strong>的实现类了，即<strong>AbstractExecutorService</strong></p><p>我们就随便挑一个传Runnable对象的方法<del>（总共不是有两个嘛）</del></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-keyword">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，里面创建了一个<strong>RunnableFuture</strong>对象，接下来让我<strong>无脑推理一波：</strong></p><p>$RunnableFuture = Runnable + Future$</p><p>所以这个类就是实现了两个接口，那么它既能被当作<strong>Runnable</strong>对象去执行，又能当作<strong>Future</strong>对象来返回</p><p>这样子就说得通了。</p><p><strong>既然Future是返回结果类型，那么我们再去看看它是咋样的吧</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br><br><span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br></code></pre></td></tr></table></figure><p>可以看到，里面就只有5个方法，这可太简单了是不是</p><p>而且这些方法看方法名就知道它是干啥了，就不用我多说了吧</p><p><strong>这里就讲一点：</strong></p><p>无参数的get()会一直阻塞地等待返回结果</p><p>有参数的，则会在超时时间后放弃等待</p>]]></content>
      
      
      <categories>
          
          <category> 线程和线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(三).Executor框架介绍</title>
      <link href="2021/04/03/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2021/04/03/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/20210430161315.PNG" alt="executor_1"></p><h2 id="一、好处"><a href="#一、好处" class="headerlink" title="一、好处"></a>一、好处</h2><p>Executor是Java提供的线程池框架</p><p>首先，介绍一下使用线程池的好处：</p><ol><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程的可管理性</li></ol><p>另外，还能避免<strong>this逃逸问题</strong></p><blockquote><p>即在构造器完成构造前，将自身的<strong>this</strong>引用向外抛出，并被其他线程获取到，这样其他线程有可能<strong>访问</strong>还<strong>未初始化</strong>的变量</p><p>详情请转至<a href="https://www.cnblogs.com/jian0110/p/9369096.html">https://www.cnblogs.com/jian0110/p/9369096.html</a></p></blockquote><h2 id="二、组成"><a href="#二、组成" class="headerlink" title="二、组成"></a>二、组成</h2><h3 id="1-任务"><a href="#1-任务" class="headerlink" title="1.任务"></a>1.任务</h3><p>任务有内外之分</p><p><strong>外部的任务</strong>是指实现了Runnable接口的类，使用的时候把该类对象传进去，就会执行重写的run方法</p><p>传进去后，线程池会把该对象包装成Worker内部类的形式</p><h3 id="2-任务的执行"><a href="#2-任务的执行" class="headerlink" title="2.任务的执行"></a>2.任务的执行</h3><p>执行的方式有两种，一种是直接调用<strong>execute()<strong>，这是</strong>Executor接口</strong>提供的方法</p><p>另一种是调用<strong>ExecutorService</strong>提供的**submit()**，它实际上也是调用前者执行的，区别在于它具有返回值，返回了一个Future对象。</p><h3 id="3-结果"><a href="#3-结果" class="headerlink" title="3.结果"></a>3.结果</h3><p>调用submit执行的话，会返回结果对象，它是实现Future接口的对象。</p><hr><h2 id="三、执行流程图"><a href="#三、执行流程图" class="headerlink" title="三、执行流程图"></a>三、执行流程图</h2><p>执行流程如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/20210430161525.png" alt="executor_2"></p><p><strong>1.<strong>主线程创建实现</strong>Runnable</strong>或<strong>Callable</strong>接口的对象</p><p><strong>2.<strong>把对象交给</strong>Executor Service</strong>的<strong>execute</strong>或<strong>submit</strong>方法，去执行</p><p><strong>3.<strong>如果是采用submit的方式执行，那么会返回一个</strong>Future</strong>或<strong>Future Task</strong>对象</p><p>**4.**主线程可以执行FutureTask.get()来等待任务完成，也可以调用FutureTask.cancel()来取消任务</p><hr><h2 id="四、ThreadPoolExecutor类介绍"><a href="#四、ThreadPoolExecutor类介绍" class="headerlink" title="四、ThreadPoolExecutor类介绍"></a>四、ThreadPoolExecutor类介绍</h2><p><strong>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</strong></p><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h3><p>共有四个构造方法，内部实际上都是用的同一个，如下</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,      // 核心线程数  一旦超过这个数，任务就会被添加到队列中等待</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,   // 最大线程数</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime,    // 存活的最长时间（指核心线程数之外的线程空闲后的存活时间）</span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit, // 时间单位</span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory, // 工厂</span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span>&#123; <span class="hljs-comment">//拒绝策略</span><br>                          <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">corePoolSize</td><td align="center">核心线程数</td></tr><tr><td align="center">maximumPoolSize</td><td align="center">线程池最大线程数，当阻塞队列满时，线程数会从核心线程数变成最大线程数</td></tr><tr><td align="center">keepAliveTime</td><td align="center">非核心线程没有任务执行时的存活时间</td></tr><tr><td align="center">unit</td><td align="center">存活时间的单位</td></tr><tr><td align="center">workQueue</td><td align="center">阻塞队列</td></tr><tr><td align="center">threadFactory</td><td align="center">线程工厂，默认是Executors工具类提供的默认工厂，也可以自己实现ThreadFactory接口</td></tr><tr><td align="center">handler</td><td align="center">拒绝策略</td></tr></tbody></table><h3 id="2-状态"><a href="#2-状态" class="headerlink" title="2.状态"></a>2.状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;      <span class="hljs-comment">// 32 - 3 = 29</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY   = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 2^29 - 1，即左边29个1</span><br><span class="hljs-comment">// 可以看出，状态是有序的，从小到大</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;   <span class="hljs-comment">// -1补码表示为 111 </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//  0补码表示为 000 </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;   <span class="hljs-comment">//  1补码表示为 001 </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;   <span class="hljs-comment">//  2补码表示为 010 </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;   <span class="hljs-comment">//  3补码表示为 011 </span><br><br><span class="hljs-comment">// int共有32位</span><br><span class="hljs-comment">// 前3位表示状态，后29位表示线程数量</span><br></code></pre></td></tr></table></figure><p><strong>状态说明如下</strong></p><table><thead><tr><th align="center">状态</th><th align="center">描述</th><th align="center">数值</th><th>结构</th></tr></thead><tbody><tr><td align="center"><strong>Running</strong></td><td align="center">接受新任务并处理工作队列中的任务</td><td align="center">$-2^{29}$</td><td>$111+29个0$</td></tr><tr><td align="center"><strong>Shutdown</strong></td><td align="center">不接受新任务，但仍处理队列中的任务</td><td align="center">$0$</td><td>$000+29个0$</td></tr><tr><td align="center"><strong>Stop</strong></td><td align="center">不接受新任务，也不处理队列中的任务，中断正在执行的任务</td><td align="center">$2^{29}$</td><td>$001+29个0$</td></tr><tr><td align="center"><strong>Tidying</strong></td><td align="center">任务已经终止，正在工作的线程数为0。线程来到这个状态时，会执行terminated()</td><td align="center">$2^{30}$</td><td>$010+29个0$</td></tr><tr><td align="center"><strong>Terminated</strong></td><td align="center">完成terminated()后进入此状态</td><td align="center">$3\times2^{29}$</td><td>${011}+29个0$</td></tr></tbody></table><p>执行的<strong>流程</strong>如下所示</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/20210430161844.png" alt="executor_3"></p><hr><h2 id="五、两种创建线程池的方式"><a href="#五、两种创建线程池的方式" class="headerlink" title="五、两种创建线程池的方式"></a>五、两种创建线程池的方式</h2><p>Java提供了Executors工具类来快捷的创建线程池，主要有四种</p><p>但这是<strong>不推荐</strong>的做法。</p><table><thead><tr><th align="left">线程池</th><th align="left">描述</th><th align="center">特点</th></tr></thead><tbody><tr><td align="left">①newFixedThreadPool</td><td align="left">固定大小，当线程不够时，任务就会放入到队列中等待</td><td align="center">队列容量大，线程一直存在，直到显式的调用shutdown</td></tr><tr><td align="left">②newSingleThreadExecutor</td><td align="left">只有一个线程存在，当它终止时，就会产生一个新的线程去代替它</td><td align="center">队列容量大</td></tr><tr><td align="left">③newScheduledThreadPool</td><td align="left">可以指定一段延迟时间，来让线程执行</td><td align="center">允许创建的线程数大</td></tr><tr><td align="left">④newCachedThreadPool</td><td align="left">根据需要创建线程，没有使用的线程在60秒后会终止并移出线程池</td><td align="center">允许创建的线程数大</td></tr></tbody></table><p>从上面可以看出：</p><ol><li>①②的工作队列容量是Integer.MAX_VALUE，当任务较多时可能会出现OOM</li><li>③④允许创建的线程数量为Integer.MAX_VALUE，创建线程较多时，会出现OOM</li></ol><p>其实<strong>Executors</strong>提供的<strong>四种创建</strong>线程池的方法，实际上是调用的<strong>ThreadPoolExecutor</strong>的构造方法</p><p>所以推荐使用<strong>ThreadPoolExecutor</strong>来<strong>手动配置</strong>线程池参数。</p><hr><h2 id="六、线程池大小"><a href="#六、线程池大小" class="headerlink" title="六、线程池大小"></a>六、线程池大小</h2><p>上面我们知道了应该<strong>手动创建</strong>线程池，那么线程池的大小该如何选择呢？</p><p>在这之前先介绍一下<strong>上下文切换</strong>的概念</p><h3 id="1-上下文切换"><a href="#1-上下文切换" class="headerlink" title="1.上下文切换"></a>1.上下文切换</h3><p><strong>背景</strong></p><blockquote><p>一个<strong>CPU核心</strong>在任意一个时刻<strong>只能</strong>由一个线程使用</p><p>而线程的数量是比CPU核心数要多的</p><p>所以我们一般采取的策略是<strong>时间片轮转</strong>来为每个线程执行。</p></blockquote><p><strong>定义</strong></p><blockquote><p>当一个线程的时间片用完后，就会把CPU让给其他线程执行</p><p>在切换的过程中，我们需要保存当前任务的状态，以便下次切换回来时，可以很快地加载状态，这就叫<strong>上下文切换</strong>。</p></blockquote><p>那么<strong>上下文切换</strong>和<strong>线程池的大小</strong>有什么关系呢？且听我慢慢道来。</p><p>如果线程池大小设置的<strong>过大</strong>，就会有很多线程在<strong>竞争</strong>CPU资源，<strong>上下文切换</strong>就会变得更加<strong>频繁</strong>，因此开销也会增大</p><p>如果<strong>过小</strong>，当遇到大量任务出现的情景时，就会造成任务堆积，甚至OOM</p><h3 id="2-简单的公式"><a href="#2-简单的公式" class="headerlink" title="2.简单的公式"></a>2.简单的公式</h3><p>假设 <code>n</code> 表示<strong>CPU</strong>核心数</p><ul><li>CPU密集型任务 $n+1$ </li></ul><p>这些任务主要消耗的是CPU的计算资源（计算、排序等），把线程池大小设置成核心数加1</p><p>这样可以防止某个线程暂停时，CPU空闲下来的情况，或者是防止线程偶发的缺页中断。</p><ul><li>I/O密集型任务 $2n$</li></ul><p>这类任务大部分时间都在进行I/O操作，在这段时间内，CPU可以交给其他线程去执行，所以可以多配一些线程</p><p>因为如果线程数较小的话，可能大部分线程都在执行I/O，那么CPU利用率就会降低。</p><hr><h2 id="七、线程复用（源码分析）"><a href="#七、线程复用（源码分析）" class="headerlink" title="七、线程复用（源码分析）"></a>七、线程复用（源码分析）</h2><h3 id="什么是线程复用？"><a href="#什么是线程复用？" class="headerlink" title="什么是线程复用？"></a><strong>什么是线程复用？</strong></h3><blockquote><p>以前使用Thread类去创建线程时，当线程执行完任务后，就会被销毁，就算把它挂起了，也处理不了其他任务。</p><p>而Executor框架提供的线程池，可以让一个线程在执行完任务后，再去执行其他任务，这就叫做<strong>线程复用</strong>。</p></blockquote><p>ThreadPoolExecutor的一大特点就是<strong>线程复用</strong>。</p><p>首先放张图介绍下线程池执行任务的<strong>流程</strong></p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/20210430162129.png" alt="executor_4" style="zoom:67%;" /><ol><li>工作线程数小于核心线程数</li></ol><p>创建一个线程<strong>作为核心线程</strong>，去执行该任务。</p><ol start="2"><li>工作线程数大于等于核心线程数</li></ol><p>把任务添加到阻塞队列中</p><ol start="3"><li>阻塞队列满了</li></ol><p>创建线程作为<strong>非核心线程</strong>，去执行任务</p><p>既然想了解它的线程复用原理，就免不了看源码的过程，下面放出了一些关键方法。</p><h3 id="1-execute"><a href="#1-execute" class="headerlink" title="1.execute()"></a>1.execute()</h3><p>之前提到，不管是用execute()还是submit()来执行任务，<strong>实质</strong>都是调用execute()来执行的</p><p>下面就来看看execute()的核心源码</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">int</span> c = ctl.get();<br><span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;   <span class="hljs-comment">// 如果工作线程数小于核心线程数，就调用addWorker()</span><br>    <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))        <span class="hljs-comment">// 该方法内部新建了线程去执行任务</span><br>        <span class="hljs-keyword">return</span>;<br>    c = ctl.get();<br>&#125; <span class="hljs-comment">// 工作线程数大于等于核心线程数，就会来到这</span><br><span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;  <span class="hljs-comment">// 状态是Running，就把任务放入到队列中，如果失败就执行else</span><br>    <span class="hljs-keyword">int</span> recheck = ctl.get();                     <span class="hljs-comment">// 二次检查</span><br>    <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="hljs-comment">// 检查不通过(状态不是Running)就删除该任务并采取拒绝策略</span><br>        reject(command);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))   <span class="hljs-comment">// 当状态不是运行状态，或者队列满了，就会走到这里</span><br>    reject(command);                   <span class="hljs-comment">// 创建非核心线程去执行任务，如果失败就采用拒绝策略</span><br></code></pre></td></tr></table></figure><p>我们可以发现，execute()主要调用了两个方法，分别是<code>addWorker()</code>和<code>reject()</code></p><h3 id="2-reject"><a href="#2-reject" class="headerlink" title="2.reject()"></a>2.reject()</h3><p>主要是调用处理器去拒绝该任务，具体策略有四种</p><p>在创建线程池时，会添加默认的处理器defaultHandler，它采取的是<strong>AbortPolicy</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="hljs-keyword">new</span> AbortPolicy();<br><span class="hljs-comment">// 在构造方法里，会默认让 handler = defaultHandler</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    handler.rejectedExecution(command, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>具体策略：</strong></p><table><thead><tr><th align="center">拒绝策略</th><th align="center">描述</th><th align="center">应用场景</th></tr></thead><tbody><tr><td align="center"><strong>AbortPolicy</strong></td><td align="center">拒绝任务并抛出异常RejectedExecutionException</td><td align="center">捕获异常进行处理</td></tr><tr><td align="center"><strong>CallerRunsPolicy</strong></td><td align="center">让调用的线程去执行任务</td><td align="center">并发量低时，可以使用这种</td></tr><tr><td align="center"><strong>DiscardPolicy</strong></td><td align="center">拒绝并丢弃任务</td><td align="center">当前任务不重要</td></tr><tr><td align="center"><strong>DiscardOldestPolicy</strong></td><td align="center">丢弃最久未处理的工作，然后再次尝试execute()</td><td align="center">之前的任务不是很重要，就可以用这种策略</td></tr></tbody></table><p><strong>具体应用1：</strong></p><p><strong>场景：</strong>用户支付后，把消息发送给用户，我们希望这个消息无论如何都能够发出去。</p><p><strong>解决：</strong>使用线程池来执行任务。如果并发量很大，导致线程池的阻塞队列满了，可以采用<code>AbortPolicy</code>策略，抛出异常，然后在外部捕获异常。捕获异常后把任务存到<code>redis</code>中，另外使用一个定时器，每隔一秒去redis中异步获取任务，再次添加到线程池。</p><p><strong>优化版：</strong>自定义拒绝策略，在里面把任务存到<code>redis</code>中，以此封装逻辑。</p><p><strong>具体应用2：</strong></p><p><strong>场景：</strong>推送，上游生产，下游消费；我们希望下游消费得比较慢时，就不要再推送。</p><p><strong>解决：</strong>开一个异步线程去获取任务，然后把任务放入到线程池中去执行推送；当阻塞队列满时，采取<code>CallerRunsPolicy</code>策略，让主线程去执行推送，这样主线程既不会空闲下来，也不会再去获取任务。</p><h3 id="3-addWorker"><a href="#3-addWorker" class="headerlink" title="3.addWorker()"></a>3.addWorker()</h3><p>这里主要是把任务<strong>包装</strong>成Worker对象，然后<strong>新建</strong>线程（由工厂新建）去执行任务。</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br><span class="hljs-comment">// 省略前面的一些判断和处理</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>    Worker w = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        w = <span class="hljs-keyword">new</span> Worker(firstTask); <span class="hljs-comment">// 创建Worker对象时，内部通过工厂获得了一个线程</span><br>        <span class="hljs-keyword">final</span> Thread t = w.thread; <span class="hljs-comment">// 使用线程</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<span class="hljs-comment">// 加锁</span><br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());  <span class="hljs-comment">// 进行检查，如果状态是Running</span><br>  <span class="hljs-comment">// 如果状态是Shutdown 且firstTask是空</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN || <span class="hljs-comment">// 就把任务添加到HashSet中</span><br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    workers.add(w);<br>                    <span class="hljs-keyword">int</span> s = workers.size();      <span class="hljs-comment">// 判断大小</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock(); <span class="hljs-comment">// 解锁</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();         <span class="hljs-comment">// 启动线程</span><br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);    <span class="hljs-comment">// 调用失败的方法</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p>看了上面的源码，我们可以发现<strong>线程池</strong>是通过<strong>创建Worker</strong>来执行任务的，同时<strong>线程</strong>也在Worker对象中。</p><p>那么我们再看看<strong>Worker</strong>类</p><h3 id="4-Worker"><a href="#4-Worker" class="headerlink" title="4.Worker"></a>4.Worker</h3><p>Worker类实现了Runnable接口，重写了run()</p><p>里面调用了**runWorker()**，那么这个方法才是真正执行任务的！</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 构造方法</span><br>    Worker(Runnable firstTask) &#123;<br>            setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>            <span class="hljs-keyword">this</span>.firstTask = firstTask;<br>            <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            runWorker(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-runWorker"><a href="#5-runWorker" class="headerlink" title="5.runWorker()"></a>5.runWorker()</h3><p>我们可以清楚地看到，当任务不为空时，就调用run()执行。</p><p>这里也是线程复用的实现：</p><p>当一个线程 <strong>执行完 firstTask <strong>后，它会通过getTask()主动去阻塞队列中</strong>获取</strong>任务来执行</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>    Thread wt = Thread.currentThread();<br>    Runnable task = w.firstTask;<br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 重点，获得任务的方式有两种</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;  <span class="hljs-comment">// 1.从Worker对象中得到任务</span><br>            w.lock();<span class="hljs-comment">// 2.如果Worker对象中的任务完成了</span><br>         <span class="hljs-comment">// 就通过getTask()方法去获取</span><br>          <span class="hljs-comment">/* 省略一些中断处理和判断... */</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                beforeExecute(wt, task);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task.run();       <span class="hljs-comment">// 前面获取到了任务，就在这里运行</span><br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-keyword">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-getTask"><a href="#6-getTask" class="headerlink" title="6.getTask()"></a>6.getTask()</h3><p>通过死循环来获取任务，任务是从阻塞队列中获取的</p><ol><li>工作线程数 &gt; 核心线程数 使用poll()</li><li>工作线程数 &lt;= 核心线程数 使用take()</li></ol><p>poll()和take()的区别在于，poll可以传递放弃等待的时间参数，超过这个时间就放弃获取</p><p>take()如果获取不到就会阻塞，一直等待（因为这时候工作线程数量少，你获取不到任务就会空闲，所以要一直阻塞，直到任务来了）</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">// 通过死循环获取任务</span><br>        <span class="hljs-comment">// 省略检查线程池状态和队列为空的判断</span><br>        <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>        <span class="hljs-comment">// 工作线程数 &gt; 核心线程数，就是true</span><br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>       <span class="hljs-comment">// 省略超时和容量上限判断</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Runnable r = timed ?                                      <span class="hljs-comment">// 1.工作线程数 &gt; 核心线程数 用poll()</span><br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="hljs-comment">// 2.反之，就用take()</span><br>                workQueue.take();  <span class="hljs-comment">// 区别在于take()会阻塞地获取任务 </span><br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h3><p>Executor的线程复用，是让线程在完成任务后，不断地向阻塞队列获取任务</p><p>对于核心线程来说，用take方法，获取不到就会阻塞，从而保证它永远不会因为存活时间而过期销毁</p><p>而非核心线程，用poll方法，在超时时间内获取不到任务，就会放弃，从而会因为存活时间到期而销毁。</p>]]></content>
      
      
      <categories>
          
          <category> 线程和线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="2021/04/01/Java/Java%E5%AE%B9%E5%99%A8/ArrayList/"/>
      <url>2021/04/01/Java/Java%E5%AE%B9%E5%99%A8/ArrayList/</url>
      
        <content type="html"><![CDATA[<p>谈谈arraylist</p><p>1.底层实现    是对象数组</p><p>2.构造方法   3种</p><p>3.扩容机制</p><p>默认大小是10</p><p>如果不指定大小，会先创建空数组，在添加元素的时候把数组扩容成10，然后放满都不会扩容，直到添加第11个元素</p><p>如果指定大小，比如5，那么放入第六个元素时才会进行扩容</p><p>扩容是每次容量*1.5倍，用了位运算</p><p>4.最大容量</p><p>整型最大值 - 8</p><p>大于这个值，就调用hugeCapacity方法，把容量变成整型的最大值</p><p>如果溢出，就抛出错误。</p><p>5.添加大量元素</p><p>添加大量元素时，arraylist会经过多次扩容，性能较低，这时候可以调用ensureCapacity方法，提前让数组扩容一次，以满足需求</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信件错排</title>
      <link href="2021/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2021/04/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="1-信件错排"><a href="#1-信件错排" class="headerlink" title="1.信件错排"></a>1.信件错排</h1><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>存在<strong>n个信封</strong>和<strong>n封信</strong>，每封信都有个正确的信封存放，那么所有信<strong>都放错</strong>的情况有几种？</p><p>可以只写出转移方程</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>$dp[i]$ 表示 $i$ 封信错排的总数</p><p>假设现在有5个信封和5封信，编号为1~5</p><p>如果我们把<code>信1</code>放入到<code>信封2</code>中，那么<code>信2</code>想要维持错排的状态，就有两种可能：一是放入<code>信封1</code>，二是放到<code>其他信封(3,4,5)</code>中</p><p><img src= "/img/loading.gif" data-lazy-src="E:\吴和泽\LearningFile\resources\dp-2.PNG"></p><p>针对情况一，信2放入到信封1后，就剩下了编号为<strong>3、4、5</strong>的信和信封，问题就转化为求3封信3个信封错排情况，即 $dp[i-2]$</p><p>针对情况二，信2要放入<strong>3、4、5</strong>中，如果我们把<code>信2</code>和<code>信封1</code>看成是一对，就有四对要错排的元素，那么就变成了求四封信四个信封的错排数，即 $dp[i-1]$</p><h3 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h3><p>信1放入信封2时， $dp[i] = dp[i-1] + dp[i-2]$</p><p>而最开始，信1还可能放到<strong>3、4、5</strong>中，总共有 $n-1$ 种可能</p><p><strong>所以</strong>：<br>$$<br>dp[i] = (i-1) * (dp[i-1] + dp[i-2])<br>$$<br>至于具体解，可以通过 <strong>一个for循环</strong> 和 <strong>滑动窗口</strong> 来计算</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(一).Java线程的简单介绍</title>
      <link href="2021/03/26/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/Java%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/03/26/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/Java%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Java实现线程的三种方式"><a href="#1-Java实现线程的三种方式" class="headerlink" title="1. Java实现线程的三种方式"></a>1. Java实现线程的三种方式</h4><ul><li>继承Thread类</li></ul><p>查看Thread的源码，可以发现，它是实现了 <code>Runnable</code> 接口</p><p>因此也是通过调用 <code>run</code> 方法来运行的</p><ul><li>实现Runnable接口</li></ul><p>是一个接口，定义了run方法。</p><ul><li>实现Callable接口</li></ul><p>第三种比较特殊，是用于需要线程返回信息的情况。</p><h4 id="2-线程的生命周期"><a href="#2-线程的生命周期" class="headerlink" title="2. 线程的生命周期"></a>2. 线程的生命周期</h4><p>线程池管理着多个线程的创建与销毁</p><p>那么线程的生命周期是怎样的呢，让我们来一探究竟！</p><ul><li>新建（new）</li></ul><p>使用 <code>new</code> 关键字创建线程后，就处于 <code>新建</code> 状态，JVM为线程分配内存空间，并初始化成员变量</p><ul><li><p>就绪（runnable）</p><p>调用 <code>start</code> 方法后，处于 <code>就绪</code> 状态，JVM为它创建方法栈和程序计数器</p></li><li><p>运行（running）</p></li></ul><p>得到CPU时间片后，开始执行 <code>run</code> 方法体</p><ul><li>阻塞（blocked）</li></ul><p>线程因某种原因放弃了CPU，进入阻塞</p><table><thead><tr><th align="center">阻塞类型</th><th align="center">描述</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">等待阻塞</td><td align="center">执行wait方法</td><td align="center">进入等待队列中（waiting queue）</td></tr><tr><td align="center">同步阻塞</td><td align="center">获取锁失败</td><td align="center">进入锁池（lock pool）</td></tr><tr><td align="center">其他阻塞</td><td align="center">执行sleep或join或IO请求</td><td align="center">状态置为阻塞</td></tr></tbody></table><ul><li>死亡（dead）</li></ul><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">正常死亡</td><td align="center">执行完方法体</td></tr><tr><td align="center">异常结束</td><td align="center">抛出异常</td></tr><tr><td align="center">调用stop</td><td align="center">直接调用stop来结束该线程（可能会出问题）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 线程和线程池 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加密算法</title>
      <link href="2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-摘要算法"><a href="#1-摘要算法" class="headerlink" title="1. 摘要算法"></a>1. 摘要算法</h2><p>对<strong>明文</strong>进行hash，生成一段固定长度的密文</p><p>有以下几个<strong>特点</strong>：</p><ol><li>相同的明文，经过相同的摘要算法，得到的密文一定是一样的</li><li>摘要算法要尽量<strong>避免碰撞</strong></li><li>明文变成密文的过程是<strong>不可逆</strong>的</li></ol><p>常见的摘要算法有<strong>MD5、SHA</strong></p><h2 id="2-对称加密"><a href="#2-对称加密" class="headerlink" title="2. 对称加密"></a>2. 对称加密</h2><p>存在<strong>一个密钥</strong></p><blockquote><p>明文通过密钥加密，变成密文</p></blockquote><blockquote><p>密文通过密钥解密，得到明文</p></blockquote><p>如果要保证数据传输的安全性，就得考虑怎样安全的把密钥告知对方</p><p>否则一旦密钥泄露，数据就会变得透明</p><h2 id="3-非对称加密"><a href="#3-非对称加密" class="headerlink" title="3. 非对称加密"></a>3. 非对称加密</h2><blockquote><p>存在<strong>一对密钥</strong>，公钥和私钥</p><p>一个来加密，另一个来解密，才能获得原文。</p></blockquote><p>HTTPS 通信<strong>基础版</strong>：混合加密机制</p><p>服务器 S 有一对公钥和私钥，客户端 C 有一个密钥</p><ol><li><p><code>S</code> 把公钥发给 <code>C</code></p></li><li><p><code>C</code> 获得公钥后，用公钥加密它自己的密钥，发给 <code>S</code></p></li><li><p><code>S</code> 收到密文，用私钥解密，得到 <code>C</code> 的密钥</p></li></ol><p>然后双方就可以用对称加密的方式进行通信。</p><p><strong>但是……</strong></p><p>这样的机制还是会有安全问题</p><p>比如客户端判断不出它收到的公钥是服务器发的，还是被<strong>中间人篡改</strong>了的</p><p>如果公钥是被中间人篡改过的，那么它就可以<strong>伪装</strong>成服务器，与客户端进行通信</p><p>而服务器和客户端都<strong>无法感觉</strong>到这件事。</p><h2 id="4-数字签名"><a href="#4-数字签名" class="headerlink" title="4. 数字签名"></a>4. 数字签名</h2><p>基于以上<strong>中间人</strong>的问题，我们又提出了数字签名算法。</p><p>它类似于写在纸上的物理签名</p><p>数字签名通常是用私钥生成签名，用公钥验证签名</p><ol><li>发送方利用摘要算法（通常是hash），得到报文摘要，再对其用私钥加密，得到数字签名</li><li>然后把数字签名和报文一起发送给接收方</li><li>接收方同样对报文进行相同的算法，得到报文摘要</li><li>然后用公钥解密数字签名</li><li>比较3、4得到的结果是否一样</li></ol><p>就能够判断是否是发送方发过来的</p><h2 id="MD5加盐"><a href="#MD5加盐" class="headerlink" title="MD5加盐"></a>MD5加盐</h2><p><strong>加密过程：</strong></p><p>场景：首次向数据库存密码时</p><p>过程：</p><ol><li><p>在本地生成一串随机数（称为<code>盐</code>），并与<code>password</code>相加</p></li><li><p>根据相加的字符串得到<code>MD5加密</code>后的密文</p></li><li><p>把<code>盐</code>按一定规则插入到密文中，然后存入数据库</p></li></ol><p><strong>解密过程：</strong></p><p>场景：用户输入密码尝试登录</p><p>过程：</p><ol><li>从数据库中读取用户名所对应的<code>密码密文</code></li><li>按当时插入的规则取出<code>盐</code></li><li>用户此次输入的<code>password</code>加上<code>盐</code>，然后进行<code>MD5加密</code>得到新的密文</li><li>新密文与数据库存的密文进行对比即可判断密码是否一致</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="2021/03/22/Java/Java%E5%AE%B9%E5%99%A8/HashMap/"/>
      <url>2021/03/22/Java/Java%E5%AE%B9%E5%99%A8/HashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="1-hash算法"><a href="#1-hash算法" class="headerlink" title="1. hash算法"></a>1. hash算法</h2><p>即扰动函数</p><p><strong>key</strong> 的哈希码的高16位与低16位进行<strong>异或</strong>，增加低十六位的<strong>随机性</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-计算数组下标"><a href="#2-计算数组下标" class="headerlink" title="2. 计算数组下标"></a>2. 计算数组下标</h2><blockquote><p>简单地说，下标就是 hash 除以 数组容量，得到的<strong>余数</strong></p><p>具体计算采用的是<strong>与运算</strong></p></blockquote><p>n表示数组大小，初始值为<strong>16</strong></p><p>在n是2的整数幂情况下，n - 1的二进制低位全是1，高位全是0</p><p>这样 n - 1与哈希值进行<strong>与</strong>运算时，就只保留了hash的低位，来作为数组下标访问</p><p><del>因此Java规定该数组大小必须是2的整数次幂</del>，是通过tableSizeFor方法实现的</p><p>16 - 1 的二进制有个特点，即<strong>低位全是1，高位全是0</strong></p><p>这样做明显会出现碰撞的可能，所以就需要<strong>上述1</strong>中的扰动函数，来增加低位hash值的随机性</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">tab[i = (n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]<br></code></pre></td></tr></table></figure><h2 id="3-扩容机制（resize）"><a href="#3-扩容机制（resize）" class="headerlink" title="3. 扩容机制（resize）"></a>3. 扩容机制（resize）</h2><ul><li><p><strong>threshold：</strong>临界值</p></li><li><p><strong>capacity：</strong>数组容量，默认为16</p></li><li><p><strong>load factor：</strong>负载因子，默认为0.75</p></li></ul><p><strong>计算公式：</strong>$\quad threshold = capacity * load factor$</p><p>当HashMap中的元素个数大于临界值时，就会进行扩容：</p><ol><li>把数组容量变为原来的两倍</li><li>重新计算hash(这里是指元素在散列表中的位置，即索引，与数组大小有关，所以发生了变化)</li></ol><h2 id="4-插入元素"><a href="#4-插入元素" class="headerlink" title="4. 插入元素"></a>4. 插入元素</h2><p>插入元素时：</p><ol><li>如果数组索引处节点是空的，就新建一个节点</li><li>如果索引处节点不为空，则插入到链表中（1.7头插法，1.8尾插法）</li><li>如果是树节点，则调用插入树节点的方法</li></ol><p>插入完毕后：</p><p>如果链表长度大于8，则判断数组容量，小于64就进行<strong>resize</strong>，大于64就<strong>由链表</strong>优化成<strong>红黑树</strong></p><h5 id="5-tableSizeFor方法"><a href="#5-tableSizeFor方法" class="headerlink" title="5.tableSizeFor方法"></a>5.tableSizeFor方法</h5><p>传入用户指定的初始容量，然后返回大于该数值的最近的2幂次，例如输入11，返回16（2的四次）</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>        n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>        <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-putVal方法"><a href="#5-putVal方法" class="headerlink" title="5. putVal方法"></a>5. putVal方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) <span class="hljs-comment">// 判断数组是否为空或长度为0，然后进行扩容</span><br>            n = (tab = resize()).length;<br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 索引命中的地方为空，则直接插入到数组中</span><br>            tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>); <span class="hljs-comment">// 是在方法最后面判断size+1后容量是否超过上限</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 数组索引处存在节点，发生碰撞</span><br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;  <span class="hljs-comment">// 判断是不是重复元素，如果是的话，会在下面覆盖。</span><br>                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 覆盖重复元素</span><br>                V oldValue = e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue; <span class="hljs-comment">// 返回旧的value，覆盖相同key的时候才会从这里返回</span><br>            &#125; <span class="hljs-comment">// 这里还可以让HashSet的add方法返回false</span><br>        &#125; <span class="hljs-comment">// 因为add方法调用了putVal方法，具体返回为 putVal(...) == null</span><br>        ++modCount; <span class="hljs-comment">// false则说明在HashMap中遇到并覆盖了重复的元素</span><br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>HashSet的add方法</p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 这里可以看到，HashSet添加元素，是把元素作为map的key,而map的value则是一个常量Object，在最上方定义。</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="2021/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>2021/03/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><blockquote><p>红黑树是一种含有红黑节点并能<strong>自平衡</strong>的<strong>二叉查找树</strong></p></blockquote><ul><li>每个节点只能是红色或黑色</li><li>根节点为黑色</li><li>每个叶子节点（这里是指为空的节点）是黑色</li><li><strong>红色</strong>节点的<strong>子节点</strong>一定是<strong>黑色</strong></li><li><strong>任意一个节点</strong>到每个<strong>叶子节点</strong>的路径都包含<strong>相同数量</strong>的黑色节点</li></ul><h5 id="2-插入元素（每个新插入的节点默认是红色）"><a href="#2-插入元素（每个新插入的节点默认是红色）" class="headerlink" title="2. 插入元素（每个新插入的节点默认是红色）"></a>2. 插入元素（每个新插入的节点默认是红色）</h5><p>红黑树在插入节点时：</p><ol><li>先按搜索的顺序，把节点放在合适位置（类似二叉查找）</li><li>然后判断是否满足红黑树定义</li><li>不满足就会发生<strong>旋转</strong>和<strong>变色</strong>现象</li></ol><p>判断条件如下：</p><table><thead><tr><th align="center">情况</th><th align="center">做法</th></tr></thead><tbody><tr><td align="center">父节点为黑色</td><td align="center">什么都不做</td></tr><tr><td align="center">父节点红色，且叔叔也是红色</td><td align="center">父亲叔叔变黑，祖父变红</td></tr><tr><td align="center">父红色，且叔叔为空或黑色</td><td align="center">旋转 + 变色</td></tr></tbody></table><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/aurora1004/pictures/raw/master/20210430111115.png" style="zoom:67%;" /><p>父节点红色，叔叔为黑色的情形：</p><h5 id="3-HashMap红黑树部分源码"><a href="#3-HashMap红黑树部分源码" class="headerlink" title="3. HashMap红黑树部分源码"></a>3. HashMap红黑树部分源码</h5><p>红黑树插入节点 <code>x</code> 时，进行了以下判断：</p><ol><li>若x的父亲是null，说明x是根节点，直接返回x（这里x就是根节点了，所以返回x）</li><li>若x的父亲是黑色 或者 x的祖父是空（即x的父亲为根节点，而根节点一定是黑色的），直接返回根节点</li><li></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">balanceInsertion</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                    TreeNode&lt;K,V&gt; x)</span> </span>&#123;<br>            x.red = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 要插入的节点</span><br>            <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;<br>                <span class="hljs-keyword">if</span> ((xp = x.parent) == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// x父亲为空，即x为根节点</span><br>                    x.red = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span> x;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="hljs-keyword">null</span>)<span class="hljs-comment">// x父亲为黑色 或者 x祖父为空，不用调整</span><br>                    <span class="hljs-keyword">return</span> root;<br>                <span class="hljs-keyword">if</span> (xp == (xppl = xpp.left)) &#123;<br>                    <span class="hljs-keyword">if</span> ((xppr = xpp.right) != <span class="hljs-keyword">null</span> &amp;&amp; xppr.red) &#123;<span class="hljs-comment">// 如果父亲叔叔都是红色</span><br>                        xppr.red = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 则把父亲叔叔改成黑色，祖父改成红色</span><br>                        xp.red = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 更新当前节点为祖父，进行下一次循环</span><br>                        xpp.red = <span class="hljs-keyword">true</span>;<br>                        x = xpp;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> (x == xp.right) &#123;<br>                            root = rotateLeft(root, x = xp);<br>                            xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                            xp.red = <span class="hljs-keyword">false</span>;<br>                            <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                                xpp.red = <span class="hljs-keyword">true</span>;<br>                                root = rotateRight(root, xpp);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (xppl != <span class="hljs-keyword">null</span> &amp;&amp; xppl.red) &#123;<br>                        xppl.red = <span class="hljs-keyword">false</span>;<br>                        xp.red = <span class="hljs-keyword">false</span>;<br>                        xpp.red = <span class="hljs-keyword">true</span>;<br>                        x = xpp;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> (x == xp.left) &#123;<br>                            root = rotateRight(root, x = xp);<br>                            xpp = (xp = x.parent) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : xp.parent;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (xp != <span class="hljs-keyword">null</span>) &#123;<br>                            xp.red = <span class="hljs-keyword">false</span>;<br>                            <span class="hljs-keyword">if</span> (xpp != <span class="hljs-keyword">null</span>) &#123;<br>                                xpp.red = <span class="hljs-keyword">true</span>;<br>                                root = rotateLeft(root, xpp);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="E:\吴和泽\NotepadFile\resources\rotate.png"></p><p><strong>左旋转，即以旋转点为中心，逆时针旋转</strong></p><p><strong>右旋，则是以旋转点为中心，顺时针旋转</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> &lt;K,V&gt; <span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">rotateLeft</span><span class="hljs-params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="hljs-function"><span class="hljs-params">                                              TreeNode&lt;K,V&gt; p)</span> </span>&#123;<br>            TreeNode&lt;K,V&gt; r, pp, rl;<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; (r = p.right) != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((rl = p.right = r.left) != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 这里分两步，赋值和判断     // 赋值：r1 = r.left 且 p.right = r.left</span><br>                    rl.parent = p; <span class="hljs-comment">// 判断：r.left != null</span><br>                <span class="hljs-keyword">if</span> ((pp = r.parent = p.parent) == <span class="hljs-keyword">null</span>)<br>                    (root = r).red = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pp.left == p)<br>                    pp.left = r;<br>                <span class="hljs-keyword">else</span><br>                    pp.right = r;<br>                r.left = p;<br>                p.parent = r;<br>            &#125;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发(待完善)</title>
      <link href="2021/03/16/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B9%B6%E5%8F%91%EF%BC%88%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/"/>
      <url>2021/03/16/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E5%B9%B6%E5%8F%91%EF%BC%88%E5%BE%85%E5%AE%8C%E5%96%84%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h4 id="一、多线程的优缺点"><a href="#一、多线程的优缺点" class="headerlink" title="一、多线程的优缺点"></a>一、多线程的优缺点</h4><ul><li><strong>优点</strong></li></ul><p>和进程相比，线程的调度和切换成本更小。</p><p>多核CPU能够让多个线程同时运行，还能减少线程上下文切换的开销，提高CPU利用率</p><ul><li><strong>缺点</strong></li></ul><p>可能会遇到<strong>内存泄漏、死锁、线程不安全</strong>的情况</p><ul><li><strong>补充</strong></li></ul><p>Java内存泄漏：主要是由于长生命周期的对象持有短生命周期的引用，如集合里存放类对象</p><h4 id="二、死锁"><a href="#二、死锁" class="headerlink" title="二、死锁"></a>二、死锁</h4><ul><li>互斥性</li></ul><blockquote><p>同一时间只能有一个线程持有某个对象的锁</p></blockquote><ul><li>可见性</li></ul><blockquote><p>锁释放之前，共享变量的修改要对其他线程可见</p></blockquote><hr><p><strong>Java内存模型：</strong></p><p>内存分为<code>主内存</code>和<code>工作内存</code></p><p><code>主内存</code>是所有线程共享的，如<strong>堆、方法区</strong></p><p><code>工作内存</code>是线程私有的区域，如<strong>虚拟机栈、程序计数器</strong>等</p><hr><p><strong>volatile</strong>关键字的作用：</p><ol><li><strong>保证线程间变量的可见性</strong></li></ol><p>一个变量如果用<strong>volatile</strong>修饰，那么：</p><p>①某个线程修改变量后，要写回主内存中</p><p>②某个线程要读取该变量时，要从主内存中读，而不是缓存</p><ol start="2"><li><strong>禁止指令重排序</strong></li></ol><p>注意：volatile不保证原子性</p><h4 id="三、锁"><a href="#三、锁" class="headerlink" title="三、锁"></a>三、锁</h4><ol><li><strong>互斥锁</strong></li><li><strong>偏向锁</strong></li></ol><p>背景：在多数情况下，锁不仅不存在多线程竞争，而且还总是由同一线程多次获得</p><p>目的：让线程获得锁的代价更低</p><p>实现：</p><p>一个线程想要获取对象锁时，先查看对象头的锁记录里是否有线程ID</p><p>如果有，直接获取锁</p><p>如果设置了，说明是其他线程获得了锁，就发起竞争，由<strong>偏向锁</strong>变为<strong>轻量级锁</strong></p>]]></content>
      
      
      <categories>
          
          <category> 线程和线程池 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题记录</title>
      <link href="2021/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91/"/>
      <url>2021/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h4 id="一、TCP三次握手的过程"><a href="#一、TCP三次握手的过程" class="headerlink" title="一、TCP三次握手的过程"></a>一、TCP三次握手的过程</h4><h6 id="1-符号说明"><a href="#1-符号说明" class="headerlink" title="1.符号说明"></a>1.符号说明</h6><ul><li>ACK：确认标志，请求连接时为0，连接建立后所有发送的报文的ACK必须为1</li><li>SYN：同步序列号，只在三次握手建立连接时有效，值为1</li><li>ISN ：初始序列号，由生成器生成一个32位的ISN，生成器用32位长的时钟，每隔一段时间增长一次，大约<strong>5小时</strong>会重新循环。而数据包的默认最大寿命<strong>MSL</strong>为<strong>2分钟</strong>，所以可以认为初始序列号是唯一的</li></ul><h6 id="2-过程"><a href="#2-过程" class="headerlink" title="2.过程"></a>2.过程</h6><p>假设客户端和服务器的初始序列号分别为X，Y</p><ol><li><p>客户端发送建立连接请求，<code>SYN = 1，seq = X</code></p></li><li><p>服务器收到请求并回复，<code>SYN = 1，ack = X + 1，seq= Y</code></p></li><li><p>客户端收到回复，并告诉服务器我收到了 <code>SYN = 0，ack = Y + 1，seq = X + 1，</code></p></li></ol><p>三次握手可以理解为</p><ol><li>客户端 - &gt; 服务器  SYN，my ISN is X</li><li>服务器 - &gt; 客户端  ACK，your ISN is X</li><li>服务器 - &gt; 客户端  SYN，my ISN is Y</li><li>客户端 - &gt; 服务器  ACK，your ISN is Y</li></ol><p>其中2，3 可以合并</p><h4 id="二、为什么要进行三次握手，而不用两次或四次？"><a href="#二、为什么要进行三次握手，而不用两次或四次？" class="headerlink" title="二、为什么要进行三次握手，而不用两次或四次？"></a>二、为什么要进行三次握手，而不用两次或四次？</h4><p>目的是建立可靠的通信信道，同时避免资源浪费。</p><p>如果是采用两次握手的话，只保证了客户端的发送和接受，而服务器不知道它发出的报文是否被客户端接受到。</p><p>而三次握手则保证了服务器和客户端的发送接收都没有问题。</p><p>四次握手的话会浪费更多的网络资源</p><h4 id="三、第二次握手为什么要传回SYN？"><a href="#三、第二次握手为什么要传回SYN？" class="headerlink" title="三、第二次握手为什么要传回SYN？"></a>三、第二次握手为什么要传回SYN？</h4><p>第二次握手既传了ACK，又传了SYN。</p><p>传ACK是为了告诉发送方，我收到了你发送的信息，这表明客户端到服务器的通信是正常的。</p><p>而回传SYN则是为了建立并确认服务端到客户端的通信。</p><h4 id="四、四次挥手的过程"><a href="#四、四次挥手的过程" class="headerlink" title="四、四次挥手的过程"></a>四、四次挥手的过程</h4><ol><li>客户端向服务器发起<code>FIN请求</code></li><li>服务器收到断开连接请求后，并没有立即关闭，而是先发送<code>ACK应答报文</code>，通知客户端，它已经收到请求</li><li>服务器等待资源发送完毕，再发出<code>FIN报文</code></li><li>客户端收到服务器的FIN报文后，发出<code>ACK确认报文</code>给服务器，并开始计时，在<strong>2MSL（max segment lifetime）</strong>后关闭连接</li></ol><h4 id="五、为什么连接的时候是三次握手，关闭的时候却是四次挥手？"><a href="#五、为什么连接的时候是三次握手，关闭的时候却是四次挥手？" class="headerlink" title="五、为什么连接的时候是三次握手，关闭的时候却是四次挥手？"></a>五、为什么连接的时候是三次握手，关闭的时候却是四次挥手？</h4><p>因为在三次握手的时候，服务器接收到客户端的连接请求时，可以立即发出ACK应答报文并请求建立连接</p><p>而在四次挥手过程中，服务器接收到客户端的FIN请求，它可能还有数据包还没发送完，只能先返回ACK报文来应答，等数据包发送完之后，才能返回FIN请求给客户端。</p><h4 id="六、TIME-WAIT状态为什么要定义为2MSL？"><a href="#六、TIME-WAIT状态为什么要定义为2MSL？" class="headerlink" title="六、TIME_WAIT状态为什么要定义为2MSL？"></a>六、TIME_WAIT状态为什么要定义为2MSL？</h4><ol><li><p>尽可能能的确保最后的ACK报文顺利到达服务器</p><p> 第四次握手时，客户端向服务器发送的ACK报文可能会丢失，服务器收不到ACK报文，就会进行超时重传FIN</p><p> <strong>补充：</strong>那么为什么不把时间设置成<strong>RTT（报文从发送到接受再到确认的一次往返时间）</strong></p><p> <strong>答：</strong>即第二点理由</p></li><li><p>为了确保老的重复的报文段消失在网络中</p></li><li><p>一些路由器会缓存数据包，TIME_WAIT可以有效地应对这种情况</p></li></ol><h4 id="七、TCP三次握手可以传递数据吗？"><a href="#七、TCP三次握手可以传递数据吗？" class="headerlink" title="七、TCP三次握手可以传递数据吗？"></a>七、TCP三次握手可以传递数据吗？</h4><p>前两次不可以，因为此时连接还没建立。</p><p>第三次可以，因为客户端收到服务器传来的ACK报文后，处于建立连接的状态，并且知道服务器接收和发送能力是正常的，所以可以传递数据。</p><h4 id="八、TCP如果没有完成第四次挥手会发生什么？"><a href="#八、TCP如果没有完成第四次挥手会发生什么？" class="headerlink" title="八、TCP如果没有完成第四次挥手会发生什么？"></a>八、TCP如果没有完成第四次挥手会发生什么？</h4><p>服务器端的重传计时器达到规定时间片，依旧没有收到来自客户端的ACK报文，就开始进行超时重传，重新发送FIN报文给客户端。</p><h4 id="九、计网五层模型和七层模型（应用层协议有哪些）"><a href="#九、计网五层模型和七层模型（应用层协议有哪些）" class="headerlink" title="九、计网五层模型和七层模型（应用层协议有哪些）"></a>九、计网五层模型和七层模型（应用层协议有哪些）</h4><p>五层模型，从上到下：</p><ul><li><strong>应用层</strong>——<strong>DNS、HTTP</strong>、SMTP、FTP、telnet</li></ul><p>提供应用进程间的服务</p><ul><li><strong>传输层</strong>——<strong>TCP、UDP</strong></li></ul><p>提供端到端的通信</p><p>即数据传输路径中最两端的两台网络设备之间的通信</p><ul><li><strong>网络层</strong>——<strong>IP</strong>、ARP、ICMP、IGMP</li></ul><p>路由、寻址，把数据包传送到目的地</p><ul><li><strong>数据链路层</strong>——PPP、CSMA/CD</li></ul><ul><li><strong>物理层</strong>——电路交换、分组交换</li></ul><p><strong>透明</strong>地传输比特流，<strong>透明</strong>即让上层感受不到传输介质、接口光纤不同所带来的变化</p><p>七层模型：多了两层，表示层和会话层</p><h4 id="十、浏览器输入URL后发生了什么？（使用了哪些协议）"><a href="#十、浏览器输入URL后发生了什么？（使用了哪些协议）" class="headerlink" title="十、浏览器输入URL后发生了什么？（使用了哪些协议）"></a>十、浏览器输入URL后发生了什么？（使用了哪些协议）</h4><ol><li><strong>DNS解析</strong></li></ol><p>根据域名，在<strong>浏览器缓存、系统缓存、路由器缓存</strong>等依次向上查找。</p><p>另外，<strong>DNS重定向/负载均衡</strong></p><ol start="2"><li><strong>建立TCP连接</strong></li></ol><p>三次握手</p><ol start="3"><li><strong>发送HTTP请求</strong></li></ol><p>因为HTTP请求是明文，存在信息泄露的风险。</p><p>所以采用HTTPS协议进行加密（HTTP + SSL）</p><ol start="4"><li><p><strong>服务器处理请求并返回HTTP报文</strong></p></li><li><p><strong>浏览器解析渲染页面</strong></p></li></ol><p>浏览器边解析边渲染</p><p>解析HTML和CSS文件，得到DOM树和渲染树</p><p>然后布局渲染树，并把它绘制到屏幕上</p><h6 id="协议："><a href="#协议：" class="headerlink" title="协议："></a>协议：</h6><p>1.DNS    解析域名，获得ip地址</p><p>2.TCP     与服务器建立连接</p><p>3.IP        使用TCP建立连接时，网络层用到了IP协议</p><p>4.OSPF  进行路由选择</p><p>5.ARP     路由器与服务器通信时，根据ip地址得到MAC地址</p><p>6.HTTP   发送网页数据的请求</p><h4 id="十一、TCP和UDP的区别"><a href="#十一、TCP和UDP的区别" class="headerlink" title="十一、TCP和UDP的区别"></a>十一、TCP和UDP的区别</h4><p>TCP：可靠、需要建立连接、消耗资源较多</p><p>UDP：不保证数据的正确，无连接，消耗资源少，程序结构简单</p><h4 id="十二、TCP的可靠传输"><a href="#十二、TCP的可靠传输" class="headerlink" title="十二、TCP的可靠传输"></a>十二、TCP的可靠传输</h4><h5 id="（一）如何确保可靠性传输："><a href="#（一）如何确保可靠性传输：" class="headerlink" title="（一）如何确保可靠性传输："></a>（一）如何确保可靠性传输：</h5><p>使用超时重传来实现可靠传输，如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><h5 id="（二）拥塞控制："><a href="#（二）拥塞控制：" class="headerlink" title="（二）拥塞控制："></a>（二）拥塞控制：</h5><blockquote><p>发送方维护变量<strong>拥塞窗口（cwnd）</strong>，出现拥塞时，控制发送方的发送速率，算法如下：</p></blockquote><p><strong>1.慢开始</strong> 从发送1个报文段开始，如果该报文段被接受，就把数量*2</p><p>**2.拥塞避免 **慢开始会增长地很快，当cwnd大于门限时，每次只增1</p><p>如果出现了超时，就将门限设置为cwnd / 2，然后cwnd = 1，重新执行满开始</p><p><strong>3.快重传与快恢复</strong></p><blockquote><p>接收方收到的报文段应该是有序的，例如M1，M2收到，又来了个M4，这时候接收方发送对M2的确认</p></blockquote><p>一旦发送方收到三个重复的确认，就可以判定下一个报文段丢失，立刻重传</p><p>出现快重传后，网络并没有拥塞，只是丢失了个别报文段，因此执行快恢复。</p><p>即把cwnd的值设置的大一些，具体操作为：</p><p>门限 / 2，cwnd = 门限，这表示直接进入拥塞避免状态。</p><h5 id="（三）TCP传输时，客户端突然断开连接，服务器如何判定？"><a href="#（三）TCP传输时，客户端突然断开连接，服务器如何判定？" class="headerlink" title="（三）TCP传输时，客户端突然断开连接，服务器如何判定？"></a>（三）TCP传输时，客户端突然断开连接，服务器如何判定？</h5><p>利用TCP协议层提供的保活探测方法来判定</p><h5 id="（四）TCP的端口是为了区分什么？"><a href="#（四）TCP的端口是为了区分什么？" class="headerlink" title="（四）TCP的端口是为了区分什么？"></a>（四）TCP的端口是为了区分什么？</h5><p>区分一台设备中的不同应用进程</p><h4 id="十三、常见的HTTP状态码"><a href="#十三、常见的HTTP状态码" class="headerlink" title="十三、常见的HTTP状态码"></a>十三、常见的HTTP状态码</h4><p>200，204（没有实体内容），206（部分内容）</p><p>301（永久重定向），302（临时），303（临时，必须用GET请求），304（客户端发送附带条件，条件满足后的返回内容），307（临时）</p><p>400（请求报文错误），401（需要HTTP认证），403（没有访问服务器的权限），404（没找到资源）</p><p>500（服务器出错），503（服务器处于维护或超负载状态）</p><h4 id="十四、HTTP报文"><a href="#十四、HTTP报文" class="headerlink" title="十四、HTTP报文"></a>十四、HTTP报文</h4><h5 id="（一）请求报文和响应报文的组成"><a href="#（一）请求报文和响应报文的组成" class="headerlink" title="（一）请求报文和响应报文的组成"></a>（一）请求报文和响应报文的组成</h5><p>请求报文由<strong>请求行、请求首部、请求实体</strong>组成</p><p>响应报文由<strong>状态行、响应首部、响应实体</strong>组成</p><h5 id="（二）HTTP请求报文包含哪些方法，GET和POST的区别"><a href="#（二）HTTP请求报文包含哪些方法，GET和POST的区别" class="headerlink" title="（二）HTTP请求报文包含哪些方法，GET和POST的区别"></a>（二）HTTP请求报文包含哪些方法，GET和POST的区别</h5><p><strong>方法</strong>有get，post，head，put，delete，options，trace，connect</p><p><strong>区别：</strong></p><p>1.GET用来获取资源，不会修改服务器的数据</p><p>而POST用来传输实体，可能会修改数据</p><p>2.GET的请求参数会附在URL之后，参数大小有限制</p><p>而POST参数是放在请求实体中</p><h4 id="十五、HTTP和HTTPS的区别"><a href="#十五、HTTP和HTTPS的区别" class="headerlink" title="十五、HTTP和HTTPS的区别"></a>十五、HTTP和HTTPS的区别</h4><p><strong>区别：</strong></p><ol><li>明文，安全性</li><li>需要证书，费用不同</li><li>连接方式不同</li></ol><p><strong>补充：</strong></p><ul><li>HTTPS使用混合加密机制</li></ul><blockquote><p>服务器持有公钥 A 和私钥 A’</p><p>客户端发起连接，服务器把 A 发送给客户端</p><p>客户端接收 A ，本地再生成一个对称密钥 X ，用 A 加密 X ，发送给服务器</p><p>服务器用 A‘ 解密，得到对称密钥 X</p><p>然后双方用 X 加密报文进行通信</p></blockquote><ul><li>数字证书</li></ul><blockquote><p>混合加密机制也有漏洞。</p><p>如果遇到“中间人攻击”，即中间人劫持服务器发送的公钥，换成自己的</p><p>所以需要让客户端判断它收到的公钥是否是服务器的，而不是中间人篡改后的</p><p>于是CA机构就出现了，网站向该机构申请数字证书，把公钥写入证书中，把证书传给客户端就可以了。</p></blockquote><ul><li>数字签名</li></ul><blockquote><p>证书也可能被篡改，所以就需要签名来判断证书是否为真。</p><p>签名制作：（CA持有一对非对称密钥）</p><ol><li><p>CA对证书明文进行hash</p></li><li><p>hash后的值进行私钥加密，得到签名</p></li></ol><p>浏览器判定：（浏览器持有CA公钥）</p><ol><li>用公钥解密签名</li><li>根据证书说明的hash算法对明文hash</li><li>比较前两者的值是否相等</li></ol></blockquote><h4 id="十六、HTTP1-0、1-1和2-0的区别"><a href="#十六、HTTP1-0、1-1和2-0的区别" class="headerlink" title="十六、HTTP1.0、1.1和2.0的区别"></a>十六、HTTP1.0、1.1和2.0的区别</h4><p><strong>1.0与1.1：</strong>1.1默认使用长连接，支持流水线的请求</p><p><strong>2.0和1.x相比：</strong></p><ul><li>支持多路复用</li></ul><blockquote><p>能够在一个连接中并发处理多个请求</p></blockquote><ul><li>头部数据压缩（开始行 + 首部。主体一般都是压缩的）</li></ul><blockquote><p>客户端和服务器同时维护一个缓存表，避免重复传输</p><p>此外，利用哈夫曼编码压缩首部字段</p></blockquote><ul><li>服务端推送</li></ul><blockquote><p>客户端请求资源时，会把相关资源（JS，CSS等）一起发送给客户端</p></blockquote><ul><li>二进制、分帧层</li></ul><blockquote><p>1.x是用文本协议的格式解析的，2.0采用二进制解析</p><p>把报文分成headers和data帧</p></blockquote><ul><li>总结</li></ul><p>数据流共用一个连接，提高了TCP的利用率，同时也降低了延迟。</p><h4 id="十七、HTTP的缓存机制"><a href="#十七、HTTP的缓存机制" class="headerlink" title="十七、HTTP的缓存机制"></a>十七、HTTP的缓存机制</h4><p>介绍：</p><p>①Expires：过期时间</p><p>②Cache-Control：public，private，max-age，no-cache（不建议缓存，但还是有，相当于最大存活时间为0），no-store（不缓存），会覆盖①</p><p>③Last-Modified / If-Modified-Since：最后修改时间</p><p>④Etag / If-None-Match：唯一标识，如果修改了就会变化，优先级大于③</p><ul><li>存储策略</li></ul><blockquote><p>服务器响应客户端的第一次请求时，缓存协商。</p><p>可以是1234的任意一个（甚至多个）</p></blockquote><ul><li>过期策略</li></ul><blockquote><p>客户端想要请求资源时，判断有无缓存，有缓存的话是否过期。</p></blockquote><ul><li>对比策略</li></ul><blockquote><p>如果请求头里有If-Modified-Since，就比较修改时间</p><p>如果请求头里有If-None-Match，就查找是否有Etag等于该值的数据</p><p>缓存没有过期的话，返回304；过期的话，重新进行缓存协商，并返回200和新的数据</p></blockquote><h4 id="十八、什么是cookie和session，区别是什么，禁用cookie怎么办？"><a href="#十八、什么是cookie和session，区别是什么，禁用cookie怎么办？" class="headerlink" title="十八、什么是cookie和session，区别是什么，禁用cookie怎么办？"></a>十八、什么是cookie和session，区别是什么，禁用cookie怎么办？</h4><p>cookie和session都是会话跟踪的技术</p><p>cookie是保存在客户端的，在发送请求时携带cookie，服务器可以根据cookie跟踪会话</p><p>session是保存在服务端的。客户端第一次请求时，在服务器生成的一小块区域，然后服务器把session_id发给客户端，接下来的请求都带上session_id</p><p>区别：</p><ol><li>存放的位置不同</li><li>请求过多时，session会影响服务器性能</li><li>单个cookie保存的数据有大小限制，浏览器一般也有数量限制</li></ol><h4 id="十九、页面加载不出来的原因"><a href="#十九、页面加载不出来的原因" class="headerlink" title="十九、页面加载不出来的原因"></a>十九、页面加载不出来的原因</h4>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有限状态机</title>
      <link href="2021/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
      <url>2021/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><blockquote><p><strong>有限状态机</strong>（Finite-state machine，FSM），简称状态机，是表示<strong>有限个状态</strong>以及在这些状态之间的<strong>转移</strong>和动作等行为的数学模型。</p></blockquote><h4 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2.适用范围"></a>2.适用范围</h4><p>在解决比较繁琐，容易思维混乱的问题时，可以使用有限状态机模型，限定该问题的范围和各种情形，并画出状态转移图或列出表格，以便厘清细节。</p><h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h4><p>链接直达：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转整数（atoi）</a></p><ul><li>题目描述</li></ul><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p><ul><li>状态机表格</li></ul><table><thead><tr><th align="center">状态\条件</th><th align="center">‘ ’</th><th align="center">+/-</th><th align="center">number</th><th align="center">other</th></tr></thead><tbody><tr><td align="center">start</td><td align="center">start</td><td align="center">signed</td><td align="center">get_number</td><td align="center">end</td></tr><tr><td align="center">signed</td><td align="center">end</td><td align="center">end</td><td align="center">get_number</td><td align="center">end</td></tr><tr><td align="center">get_number</td><td align="center">end</td><td align="center">end</td><td align="center">get_number</td><td align="center">end</td></tr><tr><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td><td align="center">end</td></tr></tbody></table><ul><li>题解代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        FSMTable fsm = <span class="hljs-keyword">new</span> FSMTable();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i ++) &#123;<br>            fsm.get(s.charAt(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(fsm.sign * fsm.ans);<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSMTable</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;           <span class="hljs-comment">//符号,1 or -1</span><br>        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;           <span class="hljs-comment">//结果</span><br>        String state = <span class="hljs-string">&quot;start&quot;</span>; <span class="hljs-comment">//记录当前状态,从start状态开始</span><br>        HashMap&lt;String, String[]&gt; table = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FSMTable</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-comment">//构建状态表</span><br>            table.put(<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-keyword">new</span> String[] &#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-string">&quot;get_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>            table.put(<span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-keyword">new</span> String[] &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;get_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>            table.put(<span class="hljs-string">&quot;get_number&quot;</span>, <span class="hljs-keyword">new</span> String[] &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;get_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>            table.put(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-keyword">new</span> String[] &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;);<br>        &#125;<br><br>        <span class="hljs-comment">//获取字符,进行状态转移</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>            state = table.get(state)[judge(c)];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;get_number&quot;</span>.equals(state)) &#123;<br>                ans = ans * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// c - &#x27;0&#x27; 即为字符 c 代表的数字</span><br>                ans = sign == <span class="hljs-number">1</span> ? Math.min((<span class="hljs-keyword">long</span>)Integer.MAX_VALUE, ans) : Math.min(-(<span class="hljs-keyword">long</span>)Integer.MIN_VALUE, ans);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;signed&quot;</span>.equals(state)) &#123;<br>                sign = c == <span class="hljs-string">&#x27;+&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//判断字符，返回状态</span><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>&#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Character.isDigit(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="2021/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>2021/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一、异或"><a href="#一、异或" class="headerlink" title="一、异或"></a>一、异或</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><blockquote><p>二进制数A，B，A异或B表示成：A xor B</p><p>如果AB相同，结果为假；如果AB不同，结果为真</p><p>注：这里的<strong>相同</strong>与<strong>不同</strong>指的是AB的真假，例如AB同为真，或一真一假等情形。</p></blockquote><h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h2><ol><li><code>0</code>异或<code>任何数</code>，都等于它本身</li><li><code>1</code>异或<code>任何数</code>，结果等于该数字的二进制取反的结果</li><li><u>两个相同的数异或，结果为0</u></li></ol><p>上述第三个特点，可以用来找到<strong>若干偶数个</strong>相同数字中唯一一个<strong>个数为奇数</strong>的数字，如3322114，个数为奇数的是4</p><h2 id="3-面试题…"><a href="#3-面试题…" class="headerlink" title="3. 面试题…"></a>3. 面试题…</h2><ul><li><strong>一堆数字，里面有许多出现两次的数字，只有一个数字出现一次，请找出它</strong></li></ul><p>解法：所有数字异或，结果就是只出现一次的数字</p><ul><li><strong>加强版，有两个数字只出现一次，找出它们</strong></li></ul><p>解法：</p><ol><li>先进行一次异或，得到<code>A</code>和<code>B</code>异或后的值</li><li>然后把该值转化成二进制，找到某位是1的<ol><li>为1说明目标数字在这一位上的值是不同的</li><li>因为0与1异或才能得到1</li></ol></li><li>把所有数字，按该位是0或是1，分成两组<ol><li>目标值就分成两组了</li></ol></li><li>对两组分别进行异或，得到两个目标值</li></ol><h1 id="二、与"><a href="#二、与" class="headerlink" title="二、与"></a>二、与</h1><h2 id="1-n-amp-n-1"><a href="#1-n-amp-n-1" class="headerlink" title="1. n &amp; n-1"></a>1. n &amp; n-1</h2><p>该式能把数字n的二进制表示中，最后的一位1变成0</p><p>如：已知$10 = (1010)_2\quad9 = (1001)_2\quad8 = (1000)_2$，10 &amp; (10 - 1) = 1000</p><h1 id="三、左移右移"><a href="#三、左移右移" class="headerlink" title="三、左移右移"></a>三、左移右移</h1><ul><li><p>左移  <code>&lt;&lt;</code></p></li><li><p>右移  <code>&gt;&gt;</code></p></li><li><p>无符号右移  <code>&gt;&gt;&gt;</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="2021/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
      <url>2021/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="笔记——排序"><a href="#笔记——排序" class="headerlink" title="笔记——排序"></a>笔记——排序</h1><h2 id="一、简单排序"><a href="#一、简单排序" class="headerlink" title="一、简单排序"></a>一、简单排序</h2><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><ul><li><p><strong>说明</strong></p><p>每次比较<strong>相邻</strong>两个元素大小，把较大的移到后面</p><p>在第k轮排序完成后（k从1开始），数组的<strong>最后k位</strong>是排好序的</p></li><li><p><strong>代码</strong></p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">//每排完一个元素，i值-1</span><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i -- ) &#123;<br>        <span class="hljs-comment">//比较相邻元素</span><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span> ; j &lt; i; j ++ ) &#123;<br>            <span class="hljs-keyword">if</span> ( nums[j] &gt; nums[j+<span class="hljs-number">1</span>] ) &#123;<br>                <span class="hljs-keyword">int</span> temp = nums[j];<br>                nums[j] = nums[j+<span class="hljs-number">1</span>];<br>                nums[j+<span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>复杂度分析</strong></p><ol><li>时间复杂度为    $O(n^2)$</li></ol></li></ul><hr><h4 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h4><ul><li><strong>组成</strong></li></ul><p><code>已排序 + 未排序</code></p><ul><li><p><strong>说明</strong></p><p>每次在已排序部分的末尾添加一个位置，然后所有未排序元素竞争这个位置，最小的进入</p><p>具体地说，就是从前往后，在数组中找到未排序的位置，然后遍历后面剩余数字，<strong>找到最小的</strong>，交换到前面去</p></li><li><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>[] nums )</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i ++ ) &#123;<br>        <span class="hljs-keyword">int</span> minIndex = i;<span class="hljs-comment">//前i个元素都是排好序的</span><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j ++ ) &#123;<br>            <span class="hljs-keyword">if</span> ( nums[j] &lt; nums[i] ) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> temp = nums[i];<br>        nums[i] = nums[minIndex];<br>        nums[minIndex] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>复杂度分析</strong></p><ol><li>时间复杂度    $O(n^2)$</li></ol></li></ul><hr><h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h4><ul><li><p><strong>说明</strong></p><p>像是打扑克牌一样，每拿到一张牌，就遍历前面，找到合适的位置插入。</p><p>具体来说，应该是从排好序的元素里，<strong>从后往前</strong>依次判断是否要交换</p></li><li><p><strong>对比</strong></p></li></ul><blockquote><p><strong>选择排序</strong>和<strong>插入排序</strong>，都有一部分是排序好的，不同之处在于：</p><p><u><strong>选择排序</strong></u>是从没排序的元素里找到最小的，然后放到已经排序部分的最后；</p><p>而**<u>插入排序</u>**是在已经排序的元素（严格来说，并没有排完序，只是有序）里找到合适的位置，插入当前元素</p></blockquote><ul><li><strong>代码</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>[] nums )</span> </span>&#123;<br>    <span class="hljs-comment">//从第二个元素开始</span><br><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i ++ ) &#123;<br>        <span class="hljs-comment">//依次向前一个元素比较</span><br><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span>; j -- ) &#123;<br><span class="hljs-keyword">if</span> ( nums[j] &lt; nums[j-<span class="hljs-number">1</span>] ) &#123;<br><span class="hljs-keyword">int</span> temp = nums[j-<span class="hljs-number">1</span>];<br>nums[j-<span class="hljs-number">1</span>] = nums[j];<br>nums[j] = temp;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//表明元素已经在正确位置</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>优化版代码</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>[] nums )</span> </span>&#123;<br>    <br><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i ++ ) &#123;<br>        <span class="hljs-comment">// 用临时变量tmp存储当前值</span><br>        <span class="hljs-comment">// 然后让大于tmp的数字都向后移动一位，留出空位来插入</span><br>        <span class="hljs-keyword">int</span> tmp = nums[i]<br><span class="hljs-keyword">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; tmp &lt; nums[j-<span class="hljs-number">1</span>]) &#123;<br>            nums[j] = nums[j-<span class="hljs-number">1</span>];<br>            j--;<br>        &#125;<br>        nums[j] = tmp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>复杂度分析</strong><ol><li>时间复杂度    $O(n^2)$</li></ol></li></ul><hr><h2 id="二、进阶排序"><a href="#二、进阶排序" class="headerlink" title="二、进阶排序"></a>二、进阶排序</h2><h4 id="1-希尔排序-面试不重要"><a href="#1-希尔排序-面试不重要" class="headerlink" title="1.希尔排序(面试不重要)"></a>1.希尔排序(面试不重要)</h4><ul><li><strong>说明</strong></li></ul><ol><li>希尔排序是插入排序的改良版，插入排序在寻找插入位置时，需要进行相邻元素的多次比较与交换，而希尔排序则定义了<code>增长量</code>，可以间隔的比较与交换。</li><li>希尔排序按<code>增长量</code>来分组，对每组数据进行插入排序；然后减小<code>增长量</code>，重复操作。</li></ol><ul><li><strong>代码</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span> <span class="hljs-params">( <span class="hljs-keyword">int</span>[] nums )</span> </span>&#123;<br><span class="hljs-comment">//初始化增长量</span><br><span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> ( h &lt; nums.length/<span class="hljs-number">2</span> ) &#123;<br>h = h * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//开始排序</span><br><span class="hljs-keyword">while</span> ( h &gt;= <span class="hljs-number">1</span> ) &#123;<br><span class="hljs-comment">//进阶版插入排序</span><br><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = h; i &lt; nums.length; i ++ ) &#123;<br><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> j = i; j &gt;= h; j -= h ) &#123;<br><span class="hljs-keyword">if</span> ( nums[j] &lt; nums[j-h] ) &#123;<br><span class="hljs-keyword">int</span> temp = nums[j-h];<br>nums[j-h] = nums[j];<br>nums[j] = temp;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//更新增长量</span><br>h = h / <span class="hljs-number">2</span>;<br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong><del>复杂度分析</del></strong></li></ul><p>emmm……，超纲了，不用了解</p><hr><h4 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h4><ul><li>说明</li></ul><ol><li>快速排序可以看作是冒泡排序的进阶版，区别在于快排的交换是<code>跳跃式</code>的</li><li>快排使用了一个<code>基准点</code>，每次排序的目的都是把小于基准点的数放到基准点左边，大于等于的数放在右边</li><li>数组长度较小时，使用插入排序而不是快速排序</li></ol><ul><li>代码（基础版）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> Random RANDOM = <span class="hljs-keyword">new</span> Random();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArray(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (right - left &lt;= <span class="hljs-number">7</span>) &#123;<br>            insertSort(nums, left, right);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> index = partition(nums, left, right);<br>        quickSort(nums, left, index - <span class="hljs-number">1</span>);<br>        quickSort(nums, index + <span class="hljs-number">1</span>, right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; ++ i) &#123;<br>            <span class="hljs-keyword">int</span> tmp = nums[i];<br>            <span class="hljs-keyword">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &gt; left &amp;&amp; tmp &lt; nums[j-<span class="hljs-number">1</span>]) &#123;<br>                nums[j] = nums[j-<span class="hljs-number">1</span>];<br>                j --;<br>            &#125;<br>            nums[j] = tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> randomIndex = RANDOM.nextInt(right - left + <span class="hljs-number">1</span>) + left; <span class="hljs-comment">// 包含nums[right]</span><br>        swap(nums, left, randomIndex);<br><br>        <span class="hljs-keyword">int</span> pivot = nums[left]; <span class="hljs-comment">// 定义基准值</span><br>        <span class="hljs-keyword">int</span> lt = left;          <span class="hljs-comment">// 小于pivot的最右边</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; pivot) &#123;<br>                lt ++;<br>                swap(nums, lt, i);<br>            &#125;<br>        &#125;<br>        swap(nums, lt, left);<br>        <span class="hljs-keyword">return</span> lt;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> tmp = nums[a];<br>        nums[a] = nums[b];<br>        nums[b] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>双指针碰撞</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> randomIndex = RANDOM.nextInt(right - left + <span class="hljs-number">1</span>) + left; <span class="hljs-comment">// 包含nums[right]</span><br>        swap(nums, left, randomIndex);<br>        <span class="hljs-keyword">int</span> pivot = nums[left];<br>        <span class="hljs-keyword">int</span> lt = left + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> gt = right;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">while</span> (lt &lt;= right &amp;&amp; nums[lt] &lt; pivot) &#123;<br>                lt ++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (gt &gt;= left &amp;&amp; nums[gt] &gt; pivot) &#123;<br>                gt --;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (lt &gt;= gt) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 等概分布</span><br>            swap(nums, lt, gt);<br>            lt ++;<br>            gt --;<br>        &#125;<br>        swap(nums, left, gt);<br>        <span class="hljs-keyword">return</span> gt;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>三指针（相同元素划分到基准值，不进行递归）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 待补充</span><br></code></pre></td></tr></table></figure><ul><li><p>复杂度分析</p><ol><li><p>时间复杂度</p><p>最坏情况为$O(n^2)$，平均为$O(nlogn)$</p></li></ol></li></ul><h4 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h4><ul><li><strong>说明</strong></li></ul><p>将待排序的数字一分为二，排序子数组后，最后进行合并</p><ul><li><strong>优化</strong><ul><li>划分的数组长度小于等于7时，采用插入排序</li><li>使用全局辅助数组temp，避免多次创建</li></ul></li><li><strong>代码</strong></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sortArray(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        part(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, temp);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    *   分治</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt;= <span class="hljs-number">7</span>) &#123;<br>            insertSort(nums, left, right);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = (right + left) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        part(nums, left, mid, temp);<br>        part(nums, mid + <span class="hljs-number">1</span>, right, temp);<br><br>        <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[mid+<span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        merge(nums, left, mid, right, temp);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    *   合并</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br>        System.arraycopy(nums, left, temp, left, right - left + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> i = left;<br>        <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; k ++) &#123;<br>            <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>) &#123;<br>                nums[k] = temp[j];<br>                j++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == right + <span class="hljs-number">1</span>) &#123;<br>                nums[k] = temp[i];<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp[i] &lt;= temp[j]) &#123;<br>                nums[k] = temp[i];<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums[k] = temp[j];<br>                j++;<br>            &#125; <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    *   插入排序</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; i ++) &#123;<br>            <span class="hljs-keyword">int</span> tmp = nums[i];<br>            <span class="hljs-keyword">int</span> j = i;<br>            <span class="hljs-keyword">while</span> (j &gt; left &amp;&amp; tmp &lt; nums[j-<span class="hljs-number">1</span>]) &#123;<br>                nums[j] = nums[j-<span class="hljs-number">1</span>];<br>                j --;<br>            &#125;<br>            nums[j] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>复杂度说明</strong><ul><li>时间复杂度$O(nlogn)$</li><li>空间复杂度$O(n)$</li></ul></li></ul><h4 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4.堆排序"></a>4.堆排序</h4><ul><li>说明</li></ul><p>用数组实现，先按大根堆来建堆，然后下沉后形成升序的数组。</p><ul><li>实现</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = (nums.length - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <br>        adjustHeap(nums, i, nums.length);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; --j) &#123;<br>        swap(nums, <span class="hljs-number">0</span>, j);<br>        adjustHeap(nums, <span class="hljs-number">0</span>, j);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tmp = nums[index1];<br>    nums[index1] = nums[index2];<br>    nums[index2] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="三、排序算法的稳定性总结"><a href="#三、排序算法的稳定性总结" class="headerlink" title="三、排序算法的稳定性总结"></a>三、排序算法的稳定性总结</h2><table><thead><tr><th align="center">排序算法</th><th align="center">是否稳定</th><th align="center">原因</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">稳定</td><td align="center">因为只有前一个元素大于后一个元素时，才发生交换</td></tr><tr><td align="center">选择排序</td><td align="center">不稳定</td><td align="center">为每个位置选择当前最小的元素进行交换，会破坏稳定性</td></tr><tr><td align="center">插入排序</td><td align="center">稳定</td><td align="center">原因和冒泡排序类似，只有大于时才插入到其后面</td></tr><tr><td align="center">希尔排序</td><td align="center">不稳定</td><td align="center">首次排序时是稳定的，但他分成了好几组，不同组之间排序时可能会打乱顺序</td></tr><tr><td align="center">快速排序</td><td align="center">不稳定</td><td align="center">基准值左右两侧交换时会破坏稳定性</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
