<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<!-- Referrer Policy调整致不蒜子单页面统计出错:https://senorui.top/posts/c33f.html -->
<meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aurora-ze.github.io.git","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="生产者消息分区策略问题：当生产者向包含多个分区的Topic发送消息时，消息会发往哪个分区呢？ 解释：  发送时指定partition：发送到指定分区 发送时未指定partition：由分区器来决定  在Kafka生产者中分区器主要有两种，默认分区器和轮询分区器。 一、默认分区器默认分区器利用了粘性分区的思想。  粘性分区表示在Kafka一次批量发送消息的过程中，会尽可能的减少分区的分配变动。 因此">
<meta property="og:type" content="article">
<meta property="og:title" content="生产者与消费者理论">
<meta property="og:url" content="https://aurora-ze.github.io.git/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%90%86%E8%AE%BA/index.html">
<meta property="og:site_name" content="Aurora">
<meta property="og:description" content="生产者消息分区策略问题：当生产者向包含多个分区的Topic发送消息时，消息会发往哪个分区呢？ 解释：  发送时指定partition：发送到指定分区 发送时未指定partition：由分区器来决定  在Kafka生产者中分区器主要有两种，默认分区器和轮询分区器。 一、默认分区器默认分区器利用了粘性分区的思想。  粘性分区表示在Kafka一次批量发送消息的过程中，会尽可能的减少分区的分配变动。 因此">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111211654366.png">
<meta property="article:published_time" content="2021-12-13T12:06:09.846Z">
<meta property="article:modified_time" content="2021-12-13T12:00:45.477Z">
<meta property="article:author" content="aurora">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111211654366.png">

<link rel="canonical" href="https://aurora-ze.github.io.git/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%90%86%E8%AE%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>生产者与消费者理论 | Aurora</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?dcdb42c8e3ad5d5a7981af32b9693ef3";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Aurora" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Aurora</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">矢志前行，拥抱未来！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aurora-ze.github.io.git/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
      <meta itemprop="name" content="aurora">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Aurora">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          生产者与消费者理论
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-13 20:06:09 / 修改时间：20:00:45" itemprop="dateCreated datePublished" datetime="2021-12-13T20:06:09+08:00">2021-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><h2 id="消息分区策略"><a href="#消息分区策略" class="headerlink" title="消息分区策略"></a>消息分区策略</h2><p>问题：当生产者向包含多个分区的Topic发送消息时，消息会发往哪个分区呢？</p>
<p>解释：</p>
<ol>
<li>发送时指定<code>partition</code>：发送到指定分区</li>
<li>发送时未指定<code>partition</code>：由分区器来决定</li>
</ol>
<p>在Kafka生产者中分区器主要有两种，默认分区器和轮询分区器。</p>
<h3 id="一、默认分区器"><a href="#一、默认分区器" class="headerlink" title="一、默认分区器"></a>一、默认分区器</h3><p>默认分区器利用了<code>粘性分区</code>的思想。</p>
<blockquote>
<p><code>粘性分区</code>表示在Kafka一次批量发送消息的过程中，会尽可能的减少分区的分配变动。</p>
<p>因此分区就是具备粘性的，在同一次批量发送中消息就会分配到同一个分区。</p>
</blockquote>
<h5 id="DefaultPartitioner"><a href="#DefaultPartitioner" class="headerlink" title="DefaultPartitioner"></a>DefaultPartitioner</h5><p><code>partition()</code>计算得到要发送的分区号，源码如下：</p>
<ol>
<li>未指定key时，用粘性分区缓存来获取分区号</li>
<li>指定key时，通过计算哈希值并求余的方式得到分区号。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> stickyPartitionCache.partition(topic, cluster);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StickyPartitionCache"><a href="#StickyPartitionCache" class="headerlink" title="StickyPartitionCache"></a>StickyPartitionCache</h5><p><code>StickyPartitionCache</code>类主要利用利用map记录主题和消息发往的分区号的映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StickyPartitionCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Integer&gt; indexCache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StickyPartitionCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.indexCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * partition()返回分区号</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 如果在map中找到了上次发往某个主题时分配的分区号，就返回该分区号（粘性分区）</span></span><br><span class="line"><span class="comment">    * 如果map中未找到，则调用nextPartition()执行一次重新分配分区号的动作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        Integer part = indexCache.get(topic);</span><br><span class="line">        <span class="keyword">if</span> (part == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nextPartition(topic, cluster, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> part;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、轮询分区器"><a href="#二、轮询分区器" class="headerlink" title="二、轮询分区器"></a>二、轮询分区器</h3><p>从<code>RoundRobinPartitioner</code>类的注解可以看到，如果希望消息能够分布式的写到不同的分区上，那么就可以使用轮询分区器。</p>
<p>它具备两个特点：</p>
<ol>
<li>平等的写入到每个分区</li>
<li>消息设置的key不会生效（即不会对它求hash来取值）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &quot;Round-Robin&quot; partitioner</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This partitioning strategy can be used when user wants </span></span><br><span class="line"><span class="comment"> * to distribute the writes to all partitions equally. This</span></span><br><span class="line"><span class="comment"> * is the behaviour regardless of record key hash. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="nextValue"><a href="#nextValue" class="headerlink" title="nextValue()"></a>nextValue()</h5><p>在map寻找topic对应的分区号，未找到则返回0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">nextValue</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">    AtomicInteger counter = topicCounterMap.computeIfAbsent(topic, k -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> counter.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="partition"><a href="#partition" class="headerlink" title="partition()"></a>partition()</h5><p>借助<code>nextValue()</code>返回的值来求余计算分区号。</p>
<p>此外，这里还有一些额外的逻辑，如判断是否有可用分区和确保nextValue为正。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">    List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">    <span class="keyword">int</span> nextValue = nextValue(topic);</span><br><span class="line">    List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">if</span> (!availablePartitions.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">        <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产者过程分析"><a href="#生产者过程分析" class="headerlink" title="生产者过程分析"></a>生产者过程分析</h2><p>生产者主要使用两个线程：主线程和Sender线程</p>
<p>主线程调用<code>send()</code>后，依次经过了<code>拦截器-序列化器-分区器</code>，然后被添加到消息累计器中。然后由Sender线程获取消息并发送给broker。</p>
<p><img data-src="https://raw.githubusercontent.com/Aurora-Ze/pictures/master/img/202111211654366.png" alt="image-20211118170513669"></p>
<h3 id="一、消息累加器"><a href="#一、消息累加器" class="headerlink" title="一、消息累加器"></a>一、消息累加器</h3><p>在消息累加器中，每个分区都会对应一条队列，经过分区器计算或是直接指定分区的消息，便会加入到对应的队列中。</p>
<p>消息累加器<code>RecordAccumulator</code>使用map存储了某个主题下每个分区和队列的映射关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordAccumulator</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; batches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>队列中的<code>ProducerBatch</code>对象表示批量的记录，分配消息时会取出队列的最后一条batch记录，并把消息添加在batch中。</p>
<p>这里对应的就是<code>ProducerBatch</code>类下的tryAppend()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 检查空间后，调用MemoryRecordsBuilder对象的append方法来向内存中写入新消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FutureRecordMetadata <span class="title">tryAppend</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value, Header[] headers, Callback callback, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.recordsBuilder.append(timestamp, key, value, headers); </span><br><span class="line">        <span class="keyword">this</span>.maxRecordSize = Math.max(<span class="keyword">this</span>.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(),</span><br><span class="line">                recordsBuilder.compressionType(), key, value, headers));</span><br><span class="line">        <span class="keyword">this</span>.lastAppendTime = now;</span><br><span class="line">        FutureRecordMetadata future = <span class="keyword">new</span> FutureRecordMetadata(<span class="keyword">this</span>.produceFuture, <span class="keyword">this</span>.recordCount,</span><br><span class="line">                                                               timestamp,</span><br><span class="line">                                                               key == <span class="keyword">null</span> ? -<span class="number">1</span> : key.length,</span><br><span class="line">                                                               value == <span class="keyword">null</span> ? -<span class="number">1</span> : value.length,</span><br><span class="line">                                                               Time.SYSTEM);</span><br><span class="line">        <span class="comment">// we have to keep every future returned to the users in case the batch needs to be</span></span><br><span class="line">        <span class="comment">// split to several new batches and resent.</span></span><br><span class="line">        thunks.add(<span class="keyword">new</span> Thunk(callback, future));</span><br><span class="line">        <span class="keyword">this</span>.recordCount++;</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h2><h3 id="一、位移提交"><a href="#一、位移提交" class="headerlink" title="一、位移提交"></a>一、位移提交</h3><p><strong>对于Kafka分区而言，它的每条消息都有唯一的offset，用来表示消息在分区中的位置；而消费者也是通过offset来得知上次消费消息的位置。</strong></p>
<h5 id="那么这个位移存在哪儿？"><a href="#那么这个位移存在哪儿？" class="headerlink" title="那么这个位移存在哪儿？"></a>那么这个位移存在哪儿？</h5><p>旧版存在ZooKeeper中，新版存在Kafka Broker的<code>__consumer_offsets</code>主题中。</p>
<h5 id="什么是位移提交？为什么要提交位移？"><a href="#什么是位移提交？为什么要提交位移？" class="headerlink" title="什么是位移提交？为什么要提交位移？"></a>什么是位移提交？为什么要提交位移？</h5><p>消费者将消费的位移提交到Kafka Broker的动作，就是<strong>位移提交</strong>。而之所以需要提交，是因为消费者使用拉取消息的方式，Kafka并不知道消费者消费到哪儿了，需要消费者来告诉它。</p>
<h5 id="怎样进行位移提交"><a href="#怎样进行位移提交" class="headerlink" title="怎样进行位移提交?"></a>怎样进行位移提交?</h5><p>Kafka提供了<strong>自动提交</strong>和<strong>手动提交</strong>两种方式。</p>
<p>首先，确认一点，提交的位移指的是下一次要消费的消息所在的偏移量。</p>
<p><strong>自动提交</strong></p>
<p>自动提交指的是Kafka会定期的提交一次位移，定期由两个参数来配置：</p>
<ul>
<li><p><code>enable.auto.commit</code>：是否开启自动提交，默认为true</p>
</li>
<li><p><code>auto.commit.interval.ms</code>：自动提交的间隔，默认为5秒</p>
</li>
</ul>
<p>自动提交存在的问题：</p>
<ol>
<li><code>重复消费</code>：因为位移是延后提交的，所以存在消费者消费之后，还没来得及提交位移就宕机的可能。</li>
<li><code>消息丢失</code>：如果消费者端把读到的消息放入队列中等待另一个线程处理，那么有可能提交位移后消费者宕机，处理线程还未处理消息。</li>
</ol>
<p><strong>手动提交</strong></p>
<p>手动提交可以让开发人员根据程序的逻辑在合适的地方提交位移，<strong>注意，采用手动提交时必须关闭自动提交</strong>。</p>
<p>手动提交的时机非常重要：</p>
<ol>
<li>如果先提交再处理消息，消息可能还没处理消费者就宕机了，导致<strong>消息丢失</strong>。</li>
<li>如果先处理再提交，提交位移前消费者宕机就会造成<strong>重复消费</strong>。</li>
</ol>
<p>如果希望消息精确的只被消费一次，可以采用二阶段提交的方式：落表，并在消息处理前判断是否已存在记录。（还是有缺陷？何时落表？）</p>
<h2 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h2><p>分区分配策略：</p>
<ol>
<li>决定了处于同一消费者组中的消费者该消费哪个分区</li>
<li>保证一个分区只能被同一个消费者组中的一个消费者消费</li>
</ol>
<p>如果要打破<code>2</code>的限制</p>
<h3 id="一、RangeAssignor"><a href="#一、RangeAssignor" class="headerlink" title="一、RangeAssignor"></a>一、RangeAssignor</h3><h5 id="1-1分配原理"><a href="#1-1分配原理" class="headerlink" title="1.1分配原理"></a>1.1分配原理</h5><p>对<code>单个主题</code>的所有分区进行平均分配。</p>
<ul>
<li>如果分区数与消费者数能够整除，那么每个消费者分配到的分区数量都是一样的。</li>
<li>如果有余数，那么把余数分区一份份分给靠前（排序后）的消费者</li>
</ul>
<h5 id="1-2示例"><a href="#1-2示例" class="headerlink" title="1.2示例"></a>1.2示例</h5><blockquote>
<p>两个消费者订阅两个主题，每个主题3个分区。</p>
<p>如主题t0的分区为t0p0、t0p1、t0p2</p>
</blockquote>
<p>对于一个主题来说，每个消费者先分配1个分区，然后多余的1个分区分给第一个消费者。</p>
<p><strong>分配t0后的结果：</strong></p>
<ul>
<li>消费者C0：t0p0、t0p1</li>
<li>消费者C1：t0p2</li>
</ul>
<p><strong>然后分配t1后的结果：</strong></p>
<ul>
<li>消费者C0：t0p0、t0p1、t1p0、t1p1</li>
<li>消费者C1：t0p2、t1p2</li>
</ul>
<p>设想一下，如果新订阅了第三个主题（分区数为3），那么消费者C0所分配到的分区数还会多两个，<strong>不均衡</strong>的情况会更加严重。</p>
<h5 id="1-3特点"><a href="#1-3特点" class="headerlink" title="1.3特点"></a>1.3特点</h5><p>通过上述例子可以发现，<code>Range</code>策略可以保证<strong>分配一个主题的分区时每个消费者所分配到的分区数之差在一个以内。</strong></p>
<p>但是，当订阅多个主题时可能会存在某个消费者过载的问题，并且可能会随着订阅主题数的增加而愈发严重。</p>
<h3 id="二、RoundRobinAssingor"><a href="#二、RoundRobinAssingor" class="headerlink" title="二、RoundRobinAssingor"></a>二、RoundRobinAssingor</h3><h5 id="2-1分配原理"><a href="#2-1分配原理" class="headerlink" title="2.1分配原理"></a>2.1分配原理</h5><p>对消费者组订阅的<code>所有主题及分区</code>进行排序并依次分配。</p>
<h5 id="2-2示例1-同上述的例子"><a href="#2-2示例1-同上述的例子" class="headerlink" title="2.2示例1@同上述的例子"></a>2.2示例1<code>@同上述的例子</code></h5><blockquote>
<p>两个消费者订阅两个主题，每个主题3个分区。</p>
<p>所有订阅主题的分区排序：t0p0、t0p1、t0p2、t1p0、t1p1、t1p2</p>
</blockquote>
<p>分配结果（依次分配给消费者）：</p>
<ul>
<li>消费者C0：t0p0、t0p2、t1p1</li>
<li>消费者C1：t0p1、t1p0、t1p2</li>
</ul>
<p>可以看到，如果每个消费者订阅的主题是相同的，那么可以保证尽可能的均匀分配。</p>
<h5 id="2-3示例2-订阅不同主题"><a href="#2-3示例2-订阅不同主题" class="headerlink" title="2.3示例2@订阅不同主题"></a>2.3示例2<code>@订阅不同主题</code></h5><p>再看这个订阅不同主题的例子：</p>
<blockquote>
<p>三个消费者，订阅情况分别是：C0订阅t0，C1订阅t0、t1，C2订阅t0、t1、t2</p>
<p>主题分别有1，2，3个分区</p>
</blockquote>
<p>因为消费者C0和C1没有订阅所有主题，因此并不会参与所有主题分区的分配</p>
<p>所有分区排序：t0p0、t1p0、t1p1、t2p0、t2p1、t2p2</p>
<p>分配结果：</p>
<ul>
<li>消费者C0：t0p0</li>
<li>消费者C1：t1p0</li>
<li>消费者C2：t1p1、t2p0、t2p1、t2p2</li>
</ul>
<h5 id="2-4特点"><a href="#2-4特点" class="headerlink" title="2.4特点"></a>2.4特点</h5><p>和<code>RangeAssignor</code>相比，<code>RoundRobinAssignor</code>通过从多主题的角度考虑，保证了当每个消费者订阅相同的主题时的分配均衡（最多差一个）。</p>
<p>但是订阅的主题不同时，它并没有做到最优分配，例如上述例子中<code>t1p1</code>可以分配给C1</p>
<h3 id="三、StickyAssingor"><a href="#三、StickyAssingor" class="headerlink" title="三、StickyAssingor"></a>三、StickyAssingor</h3><p>粘性分配的目的：</p>
<ol>
<li>与其他分配策略一样，尽量保证分区的分配均衡。</li>
<li>进行<strong>再分配</strong>时，尽可能的减少分配的变化，即拥有“粘性”</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="一、消息丢失问题"><a href="#一、消息丢失问题" class="headerlink" title="一、消息丢失问题"></a>一、消息丢失问题</h3><p>Kafka生产者与消费者都有可能存在消息丢失的问题。</p>
<h5 id="生产者端"><a href="#生产者端" class="headerlink" title="生产者端"></a>生产者端</h5><p>原因在于<code>ack</code>的取值，值为0或1时没有做到所有副本的消息同步，因此副本宕机会造成消息丢失。</p>
<p><code>ack</code>取-1时所有副本同步后才算消息写入成功，但这样消息吞吐量会有所损失。</p>
<h5 id="消费者端"><a href="#消费者端" class="headerlink" title="消费者端"></a>消费者端</h5><p>原因可能是开启了自动提交位移，也可能是手动提交位移的情况下先提交再消费。</p>
<p>如何解决可以看上述的<strong>手动提交</strong>部分。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>aurora
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://aurora-ze.github.io.git/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E7%90%86%E8%AE%BA/" title="生产者与消费者理论">https://aurora-ze.github.io.git/2021/12/13/中间件/kafka/三、生产者与消费者理论/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%80%E3%80%81Kafka%E5%AE%89%E8%A3%85%E4%B8%8E%E5%85%A5%E9%97%A8/" rel="prev" title="环境搭建">
      <i class="fa fa-chevron-left"></i> 环境搭建
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%9E%E8%B7%B5/" rel="next" title="生产者与消费者实践">
      生产者与消费者实践 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-text">生产者</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E7%AD%96%E7%95%A5"><span class="nav-text">消息分区策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%BB%98%E8%AE%A4%E5%88%86%E5%8C%BA%E5%99%A8"><span class="nav-text">一、默认分区器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DefaultPartitioner"><span class="nav-text">DefaultPartitioner</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#StickyPartitionCache"><span class="nav-text">StickyPartitionCache</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%BD%AE%E8%AF%A2%E5%88%86%E5%8C%BA%E5%99%A8"><span class="nav-text">二、轮询分区器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#nextValue"><span class="nav-text">nextValue()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#partition"><span class="nav-text">partition()</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-text">生产者过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="nav-text">一、消息累加器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-text">消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="nav-text">消费消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BD%8D%E7%A7%BB%E6%8F%90%E4%BA%A4"><span class="nav-text">一、位移提交</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AA%E4%BD%8D%E7%A7%BB%E5%AD%98%E5%9C%A8%E5%93%AA%E5%84%BF%EF%BC%9F"><span class="nav-text">那么这个位移存在哪儿？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8D%E7%A7%BB%E6%8F%90%E4%BA%A4%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8F%90%E4%BA%A4%E4%BD%8D%E7%A7%BB%EF%BC%9F"><span class="nav-text">什么是位移提交？为什么要提交位移？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%8E%E6%A0%B7%E8%BF%9B%E8%A1%8C%E4%BD%8D%E7%A7%BB%E6%8F%90%E4%BA%A4"><span class="nav-text">怎样进行位移提交?</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-text">分区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81RangeAssignor"><span class="nav-text">一、RangeAssignor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86"><span class="nav-text">1.1分配原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2%E7%A4%BA%E4%BE%8B"><span class="nav-text">1.2示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3%E7%89%B9%E7%82%B9"><span class="nav-text">1.3特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81RoundRobinAssingor"><span class="nav-text">二、RoundRobinAssingor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1%E5%88%86%E9%85%8D%E5%8E%9F%E7%90%86"><span class="nav-text">2.1分配原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2%E7%A4%BA%E4%BE%8B1-%E5%90%8C%E4%B8%8A%E8%BF%B0%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-text">2.2示例1@同上述的例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3%E7%A4%BA%E4%BE%8B2-%E8%AE%A2%E9%98%85%E4%B8%8D%E5%90%8C%E4%B8%BB%E9%A2%98"><span class="nav-text">2.3示例2@订阅不同主题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4%E7%89%B9%E7%82%B9"><span class="nav-text">2.4特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81StickyAssingor"><span class="nav-text">三、StickyAssingor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="nav-text">一、消息丢失问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E7%AB%AF"><span class="nav-text">生产者端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF"><span class="nav-text">消费者端</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="aurora"
      src="https://gitee.com/aurora1004/pictures/raw/master/sky-5375005_1920.jpg">
  <p class="site-author-name" itemprop="name">aurora</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">144</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Aurora-Ze" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Aurora-Ze" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:88775682whz@gmail.com" title="E-Mail → mailto:88775682whz@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      
      
       <div>
          <iframe class="cc-license motion-element" frameborder="no" border="0" marginwidth="0" marginheight="0" width="280" height="86" src="//music.163.com/outchain/player?type=2&id=3986241&auto=1&height=32"></iframe>
       </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aurora</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
    <span class="post-count">| 博客共95.3k字</span>
  </div>-->


<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("04/07/2021 15:54:40");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

        








      </div>
    </footer>
  </div>

  


  <script src=""></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/darkmode-js.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>


<script>
var options = {
  bottom: '64px', // default: '32px'
  right: 'unset', // default: '32px'
  left: '32px', // default: 'unset'
  time: '0.5s', // default: '0.3s'
  mixColor: 'transparent', // default: '#fff'
  backgroundColor: 'transparent',  // default: '#fff'
  buttonColorDark: '#100f2c',  // default: '#100f2c'
  buttonColorLight: '#fff', // default: '#fff'
  saveInCookies: true, // default: true,
  label: '🌓', // default: ''
  autoMatchOsTheme: true // default: true
}
const darkmode = new Darkmode(options);
darkmode.showWidget();
</script>
<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
